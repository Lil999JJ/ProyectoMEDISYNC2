"""
MEDISYNC - Sistema Integral de Gesti√≥n M√©dica
Versi√≥n Restaurada - Completamente Funcional
"""

import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
import sqlite3
import hashlib
from datetime import datetime, date, timedelta
from typing import List, Optional, Dict, Any
from dataclasses import dataclass
import json
import os
import subprocess

# Importar calendario si est√° disponible
try:
    from tkcalendar import Calendar, DateEntry
    CALENDAR_AVAILABLE = True
except ImportError:
    CALENDAR_AVAILABLE = False
    print("‚ö†Ô∏è tkcalendar no disponible - usando entrada de texto para fechas")

# Importar reportlab para generar PDFs
try:
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib import colors
    from reportlab.lib.units import inch, cm
    PDF_AVAILABLE = True
except ImportError:
    PDF_AVAILABLE = False
    print("‚ö†Ô∏è reportlab no disponible - funcionalidad PDF limitada")

# Importar database manager
try:
    from database_manager import DatabaseManager as DBManager
    print("‚úÖ Usando DatabaseManager principal")
except ImportError:
    try:
        from simple_database_manager import SimpleDatabaseManager as DBManager
        print("‚úÖ Usando SimpleDatabaseManager como respaldo")
    except ImportError:
        print("‚ùå Error: No se pudo importar ning√∫n database manager")
        exit(1)

class MedisyncApp:
    """Aplicaci√≥n principal de MEDISYNC"""
    
    def __init__(self, root=None):
        self.db_manager = DBManager('database/medisync.db')
        self.current_user = None
        self.root = root
        self.users_tree = None
        if root is None:
            self.create_login_window()
        else:
            self.setup_root_window()
    
    def setup_root_window(self):
        """Configurar ventana principal cuando se pasa root"""
        if self.root:
            self.root.title("MEDISYNC - Sistema de Gesti√≥n M√©dica")
            self.root.geometry("500x400")
            self.root.configure(bg='#F8FAFC')
            # Aplicar tema moderno ttk
            try:
                from ui_theme import apply_theme
                apply_theme(self.root)
            except Exception as _e:
                pass
    
    def create_login_window(self):
        """Crear ventana de login moderna y est√©tica"""
        if self.root is None:
            self.root = tk.Tk()
        
        self.root.title("MEDISYNC - Sistema de Gesti√≥n M√©dica")
        self.root.geometry("750x850")
        self.root.resizable(False, False)
        
        # Centrar ventana
        self.center_window(self.root, 750, 850)
        
        # Aplicar tema ttk
        try:
            from ui_theme import apply_theme
            apply_theme(self.root)
        except Exception:
            pass

        # Configurar fondo
        self.root.configure(bg='#F8FAFC')
        
        # Frame principal con padding
        main_frame = tk.Frame(self.root, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=40, pady=30)
        
        # Header
        header_frame = tk.Frame(main_frame, bg='#F8FAFC')
        header_frame.pack(fill='x', pady=(0, 30))
        
        # Icono m√©dico
        icon_frame = tk.Frame(header_frame, bg='#0B5394', width=80, height=80)
        icon_frame.pack(pady=(0, 15))
        icon_frame.pack_propagate(False)
        
        tk.Label(icon_frame, text="üè•", font=('Arial', 40), bg='#0B5394', fg='white').pack(expand=True)
        
        # T√≠tulo principal
        title_label = tk.Label(header_frame, text="MEDISYNC", 
                              font=('Arial', 28, 'bold'), fg='#1E293B', bg='#F8FAFC')
        title_label.pack()
        
        subtitle_label = tk.Label(header_frame, text="Sistema Integral de Gesti√≥n M√©dica", 
                                 font=('Arial', 14, 'italic'), fg='#64748B', bg='#F8FAFC')
        subtitle_label.pack(pady=(5, 0))
        
        # Frame del formulario
        form_outer_frame = tk.Frame(main_frame, bg='#E2E8F0', relief='raised', bd=2)
        form_outer_frame.pack(fill='x', pady=(0, 20))
        
        form_frame = tk.Frame(form_outer_frame, bg='white', padx=40, pady=30)
        form_frame.pack(fill='x', padx=3, pady=3)
        
        # T√≠tulo del formulario
        form_title = tk.Label(form_frame, text="üîê Iniciar Sesi√≥n", 
                             font=('Arial', 18, 'bold'), fg='#0B5394', bg='white')
        form_title.pack(pady=(0, 25))
        
        # Campo Email
        email_frame = tk.Frame(form_frame, bg='white')
        email_frame.pack(fill='x', pady=(0, 20))
        
        tk.Label(email_frame, text="üìß Correo Electr√≥nico", 
                font=('Arial', 12, 'bold'), fg='#1E293B', bg='white').pack(anchor='w')
        
        email_input_frame = tk.Frame(email_frame, bg='#F8FAFC', relief='solid', bd=1)
        email_input_frame.pack(fill='x', pady=(5, 0))
        
        self.email_entry = tk.Entry(email_input_frame, font=('Arial', 12), bg='#F8FAFC', 
                                   relief='flat', bd=0)
        self.email_entry.pack(fill='x', padx=10, pady=8)
        
        # Campo Contrase√±a
        password_frame = tk.Frame(form_frame, bg='white')
        password_frame.pack(fill='x', pady=(0, 25))
        
        tk.Label(password_frame, text="üîí Contrase√±a", 
                font=('Arial', 12, 'bold'), fg='#1E293B', bg='white').pack(anchor='w')
        
        password_input_frame = tk.Frame(password_frame, bg='#F8FAFC', relief='solid', bd=1)
        password_input_frame.pack(fill='x', pady=(5, 0))
        
        self.password_entry = tk.Entry(password_input_frame, font=('Arial', 12), bg='#F8FAFC', 
                                      relief='flat', bd=0, show='*')
        self.password_entry.pack(fill='x', padx=10, pady=8)
        
        # Botones
        buttons_frame = tk.Frame(form_frame, bg='white')
        buttons_frame.pack(fill='x', pady=(0, 10))
        
        buttons_row_frame = tk.Frame(buttons_frame, bg='white')
        buttons_row_frame.pack(fill='x', pady=(0, 10))
        
        # Bot√≥n de login
        login_btn = tk.Button(buttons_row_frame, text="üöÄ INICIAR SESI√ìN", 
                             font=('Arial', 12, 'bold'), bg='#0B5394', fg='white',
                             command=self.login, relief='flat', bd=0,
                             padx=15, pady=12, cursor='hand2')
        login_btn.pack(side='left', fill='x', expand=True, padx=(0, 5))
        
        # Bot√≥n de registro
        register_btn = tk.Button(buttons_row_frame, text="üë§ CREAR CUENTA", 
                               font=('Arial', 12, 'bold'), bg='#0B5394', fg='white',
                               command=self.show_patient_registration, relief='flat', bd=0,
                               padx=15, pady=12, cursor='hand2')
        register_btn.pack(side='right', fill='x', expand=True, padx=(5, 0))
        
        # Info de usuarios de prueba
        info_outer_frame = tk.Frame(main_frame, bg='#FFFFFF', relief='solid', bd=1)
        info_outer_frame.pack(fill='x', pady=(0, 10))
        
        info_frame = tk.Frame(info_outer_frame, bg='#FFFFFF', padx=20, pady=15)
        info_frame.pack(fill='x')
        
        tk.Label(info_frame, text="üí° Usuarios de Prueba", 
                font=('Arial', 12, 'bold'), fg='#1E293B', bg='#FFFFFF').pack(pady=(0, 10))
        
        users_info = [
            ("üõ°Ô∏è Administrador:", "admin@medisync.com / admin123"),
            ("üë®‚Äç‚öïÔ∏è Doctor:", "carlos@medisync.com / doctor123"),
            ("üë©‚Äçüíº Secretaria:", "maria@medisync.com / secretaria123"),
            ("ü§í Paciente:", "pedro@medisync.com / paciente123")
        ]
        
        for role, credentials in users_info:
            user_frame = tk.Frame(info_frame, bg='#FFFFFF')
            user_frame.pack(fill='x', pady=2)
            
            tk.Label(user_frame, text=role, font=('Arial', 10, 'bold'), 
                    fg='#1E293B', bg='#FFFFFF').pack(side='left')
            tk.Label(user_frame, text=credentials, font=('Arial', 10), 
                    fg='#64748B', bg='#FFFFFF').pack(side='left', padx=(10, 0))
        
        # Footer
        footer_frame = tk.Frame(main_frame, bg='#F8FAFC')
        footer_frame.pack(side='bottom', fill='x')
        
        tk.Label(footer_frame, text="¬© 2025 MEDISYNC - Todos los derechos reservados", 
                font=('Arial', 9), fg='#64748B', bg='#F8FAFC').pack(pady=5)
        
        # Bind Enter key
        self.root.bind('<Return>', lambda e: self.login())
        self.email_entry.focus_set()
        
        self.root.mainloop()
    
    def show_patient_registration(self):
        """Mostrar formulario de registro de pacientes"""
        try:
            from patient_registration_form import create_patient_registration_form
            create_patient_registration_form(self.root, self.db_manager)
        except ImportError:
            messagebox.showerror("Error", "No se pudo cargar el formulario de registro.")
        except Exception as e:
            messagebox.showerror("Error", f"Error al abrir el formulario: {e}")
    
    def center_window(self, window, width, height):
        """Centrar ventana en la pantalla"""
        screen_width = window.winfo_screenwidth()
        screen_height = window.winfo_screenheight()
        x = (screen_width - width) // 2
        y = (screen_height - height) // 2
        window.geometry(f"{width}x{height}+{x}+{y}")
    
    def login(self):
        """Procesar login"""
        email = self.email_entry.get().strip()
        password = self.password_entry.get().strip()
        
        if not email or not password:
            messagebox.showerror("Error", "Por favor ingrese email y contrase√±a")
            return
        
        user = self.db_manager.authenticate_user(email, password)
        
        if user:
            self.current_user = user
            self.root.destroy()
            self.create_main_window()
        else:
            messagebox.showerror("Error", "Credenciales inv√°lidas")
            self.password_entry.delete(0, tk.END)
    
    def create_main_window(self):
        """Crear ventana principal seg√∫n el rol del usuario"""
        self.root = tk.Tk()
        self.root.title(f"MEDISYNC - {self.current_user.nombre} {self.current_user.apellido} ({self.current_user.tipo_usuario.title()})")
        
        # Configurar pantalla completa
        self.root.state('zoomed')  # Para Windows - pantalla completa
        self.root.configure(bg='#F8FAFC')
        
        # Opcional: permitir salir de pantalla completa con Escape
        self.root.bind('<Escape>', lambda e: self.root.state('normal'))
        self.root.bind('<F11>', lambda e: self.toggle_fullscreen())
        
        self.create_menu_interface()
        
        self.root.mainloop()
    
    def toggle_fullscreen(self):
        """Alternar entre pantalla completa y ventana normal"""
        if self.root.state() == 'zoomed':
            self.root.state('normal')
            self.root.geometry("1200x800")
            self.center_window(self.root, 1200, 800)
        else:
            self.root.state('zoomed')
    
    def create_menu_interface(self):
        """Crear interfaz de men√∫ principal"""
        # Frame principal
        main_frame = tk.Frame(self.root, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Header
        header_frame = tk.Frame(main_frame, bg='#1E3A8A', height=80)
        header_frame.pack(fill='x', pady=(0, 20))
        header_frame.pack_propagate(False)
        
        # T√≠tulo en header
        tk.Label(header_frame, text="MEDISYNC", font=('Arial', 20, 'bold'), 
                fg='white', bg='#1E3A8A').pack(side='left', padx=20, pady=20)
        
        # Info usuario en header
        user_info = f"{self.current_user.nombre} {self.current_user.apellido} - {self.current_user.tipo_usuario.title()}"
        tk.Label(header_frame, text=user_info, font=('Arial', 12), 
                fg='white', bg='#1E3A8A').pack(side='right', padx=20, pady=20)
        
        # Bot√≥n logout
        logout_btn = tk.Button(header_frame, text="Cerrar Sesi√≥n", command=self.logout,
                              bg='#0B5394', fg='white', font=('Arial', 10))
        logout_btn.pack(side='right', padx=(0, 20), pady=20)
        
        # Contenido principal
        content_frame = tk.Frame(main_frame, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True)
        
        # Crear men√∫ seg√∫n rol
        if self.current_user.tipo_usuario == 'admin':
            self.create_admin_menu(content_frame)
        elif self.current_user.tipo_usuario == 'doctor':
            self.create_doctor_menu(content_frame)
        elif self.current_user.tipo_usuario == 'secretaria':
            self.create_secretaria_menu(content_frame)
        elif self.current_user.tipo_usuario == 'paciente':
            self.create_paciente_menu(content_frame)
    
    def create_admin_menu(self, parent):
        """Crear men√∫ de administrador con dise√±o moderno"""
        # Frame principal para el men√∫
        menu_container = tk.Frame(parent, bg='#F8FAFC')
        menu_container.pack(fill='both', expand=True)
        
        # Header del men√∫ con estilo moderno
        header_frame = tk.Frame(menu_container, bg='#1E3A8A', height=70)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Contenido del header
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=30, pady=10)
        
        # Logo y t√≠tulo
        title_frame = tk.Frame(header_content, bg='#1E3A8A')
        title_frame.pack(side='left', expand=True, fill='both')
        
        tk.Label(title_frame, text="üè•", font=('Arial', 20), bg='#1E3A8A', fg='white').pack(side='left', pady=5)
        tk.Label(title_frame, text="MEDISYNC", font=('Arial', 18, 'bold'), bg='#1E3A8A', fg='white').pack(side='left', padx=(10, 0), pady=5)
        tk.Label(title_frame, text="Panel de Administraci√≥n", font=('Arial', 12), bg='#1E3A8A', fg='#CBD5E1').pack(side='left', padx=(15, 0), pady=5)
        
        # Info del usuario
        user_frame = tk.Frame(header_content, bg='#1E3A8A')
        user_frame.pack(side='right')
        
        user_name = f"{self.current_user.nombre} {self.current_user.apellido}"
        tk.Label(user_frame, text=f"ÔøΩ {user_name}", font=('Arial', 11, 'bold'), bg='#1E3A8A', fg='#FFFFFF').pack(anchor='e')
        tk.Label(user_frame, text="Administrador del Sistema", font=('Arial', 9), bg='#1E3A8A', fg='#64748B').pack(anchor='e')
        
        # Barra de navegaci√≥n moderna
        nav_frame = tk.Frame(menu_container, bg='#0B5394', height=60)
        nav_frame.pack(fill='x')
        nav_frame.pack_propagate(False)
        
        # Contenedor de botones de navegaci√≥n
        nav_content = tk.Frame(nav_frame, bg='#0B5394')
        nav_content.pack(expand=True, fill='both', padx=20, pady=5)
        
        # Definir pesta√±as con iconos y colores
        tabs_config = [
            ("üìä", "Dashboard", "#0B5394", "Vista general del sistema"),
            ("üë•", "Usuarios", "#16A085", "Gesti√≥n de usuarios"),
            ("üìÖ", "Citas", "#C0392B", "Gesti√≥n de citas m√©dicas"),
            ("ü©∫", "Historial M√©dico", "#059669", "Historiales m√©dicos de pacientes"),
            ("ÔøΩ", "Facturaci√≥n Avanzada", "#E67E22", "Sistema completo de facturaci√≥n con PDFs"),
            ("üìà", "Reportes", "#16A085", "An√°lisis y reportes")
        ]
        
        # Variable para controlar la pesta√±a activa
        self.active_tab = tk.StringVar(value="Dashboard")
        
        # Crear botones de navegaci√≥n
        self.nav_buttons = {}
        for icon, name, color, description in tabs_config:
            btn_frame = tk.Frame(nav_content, bg='#0B5394')
            btn_frame.pack(side='left', padx=5, pady=5)
            
            # Bot√≥n principal
            btn = tk.Button(btn_frame, 
                          text=f"{icon}\n{name}", 
                          font=('Arial', 10, 'bold'),
                          bg='#0B5394' if self.active_tab.get() == name else '#64748B',
                          fg='white',
                          relief='flat',
                          bd=0,
                          padx=20,
                          pady=10,
                          cursor='hand2',
                          command=lambda n=name: self.switch_tab(n))
            btn.pack()
            
            # Efectos hover
            def on_enter(e, button=btn, original_color=color, tab_name=name):
                if self.active_tab.get() != tab_name:
                    button.config(bg=original_color, relief='raised')
            
            def on_leave(e, button=btn, tab_name=name):
                if self.active_tab.get() != tab_name:
                    button.config(bg='#0B5394', relief='flat')
            
            btn.bind("<Enter>", on_enter)
            btn.bind("<Leave>", on_leave)
            
            self.nav_buttons[name] = (btn, color)
        
        # √Årea de contenido principal
        self.content_area = tk.Frame(menu_container, bg='#FFFFFF')
        self.content_area.pack(fill='both', expand=True)
        
        # Cargar contenido inicial (Dashboard)
        self.switch_tab("Dashboard")
    
    def switch_tab(self, tab_name):
        """Cambiar entre pesta√±as con animaci√≥n visual"""
        # Actualizar variable de pesta√±a activa
        self.active_tab.set(tab_name)
        
        # Actualizar colores de botones
        for name, (btn, color) in self.nav_buttons.items():
            if name == tab_name:
                btn.config(bg=color, relief='raised', bd=2)
            else:
                btn.config(bg='#0B5394', relief='flat', bd=0)
        
        # Limpiar √°rea de contenido
        for widget in self.content_area.winfo_children():
            widget.destroy()
        
        # Cargar contenido de la pesta√±a seleccionada
        if tab_name == "Dashboard":
            self.create_dashboard_tab(self.content_area)
        elif tab_name == "Usuarios":
            self.create_users_tab(self.content_area)
        elif tab_name == "Citas":
            self.create_appointments_tab(self.content_area)
        elif tab_name == "Historial M√©dico":
            self.create_medical_history_tab(self.content_area)
        elif tab_name == "Facturaci√≥n Avanzada":
            self.create_advanced_billing_tab(self.content_area)
        elif tab_name == "Reportes":
            self.create_reports_tab(self.content_area)
    
    def create_dashboard_tab(self, parent):
        """Crear pesta√±a de dashboard con dise√±o moderno"""
        # Frame principal con mejor dise√±o
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True)
        
        # Header principal con gradiente visual
        header_frame = tk.Frame(main_frame, bg='#1E3A8A', height=80)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Contenido del header
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=30, pady=15)
        
        # T√≠tulo principal
        title_frame = tk.Frame(header_content, bg='#1E3A8A')
        title_frame.pack(side='left', fill='y')
        
        tk.Label(title_frame, text="üìä Dashboard del Sistema", 
                font=('Arial', 20, 'bold'), bg='#1E3A8A', fg='white').pack(anchor='w')
        tk.Label(title_frame, text="Resumen general y estad√≠sticas principales", 
                font=('Arial', 11), bg='#1E3A8A', fg='#CBD5E1').pack(anchor='w')
        
        # Informaci√≥n del usuario actual
        user_info_frame = tk.Frame(header_content, bg='#1E3A8A')
        user_info_frame.pack(side='right', fill='y')
        
        tk.Label(user_info_frame, text=f"üë§ {self.current_user.nombre} {self.current_user.apellido}", 
                font=('Arial', 12, 'bold'), bg='#1E3A8A', fg='white').pack(anchor='e')
        tk.Label(user_info_frame, text=f"Rol: {self.current_user.tipo_usuario.title()}", 
                font=('Arial', 10), bg='#1E3A8A', fg='#CBD5E1').pack(anchor='e')
        
        # Contenido principal
        content_frame = tk.Frame(main_frame, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True, padx=30, pady=30)
        
        # Tarjetas de estad√≠sticas mejoradas
        stats_frame = tk.Frame(content_frame, bg='#F8FAFC')
        stats_frame.pack(fill='x', pady=(0, 30))
        
        try:
            stats = self.get_system_stats()
            
            # Crear tarjetas modernas
            cards_data = [
                ("üë•", "Usuarios Totales", str(stats.get('total_users', 0)), "#0B5394"),
                ("üìÖ", "Citas Hoy", str(stats.get('appointments_today', 0)), "#059669"),
                ("üí∞", "Ingresos del Mes", f"RD$ {stats.get('monthly_income', 0):,.2f}", "#E67E22"),
                ("‚è≥", "Facturas Pendientes", str(stats.get('pending_invoices', 0)), "#C0392B")
            ]
            
            for i, (icon, title, value, color) in enumerate(cards_data):
                self.create_modern_stats_card(stats_frame, icon, title, value, color, i)
            
        except Exception as e:
            error_frame = tk.Frame(stats_frame, bg='#0B5394', relief='solid', bd=1)
            error_frame.pack(fill='x', pady=10)
            tk.Label(error_frame, text=f"‚ùå Error cargando estad√≠sticas: {str(e)}", 
                    fg='white', bg='#0B5394', font=('Arial', 10, 'bold'), pady=15).pack()
        
        # Panel de accesos r√°pidos mejorado
        quick_actions_frame = tk.LabelFrame(content_frame, text="üöÄ Accesos R√°pidos", 
                                          font=('Arial', 14, 'bold'), padx=25, pady=20, 
                                          bg='white', relief='solid', bd=1)
        quick_actions_frame.pack(fill='x', pady=(0, 30))
        
        # Grid de acciones r√°pidas
        actions_grid = tk.Frame(quick_actions_frame, bg='white')
        actions_grid.pack(fill='x')
        
        quick_actions = [
            ("‚ûï Nueva Cita", self.new_appointment_quick, "#16A085"),
            ("üë§ Nuevo Paciente", self.new_patient_quick, "#0B5394"),
            ("üí≥ Procesar Pago", self.process_payment_quick, "#E67E22"),
            ("üìã Generar Reporte", self.daily_report, "#16A085")
        ]
        
        for i, (text, command, color) in enumerate(quick_actions):
            btn = tk.Button(actions_grid, text=text, command=command, 
                           bg='#0B5394', fg='white', font=('Arial', 11, 'bold'),
                           width=18, height=3, relief='flat',
                           cursor='hand2')
            btn.grid(row=i//2, column=i%2, padx=15, pady=10, sticky='ew')
        
        # Configurar grid weights
        actions_grid.columnconfigure(0, weight=1)
        actions_grid.columnconfigure(1, weight=1)
        
        # Panel de actividad reciente
        activity_frame = tk.LabelFrame(content_frame, text="üìà Actividad Reciente", 
                                     font=('Arial', 14, 'bold'), padx=25, pady=20, 
                                     bg='white', relief='solid', bd=1)
        activity_frame.pack(fill='both', expand=True)
        
        # Placeholder para actividad reciente
        activity_content = tk.Frame(activity_frame, bg='white')
        activity_content.pack(fill='both', expand=True)
        
        tk.Label(activity_content, text="üìä Sistema de monitoreo en tiempo real", 
                font=('Arial', 12, 'bold'), bg='white', fg='#1E3A8A').pack(pady=(10, 5))
        tk.Label(activity_content, text="‚Ä¢ √öltimas citas registradas\n‚Ä¢ Nuevos pacientes\n‚Ä¢ Facturas procesadas\n‚Ä¢ Alertas del sistema", 
                font=('Arial', 10), bg='white', fg='#64748B', justify='left').pack()
        
    def create_modern_stats_card(self, parent, icon, title, value, color, position):
        """Crear tarjeta de estad√≠stica moderna"""
        # Frame de la tarjeta
        card = tk.Frame(parent, bg='white', relief='solid', bd=1)
        card.pack(side='left', fill='both', expand=True, padx=10 if position > 0 else 0)
        
        # Header de la tarjeta
        header = tk.Frame(card, bg=color, height=10)
        header.pack(fill='x')
        header.pack_propagate(False)
        
        # Contenido de la tarjeta
        content = tk.Frame(card, bg='white')
        content.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Icono grande
        tk.Label(content, text=icon, font=('Arial', 24), bg='white', fg=color).pack(pady=(0, 10))
        
        # Valor principal
        tk.Label(content, text=value, font=('Arial', 16, 'bold'), 
                bg='white', fg='#1E3A8A').pack()
        
        # T√≠tulo
        tk.Label(content, text=title, font=('Arial', 10), 
                bg='white', fg='#64748B').pack(pady=(5, 0))
    
    def create_stats_card(self, parent, title, value, color, row, col):
        """Crear tarjeta de estad√≠sticas (funci√≥n legacy)"""
        card_frame = tk.Frame(parent, bg=color, width=200, height=100, relief='raised', bd=2)
        card_frame.grid(row=row, column=col, padx=10, pady=10, sticky='ew')
        card_frame.grid_propagate(False)
        
        tk.Label(card_frame, text=title, font=('Arial', 10, 'bold'), 
                bg=color, fg='white').pack(pady=(10, 5))
        tk.Label(card_frame, text=value, font=('Arial', 16, 'bold'), 
                bg=color, fg='white').pack()
        
        parent.grid_columnconfigure(col, weight=1)
    
    def get_system_stats(self):
        """Obtener estad√≠sticas del sistema"""
        conn = self.db_manager.get_connection()
        cursor = conn.cursor()
        
        try:
            stats = {}
            
            # Total de usuarios
            cursor.execute("SELECT COUNT(*) FROM usuarios WHERE activo = 1")
            stats['total_users'] = cursor.fetchone()[0]
            
            # Total de pacientes
            cursor.execute("SELECT COUNT(*) FROM usuarios WHERE tipo_usuario = 'paciente'")
            stats['total_patients'] = cursor.fetchone()[0]
            
            # Citas de hoy
            today = datetime.now().strftime('%Y-%m-%d')
            cursor.execute("SELECT COUNT(*) FROM citas WHERE DATE(fecha_hora) = ?", (today,))
            stats['appointments_today'] = cursor.fetchone()[0]
            
            # Facturas pendientes
            cursor.execute("SELECT COUNT(*) FROM facturas WHERE estado = 'pendiente'")
            stats['pending_invoices'] = cursor.fetchone()[0]
            
            # Ingresos del mes actual
            current_month = datetime.now().strftime('%Y-%m')
            cursor.execute("""
                SELECT COALESCE(SUM(monto), 0) 
                FROM facturas 
                WHERE estado = 'pagado' AND strftime('%Y-%m', fecha_pago) = ?
            """, (current_month,))
            stats['monthly_income'] = cursor.fetchone()[0] or 0
            
            return stats
            
        except Exception as e:
            print(f"Error obteniendo estad√≠sticas: {e}")
            return {}
        finally:
            cursor.close()
            conn.close()
    
    def create_users_tab(self, parent):
        """Crear pesta√±a de gesti√≥n completa de usuarios integrada"""
        # Frame principal con mejor dise√±o
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True)
        
        # Header con gradiente visual
        header_frame = tk.Frame(main_frame, bg='#1E3A8A', height=70)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Contenido del header
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=20, pady=10)
        
        # T√≠tulo principal
        title_frame = tk.Frame(header_content, bg='#1E3A8A')
        title_frame.pack(side='left', fill='y')
        
        tk.Label(title_frame, text="üë• Gesti√≥n de Usuarios", 
                font=('Arial', 18, 'bold'), bg='#1E3A8A', fg='white').pack(anchor='w')
        tk.Label(title_frame, text="Administraci√≥n completa del sistema", 
                font=('Arial', 10), bg='#1E3A8A', fg='#CBD5E1').pack(anchor='w')
        
        # Botones de acci√≥n principales
        actions_frame = tk.Frame(header_content, bg='#1E3A8A')
        actions_frame.pack(side='right', fill='y')
        
        tk.Button(actions_frame, text="‚ûï Nuevo Usuario", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), relief='flat', padx=15, pady=8,
                 command=self.add_new_user).pack(side='right', padx=(10, 0))
        tk.Button(actions_frame, text="üîÑ Actualizar", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), relief='flat', padx=15, pady=8,
                 command=self.refresh_user_list).pack(side='right', padx=(10, 0))
        
        # Contenido principal dividido
        content_frame = tk.Frame(main_frame, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Panel izquierdo - Lista y filtros
        left_panel = tk.Frame(content_frame, bg='white', relief='solid', bd=1)
        left_panel.pack(side='left', fill='both', expand=True, padx=(0, 10))
        
        # Header del panel izquierdo
        left_header = tk.Frame(left_panel, bg='#0B5394', height=45)
        left_header.pack(fill='x')
        left_header.pack_propagate(False)
        
        tk.Label(left_header, text="üìã Lista de Usuarios", font=('Arial', 12, 'bold'), 
                bg='#0B5394', fg='white').pack(side='left', padx=15, pady=10)
        
        # Secci√≥n de filtros mejorada
        filters_frame = tk.LabelFrame(left_panel, text="üîç Filtros de B√∫squeda", 
                                    font=('Arial', 10, 'bold'), padx=15, pady=10, bg='white')
        filters_frame.pack(fill='x', padx=15, pady=10)
        
        # Primera fila de filtros
        filter_row1 = tk.Frame(filters_frame, bg='white')
        filter_row1.pack(fill='x', pady=(0, 8))
        
        tk.Label(filter_row1, text="Buscar:", font=('Arial', 9, 'bold'), bg='white').grid(row=0, column=0, sticky='w', padx=(0, 5))
        self.user_search_entry = tk.Entry(filter_row1, font=('Arial', 9), width=25, relief='solid', bd=1)
        self.user_search_entry.grid(row=0, column=1, padx=5, sticky='ew')
        self.user_search_entry.bind('<KeyRelease>', self.search_users)
        
        # Segunda fila de filtros
        filter_row2 = tk.Frame(filters_frame, bg='white')
        filter_row2.pack(fill='x', pady=(0, 8))
        
        tk.Label(filter_row2, text="Tipo:", font=('Arial', 9, 'bold'), bg='white').grid(row=0, column=0, sticky='w', padx=(0, 5))
        self.user_type_filter = ttk.Combobox(filter_row2, values=['Todos', 'admin', 'doctor', 'secretaria', 'paciente'], 
                                           state='readonly', width=15, font=('Arial', 9))
        self.user_type_filter.set('Todos')
        self.user_type_filter.grid(row=0, column=1, padx=5, sticky='ew')
        self.user_type_filter.bind('<<ComboboxSelected>>', self.filter_users)
        
        tk.Label(filter_row2, text="Estado:", font=('Arial', 9, 'bold'), bg='white').grid(row=0, column=2, sticky='w', padx=(15, 5))
        self.user_status_filter = ttk.Combobox(filter_row2, values=['Todos', 'Activo', 'Inactivo'], 
                                             state='readonly', width=12, font=('Arial', 9))
        self.user_status_filter.set('Todos')
        self.user_status_filter.grid(row=0, column=3, padx=5, sticky='ew')
        self.user_status_filter.bind('<<ComboboxSelected>>', self.filter_users)
        
        # Tercera fila - botones de filtro
        filter_row3 = tk.Frame(filters_frame, bg='white')
        filter_row3.pack(fill='x')
        
        tk.Button(filter_row3, text="üîç Buscar", bg='#0B5394', fg='white', font=('Arial', 8, 'bold'),
                 relief='flat', padx=12, pady=4, command=self.search_users).pack(side='left', padx=(0, 5))
        tk.Button(filter_row3, text="üóëÔ∏è Limpiar", bg='#0B5394', fg='white', font=('Arial', 8, 'bold'),
                 relief='flat', padx=12, pady=4, command=self.clear_user_search).pack(side='left')
        
        # Configurar grid weights para filtros
        filter_row1.columnconfigure(1, weight=1)
        filter_row2.columnconfigure(1, weight=1)
        filter_row2.columnconfigure(3, weight=1)
        
        # Tabla de usuarios mejorada
        table_frame = tk.Frame(left_panel, bg='white')
        table_frame.pack(fill='both', expand=True, padx=15, pady=(0, 15))
        
        # Estilo personalizado para la tabla
        style = ttk.Style()
        style.configure("Users.Treeview", font=('Arial', 9))
        style.configure("Users.Treeview.Heading", font=('Arial', 10, 'bold'))
        
        columns = ('ID', 'Nombre', 'Apellido', 'Email', 'Tipo', 'Estado', '√öltimo Acceso')
        self.users_tree = ttk.Treeview(table_frame, columns=columns, show='headings', 
                                     height=12, style="Users.Treeview")
        
        # Configurar headers con anchos optimizados
        column_widths = {'ID': 50, 'Nombre': 100, 'Apellido': 100, 'Email': 160, 
                        'Tipo': 80, 'Estado': 70, '√öltimo Acceso': 90}
        
        for col in columns:
            self.users_tree.heading(col, text=col)
            self.users_tree.column(col, width=column_widths.get(col, 100), minwidth=50)
        
        # Scrollbars para la tabla con mejor visibilidad
        scrollbar_y = ttk.Scrollbar(table_frame, orient="vertical", command=self.users_tree.yview)
        scrollbar_x = ttk.Scrollbar(table_frame, orient="horizontal", command=self.users_tree.xview)
        self.users_tree.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        
        # Layout con grid para mejor control de scrollbars con padding
        self.users_tree.grid(row=0, column=0, sticky='nsew', padx=(5, 0), pady=(5, 0))
        scrollbar_y.grid(row=0, column=1, sticky='ns', padx=(0, 5), pady=(5, 0))
        scrollbar_x.grid(row=1, column=0, sticky='ew', padx=(5, 0), pady=(0, 5))
        
        # Configurar expansi√≥n con m√≠nimo para scrollbars
        table_frame.grid_rowconfigure(0, weight=1)
        table_frame.grid_rowconfigure(1, weight=0, minsize=20)
        table_frame.grid_columnconfigure(0, weight=1)
        table_frame.grid_columnconfigure(1, weight=0, minsize=20)
        
        # Bind para selecci√≥n
        self.users_tree.bind('<<TreeviewSelect>>', self.on_user_select)
        
        # Panel derecho - Detalles y acciones
        right_panel = tk.Frame(content_frame, bg='white', relief='solid', bd=1, width=350)
        right_panel.pack(side='right', fill='y')
        right_panel.pack_propagate(False)
        
        # Header del panel derecho
        right_header = tk.Frame(right_panel, bg='#0B5394', height=45)
        right_header.pack(fill='x')
        right_header.pack_propagate(False)
        
        tk.Label(right_header, text="‚öôÔ∏è Acciones de Usuario", font=('Arial', 12, 'bold'), 
                bg='#0B5394', fg='white').pack(pady=10)
        
        # Informaci√≥n del usuario seleccionado
        self.user_info_frame = tk.Frame(right_panel, bg='white')
        self.user_info_frame.pack(fill='x', padx=15, pady=15)
        
        # Placeholder inicial
        self.user_info_label = tk.Label(self.user_info_frame, 
                                       text="üëÜ Seleccione un usuario de la lista\npara ver sus detalles y opciones", 
                                       font=('Arial', 10), bg='white', fg='#64748B', 
                                       justify='center', wraplength=300)
        self.user_info_label.pack(pady=20)
        
        # Frame para botones de acci√≥n
        self.actions_frame = tk.Frame(right_panel, bg='white')
        self.actions_frame.pack(fill='x', padx=15, pady=(0, 15))
        
        # Botones de acci√≥n (inicialmente ocultos)
        self.action_buttons = []
        user_actions = [
            ("‚úèÔ∏è Editar Usuario", self.edit_selected_user, "#0B5394"),
            ("üîë Cambiar Contrase√±a", self.change_user_password, "#E67E22"),
            ("‚úÖ Activar Usuario", self.activate_user, "#16A085"),
            ("‚ùå Desactivar Usuario", self.deactivate_user, "#C0392B"),
            ("üëÅÔ∏è Ver Detalles Completos", self.view_user_details, "#16A085"),
            ("üóëÔ∏è Eliminar Usuario", self.delete_user, "#C0392B")
        ]
        
        for text, command, color in user_actions:
            btn = tk.Button(self.actions_frame, text=text, command=command, 
                           bg='#0B5394', fg='white', font=('Arial', 9, 'bold'),
                           width=22, height=2, relief='flat', state='disabled')
            btn.pack(fill='x', pady=2)
            self.action_buttons.append(btn)
        
        # Estad√≠sticas en la parte inferior
        stats_frame = tk.LabelFrame(right_panel, text="üìä Estad√≠sticas del Sistema", 
                                   font=('Arial', 10, 'bold'), padx=10, pady=10, bg='white')
        stats_frame.pack(fill='x', padx=15, pady=(0, 15))
        
        self.load_user_stats(stats_frame)
        
        # Variables para el usuario seleccionado
        self.selected_user_id = None
        self.selected_user_data = None
        
        # Cargar datos iniciales
        self.load_users_list()
    
    def load_users_data(self):
        """Cargar datos de usuarios (funci√≥n de compatibilidad)"""
        self.load_users_list()
    
    # def create_patients_tab(self, parent):
    #     """Crear pesta√±a de pacientes - FUNCI√ìN DESHABILITADA"""
    #     pass
        
    # def load_patients_data(self, tree):
    #     """Cargar datos de pacientes - FUNCI√ìN DESHABILITADA"""
    #     pass
    
    # def create_doctors_tab(self, parent):
    #     """Crear pesta√±a de doctores - FUNCI√ìN DESHABILITADA"""
    #     pass
    
    # def load_doctors_data(self, tree):
    #     """Cargar datos de doctores - FUNCI√ìN DESHABILITADA"""
    #     pass
    
    def create_appointments_tab(self, parent):
        """Crear pesta√±a de citas con dise√±o moderno similar a usuarios"""
        # Frame principal
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Header con dise√±o moderno
        header_frame = tk.Frame(main_frame, bg='#1E3A8A', height=80, relief='raised', bd=2)
        header_frame.pack(fill='x', pady=(0, 20))
        header_frame.pack_propagate(False)
        
        # Contenido del header
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(fill='both', expand=True, padx=20, pady=15)
        
        # T√≠tulo del m√≥dulo
        title_frame = tk.Frame(header_content, bg='#1E3A8A')
        title_frame.pack(side='left', fill='y')
        
        tk.Label(title_frame, text="üìÖ", font=('Arial', 24), 
                bg='#1E3A8A', fg='white').pack(side='left')
        tk.Label(title_frame, text="Gesti√≥n de Citas M√©dicas", font=('Arial', 18, 'bold'), 
                bg='#1E3A8A', fg='white').pack(side='left', padx=(10, 0))
        
        # Botones de acci√≥n en el header
        actions_frame = tk.Frame(header_content, bg='#1E3A8A')
        actions_frame.pack(side='right', fill='y')
        
        tk.Button(actions_frame, text="‚ûï Nueva Cita", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), relief='flat', padx=15, pady=8,
                 command=self.new_appointment_window).pack(side='right', padx=(10, 0))
        tk.Button(actions_frame, text="üîÑ Actualizar", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), relief='flat', padx=15, pady=8,
                 command=lambda: self.load_appointments_data(self.appointments_tree)).pack(side='right', padx=(10, 0))
        
        # Contenido principal dividido
        content_frame = tk.Frame(main_frame, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True, padx=0, pady=0)
        
        # Panel izquierdo - Acciones r√°pidas
        left_panel = tk.Frame(content_frame, bg='white', relief='solid', bd=1, width=200)
        left_panel.pack(side='left', fill='y', padx=(0, 10))
        left_panel.pack_propagate(False)
        
        # Frame para botones de acci√≥n en panel izquierdo
        actions_label_frame = tk.LabelFrame(left_panel, text="‚ö° Acciones R√°pidas", 
                                           font=('Arial', 12, 'bold'), padx=10, pady=10, bg='white', fg='#1E3A8A')
        actions_label_frame.pack(fill='both', expand=True, padx=10, pady=15)
        
        # Botones de acci√≥n para citas seleccionadas
        action_frame = tk.Frame(actions_label_frame, bg='white')
        action_frame.pack(fill='x', pady=10)
        
        # Organizar botones verticalmente
        tk.Button(action_frame, text="‚úèÔ∏è Editar Cita", 
                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                 command=self.edit_appointment, padx=15, pady=8, relief='flat').pack(fill='x', pady=3)
        
        tk.Button(action_frame, text="üëÅÔ∏è Ver Detalles", 
                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                 command=lambda: self.show_appointment_details(), padx=15, pady=8, relief='flat').pack(fill='x', pady=3)
        
        tk.Button(action_frame, text="‚úÖ Confirmar", 
                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                 command=self.confirm_appointment, padx=15, pady=8, relief='flat').pack(fill='x', pady=3)
        
        tk.Button(action_frame, text="üöÄ Iniciar", 
                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                 command=self.start_appointment, padx=15, pady=8, relief='flat').pack(fill='x', pady=3)
        
        tk.Button(action_frame, text="‚úÖ Completar", 
                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                 command=self.complete_appointment, padx=15, pady=8, relief='flat').pack(fill='x', pady=3)
        
        tk.Button(action_frame, text="‚ùå Cancelar", 
                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                 command=self.cancel_appointment, padx=15, pady=8, relief='flat').pack(fill='x', pady=3)
        
        # Panel central - Lista de citas con filtros
        center_panel = tk.Frame(content_frame, bg='white', relief='solid', bd=1)
        center_panel.pack(side='left', fill='both', expand=True, padx=(0, 10))
        
        # Barra de filtros dentro del panel central
        filters_frame = tk.LabelFrame(center_panel, text="üîç Filtros de B√∫squeda", 
                                     font=('Arial', 12, 'bold'), padx=15, pady=10, bg='white', fg='#1E3A8A')
        filters_frame.pack(fill='x', padx=15, pady=15)
        
        # Fila 1 de filtros
        filter_row1 = tk.Frame(filters_frame, bg='white')
        filter_row1.pack(fill='x', pady=5)
        
        tk.Label(filter_row1, text="üîç Buscar:", font=('Arial', 9, 'bold'), 
                bg='white', fg='#64748B').grid(row=0, column=0, sticky='w', padx=(0, 5))
        
        self.search_var = tk.StringVar()
        search_entry = tk.Entry(filter_row1, textvariable=self.search_var, 
                               font=('Arial', 9), width=25, relief='solid', bd=1)
        search_entry.grid(row=0, column=1, sticky='ew', padx=(0, 15))
        search_entry.bind('<KeyRelease>', self.filter_appointments)
        
        tk.Label(filter_row1, text="üìä Estado:", font=('Arial', 9, 'bold'), 
                bg='white', fg='#64748B').grid(row=0, column=2, sticky='w', padx=(0, 5))
        
        self.status_filter = tk.StringVar(value="Todos")
        status_combo = ttk.Combobox(filter_row1, textvariable=self.status_filter, 
                                   values=["Todos", "pendiente", "confirmada", "en_curso", "completada", "cancelada"],
                                   width=12, state="readonly", font=('Arial', 9))
        status_combo.grid(row=0, column=3, sticky='ew')
        status_combo.bind('<<ComboboxSelected>>', self.filter_appointments)
        
        # Fila 2 de filtros
        filter_row2 = tk.Frame(filters_frame, bg='white')
        filter_row2.pack(fill='x', pady=5)
        
        tk.Label(filter_row2, text="üìÖ Fecha:", font=('Arial', 9, 'bold'), 
                bg='white', fg='#64748B').grid(row=0, column=0, sticky='w', padx=(0, 5))
        
        self.date_filter = tk.StringVar()
        if CALENDAR_AVAILABLE:
            self.date_entry = DateEntry(filter_row2, textvariable=self.date_filter,
                                       font=('Arial', 9), width=12, relief='solid', bd=1,
                                       date_pattern='dd/mm/yyyy', background='#0B5394',
                                       foreground='white', borderwidth=2)
            self.date_entry.grid(row=0, column=1, sticky='ew', padx=(0, 15))
            self.date_entry.bind('<<DateEntrySelected>>', self.filter_appointments)
        else:
            date_entry = tk.Entry(filter_row2, textvariable=self.date_filter, 
                                 font=('Arial', 9), width=12, relief='solid', bd=1)
            date_entry.grid(row=0, column=1, sticky='ew', padx=(0, 15))
            date_entry.bind('<KeyRelease>', self.filter_appointments)
        
        tk.Label(filter_row2, text="üë®‚Äç‚öïÔ∏è Doctor:", font=('Arial', 9, 'bold'), 
                bg='white', fg='#64748B').grid(row=0, column=2, sticky='w', padx=(0, 5))
        
        self.doctor_filter = tk.StringVar(value="Todos")
        # Obtener lista de doctores
        doctors_list = ["Todos"] + self.get_doctors_list()
        self.doctor_combo = ttk.Combobox(filter_row2, textvariable=self.doctor_filter, 
                                        values=doctors_list, width=15, state="readonly", font=('Arial', 9))
        self.doctor_combo.grid(row=0, column=3, sticky='ew')
        self.doctor_combo.bind('<<ComboboxSelected>>', self.filter_appointments)
        
        # Botones de filtro
        filter_row3 = tk.Frame(filters_frame, bg='white')
        filter_row3.pack(fill='x', pady=(10, 0))
        
        tk.Button(filter_row3, text="üîç Buscar", bg='#0B5394', fg='white', font=('Arial', 8, 'bold'),
                 relief='flat', padx=12, pady=4, command=self.filter_appointments).pack(side='left', padx=(0, 5))
        tk.Button(filter_row3, text="üóëÔ∏è Limpiar", bg='#0B5394', fg='white', font=('Arial', 8, 'bold'),
                 relief='flat', padx=12, pady=4, command=self.clear_appointment_filters).pack(side='left')
        
        # Configurar grid weights para filtros
        filter_row1.columnconfigure(1, weight=1)
        filter_row2.columnconfigure(1, weight=1)
        filter_row2.columnconfigure(3, weight=1)
        
        # Tabla de citas en panel central
        table_frame = tk.LabelFrame(center_panel, text="üìã Lista de Citas", 
                                   font=('Arial', 12, 'bold'), padx=10, pady=10, bg='white', fg='#1E3A8A')
        table_frame.pack(fill='both', expand=True, padx=15, pady=(0, 15))
        
        # Configurar Treeview con dise√±o limpio
        columns = ('ID', 'Fecha', 'Hora', 'Paciente', 'Doctor', 'Motivo', 'Estado')
        self.appointments_tree = ttk.Treeview(table_frame, columns=columns, show='headings', height=15)
        
        # Configurar headers
        column_widths = {'ID': 50, 'Fecha': 90, 'Hora': 70, 'Paciente': 140, 
                        'Doctor': 140, 'Motivo': 180, 'Estado': 90}
        
        for col in columns:
            self.appointments_tree.heading(col, text=col, anchor='center')
            self.appointments_tree.column(col, width=column_widths.get(col, 100), anchor='center')
        
        # Solo configurar alternado simple, sin colores de estado
        self.appointments_tree.tag_configure('oddrow', background='#F8FAFC')
        self.appointments_tree.tag_configure('evenrow', background='white')
        
        # Scrollbars
        v_scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=self.appointments_tree.yview)
        h_scrollbar = ttk.Scrollbar(table_frame, orient="horizontal", command=self.appointments_tree.xview)
        self.appointments_tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        
        # Layout de la tabla
        self.appointments_tree.grid(row=0, column=0, sticky='nsew', padx=(5, 0), pady=(5, 0))
        v_scrollbar.grid(row=0, column=1, sticky='ns', padx=(0, 5), pady=(5, 0))
        h_scrollbar.grid(row=1, column=0, sticky='ew', padx=(5, 0), pady=(0, 5))
        
        table_frame.grid_rowconfigure(0, weight=1)
        table_frame.grid_columnconfigure(0, weight=1)
        
        # Bind para selecci√≥n
        self.appointments_tree.bind('<<TreeviewSelect>>', self.on_appointment_select)
        self.appointments_tree.bind('<Double-1>', lambda event: self.show_appointment_details())
        
        # Panel derecho - Detalles y acciones
        right_panel = tk.Frame(content_frame, bg='white', relief='solid', bd=1, width=350)
        right_panel.pack(side='right', fill='y', padx=(0, 0))
        right_panel.pack_propagate(False)
        
        # Header del panel derecho
        details_header = tk.Frame(right_panel, bg='#0B5394', height=50)
        details_header.pack(fill='x')
        details_header.pack_propagate(False)
        
        tk.Label(details_header, text="üìã Detalles de la Cita", font=('Arial', 12, 'bold'), 
                bg='#0B5394', fg='white').pack(expand=True)
        
        # Frame para detalles de la cita solamente
        self.appointment_details_frame = tk.Frame(right_panel, bg='white')
        self.appointment_details_frame.pack(fill='both', expand=True, padx=15, pady=15)
        
        # Mensaje inicial
        self.appointment_details_label = tk.Label(self.appointment_details_frame, 
                                                 text="Seleccione una cita\npara ver los detalles", 
                                                 font=('Arial', 11), bg='white', fg='#64748B', 
                                                 justify='center')
        self.appointment_details_label.pack(pady=20)
        
        # Cargar datos iniciales
        self.load_appointments_data(self.appointments_tree)
        # que se crea m√°s abajo en el right_panel
        
        # Bind eventos
        self.appointments_tree.bind('<<TreeviewSelect>>', self.on_appointment_select)
        self.appointments_tree.bind('<Double-1>', lambda event: self.show_appointment_details())
        
        # Cargar datos iniciales
        self.load_appointments_data(self.appointments_tree)
    
    def get_doctors_list(self):
        """Obtener lista de doctores para el filtro"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            cursor.execute("""
                SELECT DISTINCT nombre || ' ' || apellido as doctor_name 
                FROM usuarios 
                WHERE tipo_usuario = 'doctor' AND activo = 1
                ORDER BY nombre, apellido
            """)
            doctors = cursor.fetchall()
            result = [doctor[0] for doctor in doctors]
            cursor.close()
            conn.close()
            return result
        except Exception as e:
            print(f"Error al obtener doctores: {e}")
            return []
    
    def load_appointments_data(self, tree):
        """Cargar datos de citas con dise√±o limpio sin colores de estado"""
        try:
            # Limpiar tabla
            for item in tree.get_children():
                tree.delete(item)
            
            # Obtener citas con filtros aplicados
            appointments = self.get_filtered_appointments()
            
            for i, appointment in enumerate(appointments):
                # Formatear fecha y hora por separado
                fecha_hora = appointment.get('fecha_hora', '')
                fecha, hora = '', ''
                if fecha_hora:
                    try:
                        dt = datetime.fromisoformat(fecha_hora)
                        fecha = dt.strftime('%d/%m/%Y')
                        hora = dt.strftime('%H:%M')
                    except:
                        fecha = fecha_hora
                        hora = ''
                
                # Solo usar alternado simple, sin colores de estado
                tag = 'oddrow' if i % 2 else 'evenrow'
                
                tree.insert('', 'end', values=(
                    appointment['id'], fecha, hora,
                    appointment.get('paciente_nombre', 'N/A'),
                    appointment.get('doctor_nombre', 'N/A'),
                    appointment.get('motivo', 'N/A'),
                    appointment.get('estado', 'pendiente').title()
                ), tags=(tag,))
                
        except Exception as e:
            messagebox.showerror("Error", f"Error al cargar citas: {str(e)}")
    
    def clear_appointment_filters(self):
        """Limpiar todos los filtros de citas"""
        self.search_var.set("")
        self.status_filter.set("Todos")
        if hasattr(self, 'date_filter'):
            self.date_filter.set("")
        if hasattr(self, 'doctor_filter'):
            self.doctor_filter.set("Todos")
        # Limpiar el DateEntry si est√° disponible
        if hasattr(self, 'date_entry') and CALENDAR_AVAILABLE:
            self.date_entry.set_date(datetime.now().date())
            self.date_filter.set("")
        self.load_appointments_data(self.appointments_tree)
    
    def get_filtered_appointments(self):
        """Obtener citas filtradas por b√∫squeda, estado, fecha y doctor"""
        try:
            appointments = self.db_manager.get_all_appointments()
            
            # Filtrar por texto de b√∫squeda
            search_text = getattr(self, 'search_var', None)
            if search_text and search_text.get().strip():
                search = search_text.get().strip().lower()
                appointments = [app for app in appointments if (
                    search in app.get('paciente_nombre', '').lower() or
                    search in app.get('doctor_nombre', '').lower() or
                    search in app.get('motivo', '').lower() or
                    search in str(app.get('id', ''))
                )]
            
            # Filtrar por estado
            status_filter = getattr(self, 'status_filter', None)
            if status_filter and status_filter.get() != "Todos":
                status = status_filter.get()
                appointments = [app for app in appointments if app.get('estado', 'Programada') == status]
            
            # Filtrar por fecha
            date_filter = getattr(self, 'date_filter', None)
            if date_filter and date_filter.get().strip():
                date_str = date_filter.get().strip()
                # Convertir fecha de DD/MM/YYYY a formato comparable
                try:
                    if '/' in date_str:
                        day, month, year = date_str.split('/')
                        filter_date = f"{year}-{month.zfill(2)}-{day.zfill(2)}"
                        appointments = [app for app in appointments 
                                      if app.get('fecha_hora', '').startswith(filter_date)]
                except:
                    pass  # Si hay error en el formato, ignorar filtro de fecha
            
            # Filtrar por doctor
            doctor_filter = getattr(self, 'doctor_filter', None)
            if doctor_filter and doctor_filter.get() != "Todos":
                doctor_name = doctor_filter.get()
                appointments = [app for app in appointments 
                              if app.get('doctor_nombre', '') == doctor_name]
            
            return appointments
            
        except Exception as e:
            print(f"Error filtrando citas: {str(e)}")
            return []
    
    def filter_appointments(self, event=None):
        """Filtrar citas en tiempo real"""
        if hasattr(self, 'appointments_tree'):
            self.load_appointments_data(self.appointments_tree)
    
    def on_appointment_select(self, event):
        """Manejar selecci√≥n de cita"""
        try:
            selection = self.appointments_tree.selection()
            if not selection:
                self.clear_appointment_details()
                return
            
            item = self.appointments_tree.item(selection[0])
            values = item['values']
            
            if values:
                appointment_id = values[0]
                self.show_appointment_details(appointment_id)
                
        except Exception as e:
            print(f"Error en selecci√≥n de cita: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def show_appointment_details(self, appointment_id):
        """Mostrar detalles de la cita seleccionada"""
        try:
            # Limpiar detalles anteriores
            for widget in self.appointment_details_frame.winfo_children():
                widget.destroy()
            
            # Obtener datos de la cita
            appointment = self.db_manager.get_appointment_by_id(appointment_id)
            
            if not appointment:
                tk.Label(self.appointment_details_frame, text="Cita no encontrada", 
                        font=('Arial', 10), bg='white', fg='#C0392B').pack(expand=True)
                return
            
            # Formatear fecha y hora
            fecha_hora = appointment.get('fecha_hora', '')
            if fecha_hora:
                try:
                    dt = datetime.fromisoformat(fecha_hora)
                    fecha_formatted = dt.strftime('%A, %d de %B de %Y')
                    hora_formatted = dt.strftime('%H:%M')
                except:
                    fecha_formatted = fecha_hora
                    hora_formatted = ''
            else:
                fecha_formatted = 'No definida'
                hora_formatted = ''
            
            # Crear interfaz de detalles
            details = [
                ("ID:", str(appointment['id'])),
                ("Fecha:", fecha_formatted),
                ("Hora:", hora_formatted),
                ("Paciente:", appointment.get('paciente_nombre', 'N/A')),
                ("Doctor:", appointment.get('doctor_nombre', 'N/A')),
                ("Motivo:", appointment.get('motivo', 'N/A')),
                ("Estado:", appointment.get('estado', 'Programada')),
                ("Observaciones:", appointment.get('observaciones', 'Ninguna'))
            ]
            
            for label, value in details:
                detail_frame = tk.Frame(self.appointment_details_frame, bg='white')
                detail_frame.pack(fill='x', pady=2)
                
                tk.Label(detail_frame, text=label, font=('Arial', 9, 'bold'), 
                        bg='white', fg='#1E3A8A', anchor='w').pack(side='left')
                
                # Ajustar texto largo
                if len(str(value)) > 25:
                    text_widget = tk.Text(detail_frame, height=2, wrap='word', 
                                        font=('Arial', 9), bg='#F8FAFC', relief='flat')
                    text_widget.insert(1.0, str(value))
                    text_widget.configure(state='disabled')
                    text_widget.pack(fill='x', pady=(2, 0))
                else:
                    tk.Label(detail_frame, text=str(value), font=('Arial', 9), 
                            bg='white', fg='#64748B', anchor='w', wraplength=200).pack(fill='x')
                
        except Exception as e:
            print(f"Error mostrando detalles: {str(e)}")
            import traceback
            traceback.print_exc()
            tk.Label(self.appointment_details_frame, text="Error cargando detalles", 
                    font=('Arial', 10), bg='white', fg='#C0392B').pack(expand=True)
    
    def clear_appointment_details(self):
        """Limpiar panel de detalles"""
        try:
            for widget in self.appointment_details_frame.winfo_children():
                widget.destroy()
            
            tk.Label(self.appointment_details_frame, text="Seleccione una cita\npara ver los detalles", 
                    font=('Arial', 10), bg='white', fg='#64748B').pack(expand=True)
        except:
            pass
    
    def new_appointment_window(self):
        """Ventana para crear nueva cita con dise√±o mejorado"""
        window = tk.Toplevel(self.root)
        window.title("üè• MEDISYNC - Nueva Cita M√©dica")
        window.geometry("850x750")
        window.configure(bg='#F8FAFC')
        window.transient(self.root)
        window.grab_set()
        window.resizable(False, False)
        
        # Centrar ventana
        window.update_idletasks()
        x = (window.winfo_screenwidth() // 2) - (850 // 2)
        y = (window.winfo_screenheight() // 2) - (750 // 2)
        window.geometry(f"850x750+{x}+{y}")
        
        # Header mejorado con gradiente visual
        header_frame = tk.Frame(window, bg='#1E3A8A', height=100)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Container para el t√≠tulo y subtitle
        title_container = tk.Frame(header_frame, bg='#1E3A8A')
        title_container.pack(expand=True, fill='both')
        
        # T√≠tulo principal
        title_label = tk.Label(title_container, text="üìÖ PROGRAMAR NUEVA CITA", 
                              font=('Arial', 18, 'bold'), bg='#1E3A8A', fg='white')
        title_label.pack(pady=(20, 5))
        
        # Subt√≠tulo
        subtitle_label = tk.Label(title_container, text="Complete todos los campos marcados con (*)", 
                                 font=('Arial', 10), bg='#1E3A8A', fg='#CBD5E1')
        subtitle_label.pack(pady=(0, 15))
        
        # Main container con scroll
        main_container = tk.Frame(window, bg='#F8FAFC')
        main_container.pack(fill='both', expand=True, padx=30, pady=20)
        
        # Canvas para scroll
        canvas = tk.Canvas(main_container, bg='#F8FAFC', highlightthickness=0)
        scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#F8FAFC')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Variables del formulario
        appointment_vars = {
            'fecha': tk.StringVar(),
            'hora': tk.StringVar(),
            'paciente_id': tk.StringVar(),
            'doctor_id': tk.StringVar(),
            'motivo': tk.StringVar(),
            'observaciones': tk.StringVar(),
            'estado': tk.StringVar(value='pendiente'),
            'duracion': tk.StringVar(value='60'),
            'tipo_consulta': tk.StringVar(value='general')
        }
        
        entries = {}
        
        # SECCI√ìN 1: INFORMACI√ìN TEMPORAL
        temporal_section = tk.LabelFrame(scrollable_frame, text="‚è∞ Programaci√≥n de la Cita", 
                                       font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                       padx=20, pady=15)
        temporal_section.pack(fill='x', pady=(0, 20))
        
        # Grid para fecha y hora
        datetime_grid = tk.Frame(temporal_section, bg='#F8FAFC')
        datetime_grid.pack(fill='x')
        
        # Fecha
        fecha_frame = tk.Frame(datetime_grid, bg='#F8FAFC')
        fecha_frame.grid(row=0, column=0, sticky='ew', padx=(0, 15))
        
        tk.Label(fecha_frame, text="üìÖ Fecha de la Cita *", 
                font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
        
        fecha_input_frame = tk.Frame(fecha_frame, bg='#F8FAFC')
        fecha_input_frame.pack(fill='x', pady=(8, 0))
        
        # Usar DateEntry si est√° disponible, sino Entry normal
        if CALENDAR_AVAILABLE:
            fecha_entry = DateEntry(fecha_input_frame, textvariable=appointment_vars['fecha'],
                                   font=('Arial', 12), width=15, relief='solid', bd=1,
                                   date_pattern='dd/mm/yyyy', background='#0B5394',
                                   foreground='white', borderwidth=2)
            fecha_entry.pack(side='left', ipady=8)
        else:
            fecha_entry = tk.Entry(fecha_input_frame, textvariable=appointment_vars['fecha'], 
                                  font=('Arial', 12), width=15, relief='solid', bd=1)
            fecha_entry.pack(side='left', ipady=8)
            
            fecha_btn = tk.Button(fecha_input_frame, text="üìÖ Seleccionar", 
                                 command=lambda: self.select_date_enhanced(appointment_vars['fecha']),
                                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                                 relief='flat', padx=15, pady=8, cursor='hand2')
            fecha_btn.pack(side='left', padx=(10, 0))
        
        entries['fecha'] = fecha_entry
        
        # Indicador visual para fecha
        fecha_info = tk.Label(fecha_frame, text="Formato: DD/MM/YYYY", 
                             font=('Arial', 9), bg='#F8FAFC', fg='#64748B')
        fecha_info.pack(anchor='w', pady=(5, 0))
        
        # Hora
        hora_frame = tk.Frame(datetime_grid, bg='#F8FAFC')
        hora_frame.grid(row=0, column=1, sticky='ew', padx=(15, 0))
        
        tk.Label(hora_frame, text="üïê Hora de la Cita *", 
                font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
        
        hora_input_frame = tk.Frame(hora_frame, bg='#F8FAFC')
        hora_input_frame.pack(fill='x', pady=(8, 0))
        
        hora_entry = tk.Entry(hora_input_frame, textvariable=appointment_vars['hora'], 
                             font=('Arial', 12), width=15, relief='solid', bd=1)
        hora_entry.pack(side='left', ipady=8)
        entries['hora'] = hora_entry
        
        # Botones de horarios r√°pidos
        quick_times = ['08:00', '09:00', '10:00', '14:00', '15:00', '16:00']
        quick_time_frame = tk.Frame(hora_input_frame, bg='#F8FAFC')
        quick_time_frame.pack(side='left', padx=(10, 0))
        
        for time in quick_times[:3]:
            tk.Button(quick_time_frame, text=time, 
                     command=lambda t=time: appointment_vars['hora'].set(t),
                     bg='#FFFFFF', fg='#1E3A8A', font=('Arial', 8),
                     relief='flat', padx=5, pady=2, cursor='hand2').pack(side='left', padx=1)
        
        # Indicador visual para hora
        hora_info = tk.Label(hora_frame, text="Formato: HH:MM (24h)", 
                            font=('Arial', 9), bg='#F8FAFC', fg='#64748B')
        hora_info.pack(anchor='w', pady=(5, 0))
        
        # Duraci√≥n
        duracion_frame = tk.Frame(temporal_section, bg='#F8FAFC')
        duracion_frame.pack(fill='x', pady=(15, 0))
        
        tk.Label(duracion_frame, text="‚è±Ô∏è Duraci√≥n (minutos)", 
                font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
        
        duracion_combo = ttk.Combobox(duracion_frame, textvariable=appointment_vars['duracion'],
                                     values=['30', '45', '60', '90', '120'], state='readonly',
                                     font=('Arial', 11), width=20)
        duracion_combo.pack(anchor='w', pady=(8, 0))
        entries['duracion'] = duracion_combo
        
        datetime_grid.columnconfigure(0, weight=1)
        datetime_grid.columnconfigure(1, weight=1)
        
        # SECCI√ìN 2: PARTICIPANTES
        participants_section = tk.LabelFrame(scrollable_frame, text="üë• Participantes de la Cita", 
                                           font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                           padx=20, pady=15)
        participants_section.pack(fill='x', pady=(0, 20))
        
        # Grid para paciente y doctor
        participants_grid = tk.Frame(participants_section, bg='#F8FAFC')
        participants_grid.pack(fill='x')
        
        # Paciente
        paciente_frame = tk.Frame(participants_grid, bg='#F8FAFC')
        paciente_frame.grid(row=0, column=0, sticky='ew', padx=(0, 15))
        
        tk.Label(paciente_frame, text="üë§ Paciente *", 
                font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
        
        paciente_combo = ttk.Combobox(paciente_frame, textvariable=appointment_vars['paciente_id'],
                                     font=('Arial', 11), state="readonly", width=35)
        paciente_combo.pack(fill='x', pady=(8, 0))
        entries['paciente_id'] = paciente_combo
        
        # Cargar pacientes con mejor formato
        try:
            patients = self.db_manager.get_all_patients()
            if patients:
                patient_values = [f"{p['id']} - {p['nombre']} {p['apellido']}" for p in patients]
                paciente_combo['values'] = patient_values
                paciente_combo.set("Seleccione un paciente...")
            else:
                paciente_combo['values'] = ["No hay pacientes registrados"]
        except Exception as e:
            paciente_combo['values'] = ["Error cargando pacientes"]
        
        # Doctor
        doctor_frame = tk.Frame(participants_grid, bg='#F8FAFC')
        doctor_frame.grid(row=0, column=1, sticky='ew', padx=(15, 0))
        
        tk.Label(doctor_frame, text="üë®‚Äç‚öïÔ∏è Doctor *", 
                font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
        
        doctor_combo = ttk.Combobox(doctor_frame, textvariable=appointment_vars['doctor_id'],
                                   font=('Arial', 11), state="readonly", width=35)
        doctor_combo.pack(fill='x', pady=(8, 0))
        doctor_combo.bind('<<ComboboxSelected>>', 
                         lambda e: self.update_available_hours(appointment_vars['doctor_id'], 
                                                              appointment_vars['fecha'], 
                                                              appointment_vars['hora'],
                                                              quick_time_frame))
        entries['doctor_id'] = doctor_combo
        
        # Cargar doctores con especialidad
        try:
            doctors = self.db_manager.get_all_doctors()
            if doctors:
                doctor_values = [f"{d['id']} - Dr. {d['nombre']} {d['apellido']}" for d in doctors]
                doctor_combo['values'] = doctor_values
                doctor_combo.set("Seleccione un doctor...")
            else:
                doctor_combo['values'] = ["No hay doctores registrados"]
        except Exception as e:
            doctor_combo['values'] = ["Error cargando doctores"]
        
        participants_grid.columnconfigure(0, weight=1)
        participants_grid.columnconfigure(1, weight=1)
        
        # SECCI√ìN 3: DETALLES DE LA CONSULTA
        details_section = tk.LabelFrame(scrollable_frame, text="üìã Detalles de la Consulta", 
                                      font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                      padx=20, pady=15)
        details_section.pack(fill='x', pady=(0, 20))
        
        # Tipo de consulta
        tipo_frame = tk.Frame(details_section, bg='#F8FAFC')
        tipo_frame.pack(fill='x', pady=(0, 15))
        
        tk.Label(tipo_frame, text="üè• Tipo de Consulta", 
                font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
        
        tipo_combo = ttk.Combobox(tipo_frame, textvariable=appointment_vars['tipo_consulta'],
                                 values=['general', 'especialidad', 'control', 'urgencia', 'seguimiento'],
                                 state='readonly', font=('Arial', 11), width=25)
        tipo_combo.pack(anchor='w', pady=(8, 0))
        entries['tipo_consulta'] = tipo_combo
        
        # Motivo de la consulta
        motivo_frame = tk.Frame(details_section, bg='#F8FAFC')
        motivo_frame.pack(fill='x', pady=(0, 15))
        
        tk.Label(motivo_frame, text="üí≠ Motivo de la Consulta *", 
                font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
        
        motivo_entry = tk.Entry(motivo_frame, textvariable=appointment_vars['motivo'],
                               font=('Arial', 11), relief='solid', bd=1)
        motivo_entry.pack(fill='x', pady=(8, 0), ipady=8)
        entries['motivo'] = motivo_entry
        
        # Botones de motivos frecuentes
        motivos_frecuentes = ['Consulta general', 'Control m√©dico', 'Seguimiento', 'Revisi√≥n', 'Chequeo']
        motivos_frame = tk.Frame(motivo_frame, bg='#F8FAFC')
        motivos_frame.pack(fill='x', pady=(8, 0))
        
        tk.Label(motivos_frame, text="Motivos frecuentes:", 
                font=('Arial', 9), bg='#F8FAFC', fg='#64748B').pack(anchor='w')
        
        motivos_buttons = tk.Frame(motivos_frame, bg='#F8FAFC')
        motivos_buttons.pack(fill='x', pady=(5, 0))
        
        for motivo in motivos_frecuentes:
            tk.Button(motivos_buttons, text=motivo,
                     command=lambda m=motivo: appointment_vars['motivo'].set(m),
                     bg='#FFFFFF', fg='#1E3A8A', font=('Arial', 9),
                     relief='flat', padx=8, pady=4, cursor='hand2').pack(side='left', padx=(0, 5))
        
        # Estado
        estado_frame = tk.Frame(details_section, bg='#F8FAFC')
        estado_frame.pack(fill='x', pady=(0, 15))
        
        tk.Label(estado_frame, text="üìä Estado de la Cita", 
                font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
        
        estado_combo = ttk.Combobox(estado_frame, textvariable=appointment_vars['estado'],
                                   values=['pendiente', 'confirmada', 'en_curso', 'completada', 'cancelada'],
                                   state='readonly', font=('Arial', 11), width=25)
        estado_combo.pack(anchor='w', pady=(8, 0))
        entries['estado'] = estado_combo
        
        # Observaciones
        obs_frame = tk.Frame(details_section, bg='#F8FAFC')
        obs_frame.pack(fill='x')
        
        tk.Label(obs_frame, text="üìù Observaciones y Notas", 
                font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
        
        obs_text = tk.Text(obs_frame, height=4, font=('Arial', 11), relief='solid', bd=1, wrap='word')
        obs_text.pack(fill='x', pady=(8, 0))
        entries['observaciones'] = obs_text
        
        # Placeholder text
        obs_text.insert(1.0, "Ingrese observaciones adicionales, instrucciones especiales, o notas importantes para la cita...")
        obs_text.bind('<FocusIn>', lambda e: obs_text.delete(1.0, tk.END) if obs_text.get(1.0, tk.END).strip().startswith("Ingrese observaciones") else None)
        
        # BOTONES DE ACCI√ìN
        buttons_section = tk.Frame(scrollable_frame, bg='#F8FAFC')
        buttons_section.pack(fill='x', pady=(30, 20))
        
        # Separador visual
        separator = tk.Frame(buttons_section, height=2, bg='#CBD5E1')
        separator.pack(fill='x', pady=(0, 20))
        
        # Frame para botones
        buttons_frame = tk.Frame(buttons_section, bg='#F8FAFC')
        buttons_frame.pack()
        
        # Bot√≥n Cancelar
        cancel_btn = tk.Button(buttons_frame, text="‚ùå Cancelar", 
                              bg='#0B5394', fg='white', font=('Arial', 12, 'bold'),
                              command=window.destroy, padx=25, pady=12, relief='flat', cursor='hand2')
        cancel_btn.pack(side='left', padx=(0, 15))
        
        # Bot√≥n Limpiar
        clear_btn = tk.Button(buttons_frame, text="ÔøΩÔ∏è Limpiar", 
                             bg='#0B5394', fg='white', font=('Arial', 12, 'bold'),
                             command=lambda: self.clear_appointment_form(appointment_vars, entries),
                             padx=25, pady=12, relief='flat', cursor='hand2')
        clear_btn.pack(side='left', padx=(0, 15))
        
        # Bot√≥n Guardar
        save_btn = tk.Button(buttons_frame, text="üíæ Guardar Cita", 
                            bg='#0B5394', fg='white', font=('Arial', 12, 'bold'),
                            command=lambda: self.save_appointment_enhanced(window, appointment_vars, entries),
                            padx=25, pady=12, relief='flat', cursor='hand2')
        save_btn.pack(side='left')
        
        # Configurar scroll
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Bind para scroll con mouse wheel
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        canvas.bind("<MouseWheel>", _on_mousewheel)
        
        # Focus en primer campo
        fecha_entry.focus_set()
        
        # Validaci√≥n en tiempo real
        self.setup_form_validation(appointment_vars, entries)
    
    def select_date(self, date_var):
        """Selector de fecha visual"""
        from datetime import date
        import calendar
        
        date_window = tk.Toplevel(self.root)
        date_window.title("Seleccionar Fecha")
        date_window.geometry("300x350")
        date_window.configure(bg='white')
        date_window.transient(self.root)
        date_window.grab_set()
        
        # Centrar ventana
        date_window.update_idletasks()
        x = (date_window.winfo_screenwidth() // 2) - (300 // 2)
        y = (date_window.winfo_screenheight() // 2) - (350 // 2)
        date_window.geometry(f"300x350+{x}+{y}")
        
        today = date.today()
        current_month = today.month
        current_year = today.year
        
        # Variables para navegaci√≥n
        month_var = tk.IntVar(value=current_month)
        year_var = tk.IntVar(value=current_year)
        
        def update_calendar():
            # Limpiar calendario anterior
            for widget in cal_frame.winfo_children():
                widget.destroy()
            
            # Obtener d√≠as del mes
            cal = calendar.monthcalendar(year_var.get(), month_var.get())
            month_name = calendar.month_name[month_var.get()]
            
            # T√≠tulo del mes
            tk.Label(cal_frame, text=f"{month_name} {year_var.get()}", 
                    font=('Arial', 12, 'bold'), bg='white').grid(row=0, column=0, columnspan=7, pady=10)
            
            # D√≠as de la semana
            days = ['Lun', 'Mar', 'Mi√©', 'Jue', 'Vie', 'S√°b', 'Dom']
            for i, day in enumerate(days):
                tk.Label(cal_frame, text=day, font=('Arial', 9, 'bold'), 
                        bg='#FFFFFF', width=4).grid(row=1, column=i, padx=1, pady=1)
            
            # D√≠as del mes
            for week_num, week in enumerate(cal):
                for day_num, day in enumerate(week):
                    if day == 0:
                        tk.Label(cal_frame, text="", width=4, height=2).grid(
                            row=week_num+2, column=day_num, padx=1, pady=1)
                    else:
                        btn = tk.Button(cal_frame, text=str(day), width=4, height=2,
                                      command=lambda d=day: select_day(d))
                        
                        # Marcar d√≠a actual
                        if (day == today.day and month_var.get() == today.month and 
                            year_var.get() == today.year):
                            btn.configure(bg='#0B5394', fg='white', font=('Arial', 9, 'bold'))
                        else:
                            btn.configure(bg='white', fg='black')
                        
                        btn.grid(row=week_num+2, column=day_num, padx=1, pady=1)
        
        def select_day(day):
            selected_date = f"{day:02d}/{month_var.get():02d}/{year_var.get()}"
            date_var.set(selected_date)
            date_window.destroy()
        
        def prev_month():
            if month_var.get() == 1:
                month_var.set(12)
                year_var.set(year_var.get() - 1)
            else:
                month_var.set(month_var.get() - 1)
            update_calendar()
        
        def next_month():
            if month_var.get() == 12:
                month_var.set(1)
                year_var.set(year_var.get() + 1)
            else:
                month_var.set(month_var.get() + 1)
            update_calendar()
        
        # Header con navegaci√≥n
        nav_frame = tk.Frame(date_window, bg='white')
        nav_frame.pack(fill='x', padx=20, pady=10)
        
        tk.Button(nav_frame, text="‚óÄ", command=prev_month, 
                 bg='#0B5394', fg='white', font=('Arial', 12, 'bold')).pack(side='left')
        tk.Button(nav_frame, text="‚ñ∂", command=next_month, 
                 bg='#0B5394', fg='white', font=('Arial', 12, 'bold')).pack(side='right')
        
        # Frame del calendario
        cal_frame = tk.Frame(date_window, bg='white')
        cal_frame.pack(fill='both', expand=True, padx=20, pady=10)
        
        # Inicializar calendario
        update_calendar()
    
    def save_appointment(self, window, appointment_vars, entries):
        """Guardar nueva cita"""
        try:
            # Validar campos requeridos
            required_fields = ['fecha', 'hora', 'paciente_id', 'doctor_id', 'motivo']
            for field in required_fields:
                value = appointment_vars[field].get().strip()
                if not value:
                    messagebox.showerror("Error", f"El campo {field} es obligatorio")
                    return
            
            # Obtener valores
            fecha = appointment_vars['fecha'].get().strip()
            hora = appointment_vars['hora'].get().strip()
            
            # Validar formato de fecha
            try:
                day, month, year = fecha.split('/')
                fecha_obj = datetime(int(year), int(month), int(day))
            except:
                messagebox.showerror("Error", "Formato de fecha inv√°lido. Use DD/MM/YYYY")
                return
            
            # Validar formato de hora
            try:
                hour, minute = hora.split(':')
                hora_obj = datetime.strptime(hora, '%H:%M').time()
            except:
                messagebox.showerror("Error", "Formato de hora inv√°lido. Use HH:MM")
                return
            
            # Combinar fecha y hora
            fecha_hora = datetime.combine(fecha_obj.date(), hora_obj).isoformat()
            
            # Extraer IDs de paciente y doctor
            paciente_text = appointment_vars['paciente_id'].get()
            doctor_text = appointment_vars['doctor_id'].get()
            
            try:
                paciente_id = int(paciente_text.split(' - ')[0])
                doctor_id = int(doctor_text.split(' - ')[0])
            except:
                messagebox.showerror("Error", "Seleccione paciente y doctor v√°lidos")
                return
            
            # Obtener observaciones del Text widget
            observaciones = ""
            if 'observaciones' in entries and hasattr(entries['observaciones'], 'get'):
                try:
                    observaciones = entries['observaciones'].get(1.0, tk.END).strip()
                except:
                    observaciones = ""
            
            # Crear diccionario de datos
            appointment_data = {
                'fecha_hora': fecha_hora,
                'paciente_id': paciente_id,
                'doctor_id': doctor_id,
                'motivo': appointment_vars['motivo'].get().strip(),
                'estado': appointment_vars['estado'].get(),
                'observaciones': observaciones
            }
            
            # Guardar en base de datos
            success = self.db_manager.create_appointment(appointment_data)
            
            if success:
                messagebox.showinfo("√âxito", "Cita creada exitosamente")
                window.destroy()
                
                # Actualizar tabla
                if hasattr(self, 'appointments_tree'):
                    self.load_appointments_data(self.appointments_tree)
            else:
                messagebox.showerror("Error", "No se pudo crear la cita")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error al guardar la cita: {str(e)}")
    
    def edit_appointment(self):
        """Editar cita seleccionada"""
        try:
            selection = self.appointments_tree.selection()
            if not selection:
                messagebox.showwarning("Advertencia", "Por favor seleccione una cita para editar")
                return
            
            item = self.appointments_tree.item(selection[0])
            appointment_id = item['values'][0]
            
            # Obtener datos de la cita
            appointment = self.db_manager.get_appointment_by_id(appointment_id)
            if not appointment:
                messagebox.showerror("Error", "Cita no encontrada")
                return
            
            self.edit_appointment_window(appointment)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al editar cita: {str(e)}")
    
    def edit_appointment_window(self, appointment):
        """Ventana para editar cita existente"""
        window = tk.Toplevel(self.root)
        window.title("‚úèÔ∏è Editar Cita M√©dica")
        window.geometry("600x700")
        window.configure(bg='#F8FAFC')
        window.transient(self.root)
        window.grab_set()
        
        # Centrar ventana
        window.update_idletasks()
        x = (window.winfo_screenwidth() // 2) - (600 // 2)
        y = (window.winfo_screenheight() // 2) - (700 // 2)
        window.geometry(f"600x700+{x}+{y}")
        
        # Header
        header_frame = tk.Frame(window, bg='#0B5394', height=80)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        tk.Label(header_frame, text=f"‚úèÔ∏è Editar Cita #{appointment['id']}", 
                font=('Arial', 16, 'bold'), bg='#0B5394', fg='white').pack(expand=True)
        
        # Contenido principal
        main_frame = tk.Frame(window, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=30, pady=30)
        
        # Variables del formulario con valores actuales
        fecha_hora = appointment.get('fecha_hora', '')
        fecha_str, hora_str = '', ''
        if fecha_hora:
            try:
                dt = datetime.fromisoformat(fecha_hora)
                fecha_str = dt.strftime('%d/%m/%Y')
                hora_str = dt.strftime('%H:%M')
            except:
                pass
        
        appointment_vars = {
            'fecha': tk.StringVar(value=fecha_str),
            'hora': tk.StringVar(value=hora_str),
            'paciente_id': tk.StringVar(),
            'doctor_id': tk.StringVar(),
            'motivo': tk.StringVar(value=appointment.get('motivo', '')),
            'observaciones': tk.StringVar(value=appointment.get('observaciones', '')),
            'estado': tk.StringVar(value=appointment.get('estado', 'pendiente'))
        }
        
        # Campos del formulario
        fields = [
            ("Fecha de la Cita *", 'fecha', 'date'),
            ("Hora *", 'hora', 'time'),
            ("Paciente *", 'paciente_id', 'combo_patient'),
            ("Doctor *", 'doctor_id', 'combo_doctor'),
            ("Motivo de la Consulta *", 'motivo', 'entry'),
            ("Estado", 'estado', 'combo_status'),
            ("Observaciones", 'observaciones', 'text')
        ]
        
        entries = {}
        doctor_combo_ref = None  # Para almacenar la referencia al combobox del doctor
        quick_time_frame_edit = None  # Para almacenar la referencia al frame de horarios
        
        for label, var_key, field_type in fields:
            field_frame = tk.Frame(main_frame, bg='#F8FAFC')
            field_frame.pack(fill='x', pady=8)
            
            tk.Label(field_frame, text=label, font=('Arial', 10, 'bold'), 
                    bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
            
            if field_type == 'entry':
                entry = tk.Entry(field_frame, textvariable=appointment_vars[var_key], 
                               font=('Arial', 10), width=50)
                entry.pack(fill='x', pady=(5, 0))
                entries[var_key] = entry
                
            elif field_type == 'date':
                date_frame = tk.Frame(field_frame, bg='#F8FAFC')
                date_frame.pack(fill='x', pady=(5, 0))
                
                # Usar DateEntry si est√° disponible, sino Entry normal
                if CALENDAR_AVAILABLE:
                    entry = DateEntry(date_frame, textvariable=appointment_vars[var_key],
                                     font=('Arial', 10), width=20, relief='solid', bd=1,
                                     date_pattern='dd/mm/yyyy', background='#0B5394',
                                     foreground='white', borderwidth=2)
                    entry.pack(side='left')
                else:
                    entry = tk.Entry(date_frame, textvariable=appointment_vars[var_key], 
                                   font=('Arial', 10), width=20)
                    entry.pack(side='left')
                    
                    tk.Button(date_frame, text="üìÖ", command=lambda: self.select_date_enhanced(appointment_vars[var_key]),
                             bg='#0B5394', fg='white', padx=10).pack(side='left', padx=(10, 0))
                
                entries[var_key] = entry
                
            elif field_type == 'time':
                time_frame = tk.Frame(field_frame, bg='#F8FAFC')
                time_frame.pack(fill='x', pady=(5, 0))
                
                entry = tk.Entry(time_frame, textvariable=appointment_vars[var_key], 
                               font=('Arial', 10), width=20)
                entry.pack(side='left')
                entries[var_key] = entry
                
                # Botones de horarios r√°pidos para editar
                quick_times_edit = ['08:00', '09:00', '10:00', '14:00', '15:00', '16:00']
                quick_time_frame_edit = tk.Frame(time_frame, bg='#F8FAFC')
                quick_time_frame_edit.pack(side='left', padx=(10, 0))
                
                for time in quick_times_edit[:4]:
                    tk.Button(quick_time_frame_edit, text=time, 
                             command=lambda t=time: appointment_vars['hora'].set(t),
                             bg='#FFFFFF', fg='#1E3A8A', font=('Arial', 8),
                             relief='flat', padx=5, pady=2, cursor='hand2').pack(side='left', padx=1)
                
            elif field_type == 'combo_patient':
                combo = ttk.Combobox(field_frame, textvariable=appointment_vars[var_key], 
                                   font=('Arial', 10), width=47, state="readonly")
                combo.pack(fill='x', pady=(5, 0))
                entries[var_key] = combo
                
                # Cargar pacientes y seleccionar el actual
                try:
                    patients = self.db_manager.get_all_patients()
                    patient_values = [f"{p['id']} - {p['nombre']} {p['apellido']}" for p in patients]
                    combo['values'] = patient_values
                    
                    # Seleccionar paciente actual
                    current_patient_id = appointment.get('paciente_id')
                    if current_patient_id:
                        for value in patient_values:
                            if value.startswith(f"{current_patient_id} -"):
                                appointment_vars[var_key].set(value)
                                break
                except:
                    combo['values'] = ["No hay pacientes disponibles"]
                
            elif field_type == 'combo_doctor':
                combo = ttk.Combobox(field_frame, textvariable=appointment_vars[var_key], 
                                   font=('Arial', 10), width=47, state="readonly")
                combo.pack(fill='x', pady=(5, 0))
                entries[var_key] = combo
                doctor_combo_ref = combo  # Almacenar referencia
                
                # Cargar doctores y seleccionar el actual
                try:
                    doctors = self.db_manager.get_all_doctors()
                    doctor_values = [f"{d['id']} - Dr. {d['nombre']} {d['apellido']}" for d in doctors]
                    combo['values'] = doctor_values
                    
                    # Seleccionar doctor actual
                    current_doctor_id = appointment.get('doctor_id')
                    if current_doctor_id:
                        for value in doctor_values:
                            if value.startswith(f"{current_doctor_id} -"):
                                appointment_vars[var_key].set(value)
                                break
                except:
                    combo['values'] = ["No hay doctores disponibles"]
                
            elif field_type == 'combo_status':
                combo = ttk.Combobox(field_frame, textvariable=appointment_vars[var_key], 
                                   font=('Arial', 10), width=47, state="readonly",
                                   values=["pendiente", "confirmada", "en_curso", "completada", "cancelada"])
                combo.pack(fill='x', pady=(5, 0))
                entries[var_key] = combo
                
            elif field_type == 'text':
                text_widget = tk.Text(field_frame, height=4, font=('Arial', 10), width=50)
                text_widget.pack(fill='x', pady=(5, 0))
                # Insertar texto actual
                current_text = appointment.get('observaciones', '')
                if current_text:
                    text_widget.insert(1.0, current_text)
                entries[var_key] = text_widget
        
        # Conectar evento del doctor con el frame de horarios (despu√©s de que ambos existan)
        if doctor_combo_ref is not None and quick_time_frame_edit is not None:
            doctor_combo_ref.bind('<<ComboboxSelected>>', 
                                 lambda e: self.update_available_hours(appointment_vars['doctor_id'], 
                                                                      appointment_vars['fecha'], 
                                                                      appointment_vars['hora'],
                                                                      quick_time_frame_edit))
        
        # Botones
        button_frame = tk.Frame(main_frame, bg='#F8FAFC')
        button_frame.pack(fill='x', pady=(30, 0))
        
        tk.Button(button_frame, text="üíæ Actualizar Cita", 
                 bg='#0B5394', fg='white', font=('Arial', 11, 'bold'),
                 command=lambda: self.update_appointment(window, appointment['id'], appointment_vars, entries),
                 padx=20, pady=10).pack(side='right', padx=(10, 0))
        
        tk.Button(button_frame, text="‚ùå Cancelar", 
                 bg='#0B5394', fg='white', font=('Arial', 11, 'bold'),
                 command=window.destroy, padx=20, pady=10).pack(side='right')
    
    def update_appointment(self, window, appointment_id, appointment_vars, entries):
        """Actualizar cita existente"""
        try:
            # Validar campos requeridos
            required_fields = ['fecha', 'hora', 'paciente_id', 'doctor_id', 'motivo']
            for field in required_fields:
                value = appointment_vars[field].get().strip()
                if not value:
                    messagebox.showerror("Error", f"El campo {field} es obligatorio")
                    return
            
            # Obtener valores
            fecha = appointment_vars['fecha'].get().strip()
            hora = appointment_vars['hora'].get().strip()
            
            # Validar formato de fecha
            try:
                day, month, year = fecha.split('/')
                fecha_obj = datetime(int(year), int(month), int(day))
            except:
                messagebox.showerror("Error", "Formato de fecha inv√°lido. Use DD/MM/YYYY")
                return
            
            # Validar formato de hora
            try:
                hour, minute = hora.split(':')
                hora_obj = datetime.strptime(hora, '%H:%M').time()
            except:
                messagebox.showerror("Error", "Formato de hora inv√°lido. Use HH:MM")
                return
            
            # Combinar fecha y hora
            fecha_hora = datetime.combine(fecha_obj.date(), hora_obj).isoformat()
            
            # Extraer IDs de paciente y doctor
            paciente_text = appointment_vars['paciente_id'].get()
            doctor_text = appointment_vars['doctor_id'].get()
            
            try:
                paciente_id = int(paciente_text.split(' - ')[0])
                doctor_id = int(doctor_text.split(' - ')[0])
            except:
                messagebox.showerror("Error", "Seleccione paciente y doctor v√°lidos")
                return
            
            # Obtener observaciones del Text widget
            observaciones = ""
            if 'observaciones' in entries and hasattr(entries['observaciones'], 'get'):
                try:
                    observaciones = entries['observaciones'].get(1.0, tk.END).strip()
                except:
                    observaciones = ""
            
            # Crear diccionario de datos
            appointment_data = {
                'fecha_hora': fecha_hora,
                'paciente_id': paciente_id,
                'doctor_id': doctor_id,
                'motivo': appointment_vars['motivo'].get().strip(),
                'estado': appointment_vars['estado'].get(),
                'observaciones': observaciones
            }
            
            # Actualizar en base de datos
            success = self.db_manager.update_appointment(appointment_id, appointment_data)
            
            if success:
                messagebox.showinfo("√âxito", "Cita actualizada exitosamente")
                window.destroy()
                
                # Actualizar tabla
                if hasattr(self, 'appointments_tree'):
                    self.load_appointments_data(self.appointments_tree)
                    self.show_appointment_details(appointment_id)
            else:
                messagebox.showerror("Error", "No se pudo actualizar la cita")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error al actualizar la cita: {str(e)}")
        
    def view_appointment_details(self, appointment_id=None):
        """Ver detalles completos de la cita en ventana separada"""
        try:
            if appointment_id is None:
                selection = self.appointments_tree.selection()
                if not selection:
                    messagebox.showwarning("Advertencia", "Por favor seleccione una cita para ver detalles")
                    return
                
                item = self.appointments_tree.item(selection[0])
                appointment_id = item['values'][0]
            
            appointment = self.db_manager.get_appointment_by_id(appointment_id)
            if not appointment:
                messagebox.showerror("Error", "Cita no encontrada")
                return
            
            # Crear ventana de detalles mejorada
            details_window = tk.Toplevel(self.root)
            details_window.title(f"üëÅÔ∏è Detalles de Cita #{appointment_id}")
            details_window.geometry("700x750")
            details_window.configure(bg='#F8FAFC')
            details_window.transient(self.root)
            details_window.grab_set()
            details_window.resizable(False, False)
            
            # Centrar ventana
            details_window.update_idletasks()
            x = (details_window.winfo_screenwidth() // 2) - (700 // 2)
            y = (details_window.winfo_screenheight() // 2) - (750 // 2)
            details_window.geometry(f"700x750+{x}+{y}")
            
            # Header con estado din√°mico
            estado = appointment.get('estado', 'pendiente').lower()
            estado_colors = {
                'pendiente': '#E67E22',
                'confirmada': '#0B5394', 
                'en_curso': '#E67E22',
                'completada': '#16A085',
                'cancelada': '#C0392B'
            }
            header_color = estado_colors.get(estado, '#64748B')
            
            header_frame = tk.Frame(details_window, bg=header_color, height=100)
            header_frame.pack(fill='x')
            header_frame.pack_propagate(False)
            
            # Contenido del header
            header_content = tk.Frame(header_frame, bg=header_color)
            header_content.pack(expand=True, fill='both', padx=20, pady=10)
            
            # T√≠tulo y estado
            title_frame = tk.Frame(header_content, bg=header_color)
            title_frame.pack(side='left', fill='y')
            
            tk.Label(title_frame, text=f"üìã Cita M√©dica #{appointment_id}", 
                    font=('Arial', 16, 'bold'), bg=header_color, fg='white').pack(anchor='w')
            tk.Label(title_frame, text=f"Estado: {estado.title()}", 
                    font=('Arial', 12, 'bold'), bg=header_color, fg='white').pack(anchor='w')
            
            # Fecha y hora
            fecha_hora = appointment.get('fecha_hora', '')
            if fecha_hora:
                try:
                    dt = datetime.fromisoformat(fecha_hora)
                    fecha_str = dt.strftime('%d/%m/%Y')
                    hora_str = dt.strftime('%H:%M')
                except:
                    fecha_str = fecha_hora
                    hora_str = ''
            else:
                fecha_str = 'No definida'
                hora_str = ''
            
            datetime_frame = tk.Frame(header_content, bg=header_color)
            datetime_frame.pack(side='right', fill='y')
            
            tk.Label(datetime_frame, text=f"üìÖ {fecha_str}", 
                    font=('Arial', 12, 'bold'), bg=header_color, fg='white').pack(anchor='e')
            if hora_str:
                tk.Label(datetime_frame, text=f"üïê {hora_str}", 
                        font=('Arial', 12, 'bold'), bg=header_color, fg='white').pack(anchor='e')
            
            # Contenido principal con scroll
            main_container = tk.Frame(details_window, bg='#F8FAFC')
            main_container.pack(fill='both', expand=True, padx=20, pady=20)
            
            # Canvas para scroll
            canvas = tk.Canvas(main_container, bg='#F8FAFC', highlightthickness=0)
            scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=canvas.yview)
            scrollable_frame = tk.Frame(canvas, bg='#F8FAFC')
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # SECCI√ìN 1: INFORMACI√ìN DE LA CITA
            info_section = tk.LabelFrame(scrollable_frame, text="üìã Informaci√≥n de la Cita", 
                                       font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                       padx=20, pady=15)
            info_section.pack(fill='x', pady=(0, 15))
            
            # Grid para informaci√≥n
            info_grid = tk.Frame(info_section, bg='#F8FAFC')
            info_grid.pack(fill='x')
            
            info_data = [
                ("ID de Cita:", str(appointment_id)),
                ("Fecha:", fecha_str),
                ("Hora:", hora_str),
                ("Estado:", estado.title()),
                ("Tipo:", appointment.get('tipo_consulta', 'General').title()),
                ("Duraci√≥n:", f"{appointment.get('duracion', 60)} minutos")
            ]
            
            for i, (label, value) in enumerate(info_data):
                row = i // 2
                col = (i % 2) * 2
                
                tk.Label(info_grid, text=label, font=('Arial', 10, 'bold'), 
                        bg='#F8FAFC', fg='#1E3A8A').grid(row=row, column=col, sticky='w', pady=5, padx=(0, 10))
                tk.Label(info_grid, text=value, font=('Arial', 10), 
                        bg='#F8FAFC', fg='#64748B').grid(row=row, column=col+1, sticky='w', pady=5, padx=(0, 30))
            
            # SECCI√ìN 2: PARTICIPANTES
            participants_section = tk.LabelFrame(scrollable_frame, text="üë• Participantes", 
                                               font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                               padx=20, pady=15)
            participants_section.pack(fill='x', pady=(0, 15))
            
            # Informaci√≥n del paciente
            patient_frame = tk.Frame(participants_section, bg='#F8FAFC')
            patient_frame.pack(fill='x', pady=(0, 10))
            
            tk.Label(patient_frame, text="üë§ Paciente:", font=('Arial', 11, 'bold'), 
                    bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
            patient_name = appointment.get('paciente_nombre', 'No disponible')
            tk.Label(patient_frame, text=f"    {patient_name}", font=('Arial', 10), 
                    bg='#F8FAFC', fg='#64748B').pack(anchor='w')
            
            # Informaci√≥n del doctor
            doctor_frame = tk.Frame(participants_section, bg='#F8FAFC')
            doctor_frame.pack(fill='x')
            
            tk.Label(doctor_frame, text="üë®‚Äç‚öïÔ∏è Doctor:", font=('Arial', 11, 'bold'), 
                    bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
            doctor_name = appointment.get('doctor_nombre', 'No disponible')
            tk.Label(doctor_frame, text=f"    Dr. {doctor_name}", font=('Arial', 10), 
                    bg='#F8FAFC', fg='#64748B').pack(anchor='w')
            
            # SECCI√ìN 3: DETALLES M√âDICOS
            medical_section = tk.LabelFrame(scrollable_frame, text="üè• Detalles M√©dicos", 
                                          font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                          padx=20, pady=15)
            medical_section.pack(fill='x', pady=(0, 15))
            
            # Motivo
            motivo_frame = tk.Frame(medical_section, bg='#F8FAFC')
            motivo_frame.pack(fill='x', pady=(0, 10))
            
            tk.Label(motivo_frame, text="üí≠ Motivo de la Consulta:", font=('Arial', 11, 'bold'), 
                    bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
            motivo = appointment.get('motivo', 'No especificado')
            tk.Label(motivo_frame, text=f"    {motivo}", font=('Arial', 10), 
                    bg='#F8FAFC', fg='#64748B', wraplength=600, justify='left').pack(anchor='w')
            
            # Observaciones
            obs_frame = tk.Frame(medical_section, bg='#F8FAFC')
            obs_frame.pack(fill='x')
            
            tk.Label(obs_frame, text="üìù Observaciones:", font=('Arial', 11, 'bold'), 
                    bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
            observaciones = appointment.get('observaciones', 'Sin observaciones')
            if observaciones and not observaciones.startswith("Ingrese observaciones"):
                obs_text = observaciones
            else:
                obs_text = "Sin observaciones adicionales"
            tk.Label(obs_frame, text=f"    {obs_text}", font=('Arial', 10), 
                    bg='#F8FAFC', fg='#64748B', wraplength=600, justify='left').pack(anchor='w')
            
            # SECCI√ìN 4: GESTI√ìN DE ESTADO
            status_section = tk.LabelFrame(scrollable_frame, text="‚öôÔ∏è Gesti√≥n de Estado", 
                                         font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                         padx=20, pady=15)
            status_section.pack(fill='x', pady=(0, 15))
            
            # Botones de cambio de estado
            status_buttons_frame = tk.Frame(status_section, bg='#F8FAFC')
            status_buttons_frame.pack(fill='x')
            
            # Primera fila de botones
            buttons_row1 = tk.Frame(status_buttons_frame, bg='#F8FAFC')
            buttons_row1.pack(fill='x', pady=(0, 10))
            
            if estado != 'confirmada':
                tk.Button(buttons_row1, text="‚úÖ Confirmar Cita", 
                         bg='#0B5394', fg='white', font=('Arial', 9, 'bold'),
                         command=lambda: self.change_appointment_status(appointment_id, 'confirmada', details_window),
                         padx=15, pady=8, relief='flat', cursor='hand2').pack(side='left', padx=(0, 10))
            
            if estado not in ['en_curso', 'completada']:
                tk.Button(buttons_row1, text="üîÑ Iniciar Consulta", 
                         bg='#0B5394', fg='white', font=('Arial', 9, 'bold'),
                         command=lambda: self.change_appointment_status(appointment_id, 'en_curso', details_window),
                         padx=15, pady=8, relief='flat', cursor='hand2').pack(side='left', padx=(0, 10))
            
            if estado not in ['completada', 'cancelada']:
                tk.Button(buttons_row1, text="‚úÖ Completar", 
                         bg='#0B5394', fg='white', font=('Arial', 9, 'bold'),
                         command=lambda: self.change_appointment_status(appointment_id, 'completada', details_window),
                         padx=15, pady=8, relief='flat', cursor='hand2').pack(side='left')
            
            # Segunda fila de botones
            buttons_row2 = tk.Frame(status_buttons_frame, bg='#F8FAFC')
            buttons_row2.pack(fill='x')
            
            if estado not in ['cancelada', 'completada']:
                tk.Button(buttons_row2, text="‚ùå Cancelar Cita", 
                         bg='#0B5394', fg='white', font=('Arial', 9, 'bold'),
                         command=lambda: self.cancel_appointment_with_reason(appointment_id, details_window),
                         padx=15, pady=8, relief='flat', cursor='hand2').pack(side='left', padx=(0, 10))
            
            tk.Button(buttons_row2, text="‚úèÔ∏è Editar Cita", 
                     bg='#0B5394', fg='white', font=('Arial', 9, 'bold'),
                     command=lambda: self.edit_appointment_from_details(appointment_id, details_window),
                     padx=15, pady=8, relief='flat', cursor='hand2').pack(side='left', padx=(0, 10))
            
            tk.Button(buttons_row2, text="üñ®Ô∏è Imprimir", 
                     bg='#0B5394', fg='white', font=('Arial', 9, 'bold'),
                     command=lambda: self.print_appointment_details(appointment_id),
                     padx=15, pady=8, relief='flat', cursor='hand2').pack(side='left')
            
            # BOTONES DE ACCI√ìN PRINCIPALES
            main_actions_section = tk.Frame(scrollable_frame, bg='#F8FAFC')
            main_actions_section.pack(fill='x', pady=(20, 0))
            
            # Separador visual
            separator = tk.Frame(main_actions_section, height=2, bg='#CBD5E1')
            separator.pack(fill='x', pady=(0, 15))
            
            # Botones principales
            main_buttons_frame = tk.Frame(main_actions_section, bg='#F8FAFC')
            main_buttons_frame.pack()
            
            tk.Button(main_buttons_frame, text="üîô Cerrar", 
                     bg='#0B5394', fg='white', font=('Arial', 12, 'bold'),
                     command=details_window.destroy, padx=25, pady=12, relief='flat', cursor='hand2').pack(side='left', padx=(0, 10))
            
            tk.Button(main_buttons_frame, text="üîÑ Actualizar Vista", 
                     bg='#0B5394', fg='white', font=('Arial', 12, 'bold'),
                     command=lambda: self.refresh_appointment_details(appointment_id, details_window),
                     padx=25, pady=12, relief='flat', cursor='hand2').pack(side='left')
            
            # Configurar scroll
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # Bind para scroll con mouse wheel
            def _on_mousewheel(event):
                canvas.yview_scroll(int(-1*(event.delta/120)), "units")
            
            canvas.bind("<MouseWheel>", _on_mousewheel)
                
        except Exception as e:
            messagebox.showerror("Error", f"Error al cargar detalles de la cita: {str(e)}")

    def change_appointment_status(self, appointment_id, new_status, details_window=None):
        """Cambiar estado de una cita con validaciones"""
        try:
            # Validar transici√≥n de estado
            current_appointment = self.db_manager.get_appointment_by_id(appointment_id)
            if not current_appointment:
                messagebox.showerror("Error", "Cita no encontrada")
                return
            
            current_status = current_appointment.get('estado', 'pendiente').lower()
            
            # Validaciones de transici√≥n
            valid_transitions = {
                'pendiente': ['confirmada', 'cancelada'],
                'confirmada': ['en_curso', 'cancelada', 'completada'],
                'en_curso': ['completada', 'cancelada'],
                'completada': [],  # No se puede cambiar desde completada
                'cancelada': []    # No se puede cambiar desde cancelada
            }
            
            if new_status not in valid_transitions.get(current_status, []):
                messagebox.showerror("Error", 
                    f"No se puede cambiar de '{current_status}' a '{new_status}'.\n"
                    f"Transiciones v√°lidas desde '{current_status}': {', '.join(valid_transitions.get(current_status, []))}")
                return
            
            # Confirmar cambio
            status_messages = {
                'confirmada': '‚úÖ ¬øConfirmar esta cita m√©dica?',
                'en_curso': 'üîÑ ¬øIniciar la consulta m√©dica?',
                'completada': '‚úÖ ¬øMarcar la cita como completada?',
                'cancelada': '‚ùå ¬øCancelar esta cita m√©dica?'
            }
            
            message = status_messages.get(new_status, f'¬øCambiar estado a {new_status}?')
            
            if not messagebox.askyesno("Confirmar Cambio", 
                f"{message}\n\nCita #{appointment_id}\nEstado actual: {current_status.title()}"):
                return
            
            # Realizar cambio en la base de datos
            success = self.db_manager.update_appointment_status(appointment_id, new_status)
            
            if success:
                # Mensaje de √©xito personalizado
                success_messages = {
                    'confirmada': '‚úÖ Cita confirmada exitosamente',
                    'en_curso': 'üîÑ Consulta iniciada',
                    'completada': '‚úÖ Cita completada exitosamente',
                    'cancelada': '‚ùå Cita cancelada'
                }
                
                messagebox.showinfo("√âxito", 
                    f"{success_messages.get(new_status, 'Estado actualizado')}\n"
                    f"Cita #{appointment_id} ahora est√°: {new_status.title()}")
                
                # Actualizar interfaz
                if hasattr(self, 'load_appointments_data') and hasattr(self, 'appointments_tree'):
                    self.load_appointments_data(self.appointments_tree)
                
                # Actualizar ventana de detalles si est√° abierta
                if details_window and details_window.winfo_exists():
                    self.refresh_appointment_details(appointment_id, details_window)
                
                # Registrar cambio en el log
                self.log_appointment_change(appointment_id, current_status, new_status)
                
            else:
                messagebox.showerror("Error", "No se pudo actualizar el estado de la cita")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error al cambiar estado: {str(e)}")

    def cancel_appointment_with_reason(self, appointment_id, details_window=None):
        """Cancelar cita con motivo de cancelaci√≥n"""
        try:
            # Crear ventana para motivo de cancelaci√≥n
            reason_window = tk.Toplevel(self.root)
            reason_window.title("‚ùå Cancelar Cita")
            reason_window.geometry("500x400")
            reason_window.configure(bg='#F8FAFC')
            reason_window.transient(self.root)
            reason_window.grab_set()
            reason_window.resizable(False, False)
            
            # Centrar ventana
            reason_window.update_idletasks()
            x = (reason_window.winfo_screenwidth() // 2) - (500 // 2)
            y = (reason_window.winfo_screenheight() // 2) - (400 // 2)
            reason_window.geometry(f"500x400+{x}+{y}")
            
            # Header
            header_frame = tk.Frame(reason_window, bg='#0B5394', height=80)
            header_frame.pack(fill='x')
            header_frame.pack_propagate(False)
            
            tk.Label(header_frame, text=f"‚ùå Cancelar Cita #{appointment_id}", 
                    font=('Arial', 16, 'bold'), bg='#0B5394', fg='white').pack(expand=True)
            
            # Contenido principal
            main_frame = tk.Frame(reason_window, bg='#F8FAFC')
            main_frame.pack(fill='both', expand=True, padx=30, pady=30)
            
            # Informaci√≥n de la cita
            info_frame = tk.LabelFrame(main_frame, text="üìã Informaci√≥n de la Cita", 
                                     font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                     padx=15, pady=10)
            info_frame.pack(fill='x', pady=(0, 20))
            
            # Obtener datos de la cita
            appointment = self.db_manager.get_appointment_by_id(appointment_id)
            if appointment:
                fecha_hora = appointment.get('fecha_hora', '')
                if fecha_hora:
                    try:
                        dt = datetime.fromisoformat(fecha_hora)
                        fecha_str = dt.strftime('%d/%m/%Y')
                        hora_str = dt.strftime('%H:%M')
                    except:
                        fecha_str = fecha_hora
                        hora_str = ''
                else:
                    fecha_str = 'No definida'
                    hora_str = ''
                
                info_text = f"Fecha: {fecha_str}\n"
                if hora_str:
                    info_text += f"Hora: {hora_str}\n"
                info_text += f"Paciente: {appointment.get('paciente_nombre', 'No disponible')}\n"
                info_text += f"Doctor: Dr. {appointment.get('doctor_nombre', 'No disponible')}\n"
                info_text += f"Motivo: {appointment.get('motivo', 'No especificado')}"
                
                tk.Label(info_frame, text=info_text, font=('Arial', 10), 
                        bg='#F8FAFC', fg='#64748B', justify='left').pack(anchor='w')
            
            # Motivo de cancelaci√≥n
            reason_frame = tk.LabelFrame(main_frame, text="üìù Motivo de Cancelaci√≥n", 
                                       font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                       padx=15, pady=10)
            reason_frame.pack(fill='x', pady=(0, 20))
            
            # Motivos predefinidos
            reason_var = tk.StringVar()
            predefined_reasons = [
                "Paciente no puede asistir",
                "Doctor no disponible",
                "Emergencia m√©dica",
                "Reprogramaci√≥n solicitada",
                "Problemas t√©cnicos",
                "Otro motivo"
            ]
            
            for reason in predefined_reasons:
                tk.Radiobutton(reason_frame, text=reason, variable=reason_var, value=reason,
                              font=('Arial', 10), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w', pady=2)
            
            # Campo de texto para motivo personalizado
            custom_frame = tk.Frame(reason_frame, bg='#F8FAFC')
            custom_frame.pack(fill='x', pady=(10, 0))
            
            tk.Label(custom_frame, text="Detalles adicionales:", 
                    font=('Arial', 10, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
            
            custom_text = tk.Text(custom_frame, height=4, font=('Arial', 10), 
                                 relief='solid', bd=1, wrap='word')
            custom_text.pack(fill='x', pady=(5, 0))
            
            # Botones
            buttons_frame = tk.Frame(main_frame, bg='#F8FAFC')
            buttons_frame.pack(fill='x', pady=(20, 0))
            
            def confirm_cancellation():
                selected_reason = reason_var.get()
                custom_details = custom_text.get(1.0, tk.END).strip()
                
                if not selected_reason:
                    messagebox.showerror("Error", "Por favor seleccione un motivo de cancelaci√≥n")
                    return
                
                # Construir motivo completo
                full_reason = selected_reason
                if custom_details:
                    full_reason += f" - {custom_details}"
                
                # Confirmar cancelaci√≥n
                if messagebox.askyesno("Confirmar Cancelaci√≥n", 
                    f"¬øEst√° seguro de cancelar la cita #{appointment_id}?\n\n"
                    f"Motivo: {full_reason}"):
                    
                    # Actualizar en base de datos con motivo
                    success = self.db_manager.cancel_appointment_with_reason(appointment_id, full_reason)
                    
                    if success:
                        messagebox.showinfo("√âxito", 
                            f"‚úÖ Cita #{appointment_id} cancelada exitosamente\n\n"
                            f"Motivo: {full_reason}")
                        
                        # Actualizar interfaz
                        if hasattr(self, 'load_appointments_data') and hasattr(self, 'appointments_tree'):
                            self.load_appointments_data(self.appointments_tree)
                        
                        # Actualizar ventana de detalles si est√° abierta
                        if details_window and details_window.winfo_exists():
                            self.refresh_appointment_details(appointment_id, details_window)
                        
                        reason_window.destroy()
                    else:
                        messagebox.showerror("Error", "No se pudo cancelar la cita")
            
            tk.Button(buttons_frame, text="‚ùå Cancelar Cita", 
                     bg='#0B5394', fg='white', font=('Arial', 12, 'bold'),
                     command=confirm_cancellation, padx=20, pady=10, relief='flat', cursor='hand2').pack(side='right', padx=(10, 0))
            
            tk.Button(buttons_frame, text="üîô Volver", 
                     bg='#0B5394', fg='white', font=('Arial', 12, 'bold'),
                     command=reason_window.destroy, padx=20, pady=10, relief='flat', cursor='hand2').pack(side='right')
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al abrir ventana de cancelaci√≥n: {str(e)}")

    def edit_appointment_from_details(self, appointment_id, details_window):
        """Editar cita desde la ventana de detalles"""
        try:
            appointment = self.db_manager.get_appointment_by_id(appointment_id)
            if not appointment:
                messagebox.showerror("Error", "Cita no encontrada")
                return
            
            self.edit_appointment_window(appointment)
            
            # Actualizar detalles despu√©s de la edici√≥n
            if details_window and details_window.winfo_exists():
                details_window.after(1000, lambda: self.refresh_appointment_details(appointment_id, details_window))
                
        except Exception as e:
            messagebox.showerror("Error", f"Error al editar cita: {str(e)}")

    def refresh_appointment_details(self, appointment_id, details_window):
        """Actualizar ventana de detalles de la cita"""
        try:
            if details_window and details_window.winfo_exists():
                details_window.destroy()
                self.view_appointment_details(appointment_id)
        except Exception as e:
            messagebox.showerror("Error", f"Error al actualizar detalles: {str(e)}")

    def print_appointment_details(self, appointment_id):
        """Imprimir o exportar detalles de la cita"""
        try:
            appointment = self.db_manager.get_appointment_by_id(appointment_id)
            if not appointment:
                messagebox.showerror("Error", "Cita no encontrada")
                return
            
            # Crear ventana de opciones de impresi√≥n
            print_window = tk.Toplevel(self.root)
            print_window.title("üñ®Ô∏è Opciones de Impresi√≥n")
            print_window.geometry("400x300")
            print_window.configure(bg='#F8FAFC')
            print_window.transient(self.root)
            print_window.grab_set()
            print_window.resizable(False, False)
            
            # Centrar ventana
            print_window.update_idletasks()
            x = (print_window.winfo_screenwidth() // 2) - (400 // 2)
            y = (print_window.winfo_screenheight() // 2) - (300 // 2)
            print_window.geometry(f"400x300+{x}+{y}")
            
            # Header
            header_frame = tk.Frame(print_window, bg='#0B5394', height=60)
            header_frame.pack(fill='x')
            header_frame.pack_propagate(False)
            
            tk.Label(header_frame, text="üñ®Ô∏è Imprimir Cita", 
                    font=('Arial', 14, 'bold'), bg='#0B5394', fg='white').pack(expand=True)
            
            # Contenido
            main_frame = tk.Frame(print_window, bg='#F8FAFC')
            main_frame.pack(fill='both', expand=True, padx=30, pady=30)
            
            tk.Label(main_frame, text=f"Cita #{appointment_id}", 
                    font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(pady=(0, 20))
            
            # Opciones
            tk.Button(main_frame, text="üìÑ Generar PDF", 
                     bg='#0B5394', fg='white', font=('Arial', 11, 'bold'),
                     command=lambda: self.generate_appointment_pdf(appointment_id, print_window),
                     padx=20, pady=10, relief='flat', cursor='hand2').pack(fill='x', pady=5)
            
            tk.Button(main_frame, text="üìã Copiar al Portapapeles", 
                     bg='#0B5394', fg='white', font=('Arial', 11, 'bold'),
                     command=lambda: self.copy_appointment_to_clipboard(appointment_id, print_window),
                     padx=20, pady=10, relief='flat', cursor='hand2').pack(fill='x', pady=5)
            
            tk.Button(main_frame, text="üìß Enviar por Email", 
                     bg='#0B5394', fg='white', font=('Arial', 11, 'bold'),
                     command=lambda: self.email_appointment_details(appointment_id),
                     padx=20, pady=10, relief='flat', cursor='hand2').pack(fill='x', pady=5)
            
            tk.Button(main_frame, text="üîô Cerrar", 
                     bg='#0B5394', fg='white', font=('Arial', 11, 'bold'),
                     command=print_window.destroy, padx=20, pady=10, relief='flat', cursor='hand2').pack(fill='x', pady=(20, 0))
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al abrir opciones de impresi√≥n: {str(e)}")

    def generate_appointment_pdf(self, appointment_id, parent_window):
        """Generar PDF de la cita"""
        try:
            appointment = self.db_manager.get_appointment_by_id(appointment_id)
            if not appointment:
                messagebox.showerror("Error", "Cita no encontrada")
                return
            
            # Aqu√≠ ir√≠a la l√≥gica para generar PDF
            # Por ahora mostrar mensaje informativo
            messagebox.showinfo("PDF", 
                f"Generando PDF para cita #{appointment_id}...\n"
                "Funcionalidad en desarrollo")
            
            if parent_window:
                parent_window.destroy()
                
        except Exception as e:
            messagebox.showerror("Error", f"Error al generar PDF: {str(e)}")

    def copy_appointment_to_clipboard(self, appointment_id, parent_window):
        """Copiar detalles de la cita al portapapeles"""
        try:
            appointment = self.db_manager.get_appointment_by_id(appointment_id)
            if not appointment:
                messagebox.showerror("Error", "Cita no encontrada")
                return
            
            # Formatear informaci√≥n para el portapapeles
            fecha_hora = appointment.get('fecha_hora', '')
            if fecha_hora:
                try:
                    dt = datetime.fromisoformat(fecha_hora)
                    fecha_str = dt.strftime('%d/%m/%Y')
                    hora_str = dt.strftime('%H:%M')
                except:
                    fecha_str = fecha_hora
                    hora_str = ''
            else:
                fecha_str = 'No definida'
                hora_str = ''
            
            clipboard_text = f"""
MEDISYNC - DETALLES DE CITA M√âDICA

ID de Cita: {appointment_id}
Fecha: {fecha_str}
Hora: {hora_str}
Estado: {appointment.get('estado', 'pendiente').title()}

PARTICIPANTES:
Paciente: {appointment.get('paciente_nombre', 'No disponible')}
Doctor: Dr. {appointment.get('doctor_nombre', 'No disponible')}

DETALLES M√âDICOS:
Motivo: {appointment.get('motivo', 'No especificado')}
Tipo de Consulta: {appointment.get('tipo_consulta', 'General').title()}
Duraci√≥n: {appointment.get('duracion', 60)} minutos

Observaciones: {appointment.get('observaciones', 'Sin observaciones')}

Generado el: {datetime.now().strftime('%d/%m/%Y %H:%M')}
            """.strip()
            
            # Copiar al portapapeles
            self.root.clipboard_clear()
            self.root.clipboard_append(clipboard_text)
            
            messagebox.showinfo("√âxito", 
                "‚úÖ Detalles de la cita copiados al portapapeles")
            
            if parent_window:
                parent_window.destroy()
                
        except Exception as e:
            messagebox.showerror("Error", f"Error al copiar al portapapeles: {str(e)}")

    def email_appointment_details(self, appointment_id):
        """Enviar detalles de la cita por email (placeholder)"""
        messagebox.showinfo("Email", 
            f"Enviando detalles de cita #{appointment_id} por email...\n"
            "Funcionalidad en desarrollo")

    def log_appointment_change(self, appointment_id, old_status, new_status):
        """Registrar cambio de estado en el log del sistema"""
        try:
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            user_name = f"{self.current_user.nombre} {self.current_user.apellido}"
            
            log_entry = f"[{timestamp}] Usuario: {user_name} | Cita #{appointment_id} | Estado: {old_status} ‚Üí {new_status}"
            
            # Aqu√≠ se podr√≠a guardar en un archivo de log o en la base de datos
            print(f"LOG: {log_entry}")
            
        except Exception as e:
            print(f"Error al registrar log: {str(e)}")

    def confirm_appointment(self):
        """Confirmar cita seleccionada - m√©todo de acceso r√°pido"""
        try:
            selection = self.appointments_tree.selection()
            if not selection:
                messagebox.showwarning("Advertencia", "Por favor seleccione una cita para confirmar")
                return
            
            item = self.appointments_tree.item(selection[0])
            appointment_id = item['values'][0]
            
            self.change_appointment_status(appointment_id, 'confirmada')
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al confirmar cita: {str(e)}")

    def cancel_appointment(self):
        """Cancelar cita seleccionada - m√©todo de acceso r√°pido"""
        try:
            selection = self.appointments_tree.selection()
            if not selection:
                messagebox.showwarning("Advertencia", "Por favor seleccione una cita para cancelar")
                return
            
            item = self.appointments_tree.item(selection[0])
            appointment_id = item['values'][0]
            
            self.cancel_appointment_with_reason(appointment_id)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al cancelar cita: {str(e)}")

    def complete_appointment(self):
        """Completar cita seleccionada - m√©todo de acceso r√°pido"""
        try:
            selection = self.appointments_tree.selection()
            if not selection:
                messagebox.showwarning("Advertencia", "Por favor seleccione una cita para completar")
                return
            
            item = self.appointments_tree.item(selection[0])
            appointment_id = item['values'][0]
            
            # Completar la cita
            self.change_appointment_status(appointment_id, 'completada')
            
            # Crear registro m√©dico autom√°ticamente
            self.create_medical_note_from_appointment(appointment_id)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al completar cita: {str(e)}")
    
    def start_appointment(self):
        """Iniciar cita seleccionada - m√©todo de acceso r√°pido"""
        try:
            selection = self.appointments_tree.selection()
            if not selection:
                messagebox.showwarning("Advertencia", "Por favor seleccione una cita para iniciar")
                return
            
            item = self.appointments_tree.item(selection[0])
            appointment_id = item['values'][0]
            
            self.change_appointment_status(appointment_id, 'en_curso')
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al iniciar cita: {str(e)}")
    
    def update_appointment_status(self, new_status, success_message):
        """Actualizar estado de la cita"""
        try:
            selection = self.appointments_tree.selection()
            if not selection:
                messagebox.showwarning("Advertencia", "Por favor seleccione una cita")
                return
            
            item = self.appointments_tree.item(selection[0])
            appointment_id = item['values'][0]
            
            # Confirmar acci√≥n
            if messagebox.askyesno("Confirmar", f"¬øEst√° seguro de cambiar el estado a '{new_status}'?"):
                success = self.db_manager.update_appointment_status(appointment_id, new_status)
                
                if success:
                    messagebox.showinfo("√âxito", success_message)
                    self.load_appointments_data(self.appointments_tree)
                    self.show_appointment_details(appointment_id)
                else:
                    messagebox.showerror("Error", "No se pudo actualizar el estado de la cita")
                    
        except Exception as e:
            messagebox.showerror("Error", f"Error al actualizar estado: {str(e)}")
    
    def print_appointment(self, appointment):
        """Imprimir detalles de la cita"""
        try:
            # Aqu√≠ puedes implementar la funcionalidad de impresi√≥n
            # Por ahora, mostraremos un mensaje
            messagebox.showinfo("Imprimir", "Funcionalidad de impresi√≥n en desarrollo")
        except Exception as e:
            messagebox.showerror("Error", f"Error al imprimir: {str(e)}")
    
    def create_medical_history_tab(self, parent):
        """Crear pesta√±a de historial m√©dico"""
        # Limpiar contenido previo
        for widget in parent.winfo_children():
            widget.destroy()
        
        # Frame principal
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # T√≠tulo y descripci√≥n
        header_frame = tk.Frame(main_frame, bg='#F8FAFC')
        header_frame.pack(fill='x', pady=(0, 20))
        
        title_frame = tk.Frame(header_frame, bg='#0B5394', relief='raised', bd=2)
        title_frame.pack(fill='x', pady=(0, 10))
        
        tk.Label(title_frame, text="ü©∫ Historial M√©dico de Pacientes", 
                font=('Arial', 18, 'bold'), bg='#0B5394', fg='white', pady=15).pack()
        
        tk.Label(header_frame, text="Gestione y consulte los historiales m√©dicos completos de sus pacientes", 
                font=('Arial', 11), bg='#F8FAFC', fg='#1E3A8A').pack()
        
        # Frame de contenido dividido
        content_frame = tk.Frame(main_frame, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True)
        
        # Panel izquierdo - Lista de pacientes
        left_panel = tk.Frame(content_frame, bg='white', relief='solid', bd=1, width=400)
        left_panel.pack(side='left', fill='both', padx=(0, 10))
        left_panel.pack_propagate(False)
        
        # Header del panel izquierdo
        left_header = tk.Frame(left_panel, bg='#0B5394', height=50)
        left_header.pack(fill='x')
        left_header.pack_propagate(False)
        
        tk.Label(left_header, text="üë• Seleccionar Paciente", font=('Arial', 14, 'bold'), 
                bg='#0B5394', fg='white').pack(expand=True)
        
        # B√∫squeda de pacientes
        search_frame = tk.Frame(left_panel, bg='white')
        search_frame.pack(fill='x', padx=15, pady=10)
        
        tk.Label(search_frame, text="üîç Buscar paciente:", font=('Arial', 10, 'bold'), bg='white').pack(anchor='w')
        
        search_row = tk.Frame(search_frame, bg='white')
        search_row.pack(fill='x', pady=(5, 0))
        
        self.patient_search_var = tk.StringVar()
        self.patient_search_entry = tk.Entry(search_row, textvariable=self.patient_search_var, 
                                           font=('Arial', 10), width=25)
        self.patient_search_entry.pack(side='left', fill='x', expand=True)
        self.patient_search_entry.bind('<KeyRelease>', self.search_patients_medical)
        
        tk.Button(search_row, text="üîç", bg='#0B5394', fg='white', font=('Arial', 9),
                 command=self.search_patients_medical).pack(side='right', padx=(5, 0))
        
        # Lista de pacientes
        patients_frame = tk.Frame(left_panel, bg='white')
        patients_frame.pack(fill='both', expand=True, padx=15, pady=(0, 15))
        
        # Treeview para pacientes
        columns = ('ID', 'Nombre', 'Apellido', 'Edad', 'Tel√©fono')
        self.patients_medical_tree = ttk.Treeview(patients_frame, columns=columns, show='headings', height=12)
        
        # Configurar headers
        headers = {
            'ID': ('ID', 50),
            'Nombre': ('Nombre', 100),
            'Apellido': ('Apellido', 100),
            'Edad': ('Edad', 60),
            'Tel√©fono': ('Tel√©fono', 100)
        }
        
        for col, (text, width) in headers.items():
            self.patients_medical_tree.heading(col, text=text)
            self.patients_medical_tree.column(col, width=width, minwidth=width)
        
        # Scrollbars para pacientes con mejor visibilidad
        patients_scrollbar_y = ttk.Scrollbar(patients_frame, orient="vertical", command=self.patients_medical_tree.yview)
        patients_scrollbar_x = ttk.Scrollbar(patients_frame, orient="horizontal", command=self.patients_medical_tree.xview)
        self.patients_medical_tree.configure(yscrollcommand=patients_scrollbar_y.set, xscrollcommand=patients_scrollbar_x.set)
        
        # Layout con grid para mejor control de scrollbars con padding
        self.patients_medical_tree.grid(row=0, column=0, sticky='nsew', padx=(5, 0), pady=(5, 0))
        patients_scrollbar_y.grid(row=0, column=1, sticky='ns', padx=(0, 5), pady=(5, 0))
        patients_scrollbar_x.grid(row=1, column=0, sticky='ew', padx=(5, 0), pady=(0, 5))
        
        # Configurar expansi√≥n con m√≠nimo para scrollbars
        patients_frame.grid_rowconfigure(0, weight=1)
        patients_frame.grid_rowconfigure(1, weight=0, minsize=20)
        patients_frame.grid_columnconfigure(0, weight=1)
        patients_frame.grid_columnconfigure(1, weight=0, minsize=20)
        
        # Bind para selecci√≥n de paciente
        self.patients_medical_tree.bind('<<TreeviewSelect>>', self.on_patient_select_medical)
        
        # Panel derecho - Historial del paciente seleccionado
        right_panel = tk.Frame(content_frame, bg='white', relief='solid', bd=1)
        right_panel.pack(side='right', fill='both', expand=True, padx=(10, 0))
        
        # Header del panel derecho
        right_header = tk.Frame(right_panel, bg='#0B5394', height=50)
        right_header.pack(fill='x')
        right_header.pack_propagate(False)
        
        self.patient_name_label = tk.Label(right_header, text="üìã Historial M√©dico", 
                                         font=('Arial', 14, 'bold'), bg='#0B5394', fg='white')
        self.patient_name_label.pack(expand=True)
        
        # Informaci√≥n del paciente seleccionado
        self.patient_info_frame = tk.Frame(right_panel, bg='#FFFFFF')
        self.patient_info_frame.pack(fill='x', padx=15, pady=10)
        
        # Botones de acci√≥n para historial
        actions_frame = tk.Frame(right_panel, bg='white')
        actions_frame.pack(fill='x', padx=15, pady=(0, 10))
        
        tk.Button(actions_frame, text="‚ûï Nueva Consulta", bg='#0B5394', fg='white', 
                 font=('Arial', 10, 'bold'), command=self.add_medical_record).pack(side='left', padx=(0, 5))
        
        tk.Button(actions_frame, text="üìÑ Ver Detalle", bg='#0B5394', fg='white', 
                 font=('Arial', 10, 'bold'), command=self.view_medical_record_detail).pack(side='left', padx=5)
        
        tk.Button(actions_frame, text="‚úèÔ∏è Editar", bg='#0B5394', fg='white', 
                 font=('Arial', 10, 'bold'), command=self.edit_medical_record).pack(side='left', padx=5)
        
        tk.Button(actions_frame, text="üñ®Ô∏è Imprimir", bg='#0B5394', fg='white', 
                 font=('Arial', 10, 'bold'), command=self.print_medical_record).pack(side='left', padx=5)
        
        # Lista de registros m√©dicos
        records_frame = tk.Frame(right_panel, bg='white')
        records_frame.pack(fill='both', expand=True, padx=15, pady=(0, 15))
        
        # Treeview para registros m√©dicos
        records_columns = ('ID', 'Fecha', 'Tipo', 'Doctor', 'Diagn√≥stico', 'Estado')
        self.medical_records_tree = ttk.Treeview(records_frame, columns=records_columns, show='headings', height=15)
        
        # Configurar headers de registros
        records_headers = {
            'ID': ('ID', 50),
            'Fecha': ('Fecha', 100),
            'Tipo': ('Tipo', 100),
            'Doctor': ('Doctor', 120),
            'Diagn√≥stico': ('Diagn√≥stico', 200),
            'Estado': ('Estado', 80)
        }
        
        for col, (text, width) in records_headers.items():
            self.medical_records_tree.heading(col, text=text)
            self.medical_records_tree.column(col, width=width, minwidth=width)
        
        # Scrollbars para registros con mejor visibilidad
        records_scrollbar_y = ttk.Scrollbar(records_frame, orient="vertical", command=self.medical_records_tree.yview)
        records_scrollbar_x = ttk.Scrollbar(records_frame, orient="horizontal", command=self.medical_records_tree.xview)
        self.medical_records_tree.configure(yscrollcommand=records_scrollbar_y.set, xscrollcommand=records_scrollbar_x.set)
        
        # Layout con grid para mejor control de scrollbars con padding
        self.medical_records_tree.grid(row=0, column=0, sticky='nsew', padx=(5, 0), pady=(5, 0))
        records_scrollbar_y.grid(row=0, column=1, sticky='ns', padx=(0, 5), pady=(5, 0))
        records_scrollbar_x.grid(row=1, column=0, sticky='ew', padx=(5, 0), pady=(0, 5))
        
        # Configurar expansi√≥n con m√≠nimo para scrollbars
        records_frame.grid_rowconfigure(0, weight=1)
        records_frame.grid_rowconfigure(1, weight=0, minsize=20)
        records_frame.grid_columnconfigure(0, weight=1)
        records_frame.grid_columnconfigure(1, weight=0, minsize=20)
        
        # Bind para selecci√≥n de registro
        self.medical_records_tree.bind('<<TreeviewSelect>>', self.on_medical_record_select)
        
        # Variables para control
        self.selected_patient_id = None
        self.selected_medical_record_id = None
        
        # Cargar datos iniciales
        self.load_patients_for_medical_history()
        self.show_default_medical_info()
        
        # Verificar si hay pacientes, si no crear algunos de prueba
        self.ensure_test_patients()
    
    def ensure_test_patients(self):
        """Asegurar que existan pacientes de prueba"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Verificar si hay pacientes
            cursor.execute("SELECT COUNT(*) FROM usuarios WHERE tipo_usuario = 'paciente'")
            patient_count = cursor.fetchone()[0]
            
            if patient_count == 0:
                # Crear pacientes de prueba
                test_patients = [
                    ('Juan', 'P√©rez', 'juan.perez@email.com', '809-555-0001', '1985-05-15'),
                    ('Mar√≠a', 'Garc√≠a', 'maria.garcia@email.com', '809-555-0002', '1990-08-22'),
                    ('Carlos', 'Rodr√≠guez', 'carlos.rodriguez@email.com', '809-555-0003', '1978-12-10'),
                    ('Ana', 'L√≥pez', 'ana.lopez@email.com', '809-555-0004', '1992-03-08')
                ]
                
                for nombre, apellido, email, telefono, fecha_nac in test_patients:
                    password_hash = self.hash_password('123456')  # Contrase√±a por defecto
                    
                    cursor.execute("""
                        INSERT INTO usuarios (nombre, apellido, email, telefono, fecha_nacimiento, 
                                            tipo_usuario, password_hash, activo, fecha_creacion)
                        VALUES (?, ?, ?, ?, ?, 'paciente', ?, 1, ?)
                    """, (nombre, apellido, email, telefono, fecha_nac, password_hash, 
                         datetime.now().strftime('%Y-%m-%d %H:%M:%S')))
                
                conn.commit()
                print("‚úÖ Pacientes de prueba creados")
                
                # Recargar la lista
                self.load_patients_for_medical_history()
                
                # Crear algunos registros m√©dicos de prueba
                self.create_sample_medical_records()
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            print(f"Error creando pacientes de prueba: {str(e)}")
    
    def create_sample_medical_records(self):
        """Crear registros m√©dicos de prueba"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Obtener IDs de pacientes y doctor
            cursor.execute("SELECT id FROM usuarios WHERE tipo_usuario = 'paciente' LIMIT 2")
            patients = cursor.fetchall()
            
            cursor.execute("SELECT id FROM usuarios WHERE tipo_usuario = 'doctor' LIMIT 1")
            doctor = cursor.fetchone()
            
            if patients and doctor:
                sample_records = [
                    {
                        'paciente_id': patients[0][0],
                        'doctor_id': doctor[0],
                        'fecha_consulta': '2025-07-20',
                        'tipo_consulta': 'Consulta General',
                        'motivo_consulta': 'Dolor de cabeza frecuente',
                        'sintomas': 'Dolor de cabeza, mareos ocasionales',
                        'diagnostico': 'Cefalea tensional',
                        'tratamiento': 'Descanso, hidrataci√≥n adecuada',
                        'medicamentos': 'Ibuprofeno 400mg cada 8 horas',
                        'estado': 'Completada'
                    },
                    {
                        'paciente_id': patients[0][0],
                        'doctor_id': doctor[0],
                        'fecha_consulta': '2025-07-15',
                        'tipo_consulta': 'Control',
                        'motivo_consulta': 'Control rutinario',
                        'sintomas': 'Ninguno reportado',
                        'diagnostico': 'Estado de salud normal',
                        'tratamiento': 'Continuar con h√°bitos saludables',
                        'medicamentos': 'Ninguno',
                        'estado': 'Completada'
                    }
                ]
                
                if len(patients) > 1:
                    sample_records.append({
                        'paciente_id': patients[1][0],
                        'doctor_id': doctor[0],
                        'fecha_consulta': '2025-07-22',
                        'tipo_consulta': 'Consulta Especializada',
                        'motivo_consulta': 'Dolor abdominal',
                        'sintomas': 'Dolor en abdomen bajo, n√°useas',
                        'diagnostico': 'Gastritis leve',
                        'tratamiento': 'Dieta blanda, evitar irritantes',
                        'medicamentos': 'Omeprazol 20mg en ayunas',
                        'estado': 'Completada'
                    })
                
                for record in sample_records:
                    cursor.execute("""
                        INSERT INTO historial_medico 
                        (paciente_id, doctor_id, fecha_consulta, tipo_consulta, motivo_consulta,
                         sintomas, diagnostico, tratamiento, medicamentos, estado, fecha_creacion)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    """, (
                        record['paciente_id'], record['doctor_id'], record['fecha_consulta'],
                        record['tipo_consulta'], record['motivo_consulta'], record['sintomas'],
                        record['diagnostico'], record['tratamiento'], record['medicamentos'],
                        record['estado'], datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    ))
                
                conn.commit()
                print("‚úÖ Registros m√©dicos de prueba creados")
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            print(f"Error creando registros m√©dicos de prueba: {str(e)}")
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            print(f"Error creando pacientes de prueba: {str(e)}")
    
    def create_advanced_billing_tab(self, parent):
        """Sistema de facturaci√≥n avanzado integrado directamente en MEDISYNC"""
        # Inicializar variables de facturaci√≥n integrada
        self.init_integrated_billing_system()
        
        # Frame principal
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True)
        
        # Header moderno
        header_frame = tk.Frame(main_frame, bg='#1E3A8A', height=80)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=20, pady=15)
        
        tk.Label(header_content, text="ÔøΩ SISTEMA DE FACTURACI√ìN INTEGRADO", 
                font=('Arial', 18, 'bold'), bg='#1E3A8A', fg='white').pack()
        tk.Label(header_content, text="PDFs Autom√°ticos | Control de Pagos | Gesti√≥n Completa", 
                font=('Arial', 11), bg='#1E3A8A', fg='#CBD5E1').pack()
        
        # Crear notebook para pesta√±as del sistema de facturaci√≥n
        self.billing_notebook = ttk.Notebook(main_frame)
        self.billing_notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Pesta√±a 1: Facturaci√≥n Principal
        billing_frame = tk.Frame(self.billing_notebook, bg='#F8FAFC')
        self.billing_notebook.add(billing_frame, text="üí∞ Facturaci√≥n")
        
        # Pesta√±a 2: Servicios M√©dicos
        services_frame = tk.Frame(self.billing_notebook, bg='#F8FAFC')
        self.billing_notebook.add(services_frame, text="üè• Servicios")
        
        # Pesta√±a 3: Reportes
        reports_frame = tk.Frame(self.billing_notebook, bg='#F8FAFC')
        self.billing_notebook.add(reports_frame, text="üìä Reportes")
        
        # Crear contenido de cada pesta√±a
        self.create_integrated_billing_content(billing_frame)
        self.create_integrated_services_content(services_frame)
        self.create_integrated_reports_content(reports_frame)
        
        # Status bar
        self.create_billing_status_bar(main_frame)
        
        # Cargar datos iniciales
        self.load_integrated_billing_data()
    
    def auto_launch_billing_system(self):
        """Lanzar autom√°ticamente el sistema de facturaci√≥n al abrir la pesta√±a"""
        # Esta funci√≥n ya no es necesaria con el sistema integrado
        pass
    
    def manual_launch_billing_system(self):
        """Lanzar manualmente el sistema de facturaci√≥n"""
        # Esta funci√≥n ya no es necesaria con el sistema integrado  
        pass
    
    def init_integrated_billing_system(self):
        """Inicializar el sistema de facturaci√≥n integrado"""
        # Variables para el sistema de facturaci√≥n
        self.billing_notebook = None
        self.appointments_tree_billing = None
        self.services_tree_billing = None
        self.invoice_services_tree = None
        self.selected_services = []
        self.current_appointment_billing = None
        
        # Variables de c√°lculo
        self.subtotal_var = tk.StringVar(value="0.00")
        self.discount_var = tk.StringVar(value="0.00")
        self.total_var = tk.StringVar(value="0.00")
        self.payment_var = tk.StringVar(value="0.00")
        self.change_var = tk.StringVar(value="0.00")
        
        # Servicios m√©dicos predefinidos
        self.medical_services = [
            {'codigo': 'CONS001', 'nombre': 'Consulta General', 'categoria': 'Consulta', 'precio': 1500.00},
            {'codigo': 'CONS002', 'nombre': 'Consulta Especializada', 'categoria': 'Consulta', 'precio': 2500.00},
            {'codigo': 'LAB001', 'nombre': 'An√°lisis de Sangre', 'categoria': 'Laboratorio', 'precio': 800.00},
            {'codigo': 'RAD001', 'nombre': 'Radiograf√≠a', 'categoria': 'Imagen', 'precio': 1800.00},
            {'codigo': 'PROC001', 'nombre': 'Procedimiento Menor', 'categoria': 'Procedimiento', 'precio': 1000.00},
            {'codigo': 'ULTRA001', 'nombre': 'Ultrasonido', 'categoria': 'Imagen', 'precio': 2200.00},
            {'codigo': 'CARDIO001', 'nombre': 'Electrocardiograma', 'categoria': 'Cardiolog√≠a', 'precio': 1200.00},
            {'codigo': 'VACU001', 'nombre': 'Aplicaci√≥n de Vacuna', 'categoria': 'Prevenci√≥n', 'precio': 500.00}
        ]
        
        # Configuraci√≥n de cl√≠nica
        self.clinic_config = {
            'nombre': 'MEDISYNC - Centro M√©dico',
            'direccion': 'Avenida Central, San Jos√©, Costa Rica',
            'telefono': '+506 2000-0000',
            'email': 'info@medisync.cr'
        }
    
    def create_integrated_billing_content(self, parent):
        """Crear contenido principal de facturaci√≥n con dise√±o de tarjetas modernas"""
        # Frame principal con scroll
        main_container = tk.Frame(parent, bg='#F8FAFC')
        main_container.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Canvas para scroll
        canvas = tk.Canvas(main_container, bg='#F8FAFC', highlightthickness=0)
        scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#F8FAFC')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Panel superior: Informaci√≥n de la cita en tarjeta moderna
        appointment_card = tk.Frame(scrollable_frame, bg='white', relief='solid', bd=2)
        appointment_card.pack(fill='x', pady=(0, 20))
        
        # Header de la tarjeta
        card_header = tk.Frame(appointment_card, bg='#1E3A8A', height=50)
        card_header.pack(fill='x')
        card_header.pack_propagate(False)
        
        tk.Label(card_header, text="üìÖ Informaci√≥n de la Cita", 
                font=('Arial', 14, 'bold'), bg='#1E3A8A', fg='white').pack(expand=True)
        
        # Contenido de la tarjeta
        card_content = tk.Frame(appointment_card, bg='white', padx=25, pady=20)
        card_content.pack(fill='both', expand=True)
        
        # Filtros en dise√±o de tarjeta
        filters_card = tk.Frame(card_content, bg='#F8FAFC', relief='solid', bd=1)
        filters_card.pack(fill='x', pady=(0, 15))
        
        filters_inner = tk.Frame(filters_card, bg='#F8FAFC', padx=20, pady=15)
        filters_inner.pack(fill='x')
        
        tk.Label(filters_inner, text="üîç Filtrar citas:", bg='#F8FAFC', fg='#1E3A8A', 
                font=('Arial', 11, 'bold')).pack(side='left')
        
        self.appointment_filter_var = tk.StringVar(value="completadas")
        filter_combo = ttk.Combobox(filters_inner, textvariable=self.appointment_filter_var,
                                   values=["completadas", "todas", "hoy"], width=15, state="readonly",
                                   font=('Arial', 10))
        filter_combo.pack(side='left', padx=(15, 0))
        filter_combo.bind('<<ComboboxSelected>>', self.filter_appointments_billing)
        
        tk.Button(filters_inner, text="üîÑ Actualizar", command=self.load_integrated_billing_data,
                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'), relief='flat',
                 padx=15, pady=8).pack(side='left', padx=(15, 0))
        
        # Lista de citas en formato de tarjetas
        appointments_list_frame = tk.Frame(card_content, bg='white')
        appointments_list_frame.pack(fill='both', expand=True)
        
        # Canvas para las tarjetas de citas
        appointments_canvas = tk.Canvas(appointments_list_frame, bg='white', height=200, highlightthickness=0)
        appointments_scrollbar = ttk.Scrollbar(appointments_list_frame, orient="vertical", command=appointments_canvas.yview)
        self.appointments_cards_frame = tk.Frame(appointments_canvas, bg='white')
        
        self.appointments_cards_frame.bind(
            "<Configure>",
            lambda e: appointments_canvas.configure(scrollregion=appointments_canvas.bbox("all"))
        )
        
        appointments_canvas.create_window((0, 0), window=self.appointments_cards_frame, anchor="nw")
        appointments_canvas.configure(yscrollcommand=appointments_scrollbar.set)
        
        appointments_canvas.pack(side="left", fill="both", expand=True)
        appointments_scrollbar.pack(side="right", fill="y")
        
        # Tambi√©n mantener el TreeView oculto para compatibilidad
        self.appointments_tree_billing = ttk.Treeview(card_content, columns=('ID', 'Fecha', 'Paciente', 'Doctor', 'Estado', 'Facturada'), 
                                                     show='headings', height=0)
        self.appointments_tree_billing.bind('<<TreeviewSelect>>', self.on_appointment_select_for_billing)
        
        # Panel de servicios m√©dicos en tarjeta moderna
        services_card = tk.Frame(scrollable_frame, bg='white', relief='solid', bd=2)
        services_card.pack(fill='x', pady=(0, 20))
        
        # Header de servicios
        services_header = tk.Frame(services_card, bg='#059669', height=50)
        services_header.pack(fill='x')
        services_header.pack_propagate(False)
        
        tk.Label(services_header, text="üè• Servicios M√©dicos Disponibles", 
                font=('Arial', 14, 'bold'), bg='#059669', fg='white').pack(expand=True)
        
        # Contenido de servicios
        services_content = tk.Frame(services_card, bg='white', padx=25, pady=20)
        services_content.pack(fill='both', expand=True)
        
        # B√∫squeda de servicios en dise√±o moderno
        search_card = tk.Frame(services_content, bg='#F8FAFC', relief='solid', bd=1)
        search_card.pack(fill='x', pady=(0, 15))
        
        search_inner = tk.Frame(search_card, bg='#F8FAFC', padx=15, pady=10)
        search_inner.pack(fill='x')
        
        tk.Label(search_inner, text="üîç Buscar servicio:", bg='#F8FAFC', fg='#059669', 
                font=('Arial', 11, 'bold')).pack(side='left')
        self.service_search_var = tk.StringVar()
        search_entry = tk.Entry(search_inner, textvariable=self.service_search_var, 
                               font=('Arial', 11), relief='solid', bd=1)
        search_entry.pack(side='left', padx=(15, 0), fill='x', expand=True)
        search_entry.bind('<KeyRelease>', self.filter_services)
        
        # Grid de servicios como tarjetas
        self.services_grid_frame = tk.Frame(services_content, bg='white')
        self.services_grid_frame.pack(fill='both', expand=True)
        
        # Mantener TreeView oculto para compatibilidad
        self.services_tree_billing = ttk.Treeview(services_content, columns=('C√≥digo', 'Servicio', 'Categor√≠a', 'Precio'), 
                                                 show='headings', height=0)
        
        # Variable para almacenar tarjetas de servicios
        self.service_cards = []
        
        # Panel de factura en proceso como tarjeta moderna
        invoice_card = tk.Frame(scrollable_frame, bg='white', relief='solid', bd=2)
        invoice_card.pack(fill='both', expand=True)
        
        # Header de factura
        invoice_header = tk.Frame(invoice_card, bg='#E67E22', height=50)
        invoice_header.pack(fill='x')
        invoice_header.pack_propagate(False)
        
        tk.Label(invoice_header, text="üìÑ Factura en Proceso", 
                font=('Arial', 14, 'bold'), bg='#E67E22', fg='white').pack(expand=True)
        
        # Contenido de factura
        invoice_content = tk.Frame(invoice_card, bg='white', padx=25, pady=20)
        invoice_content.pack(fill='both', expand=True)
        
        # Informaci√≥n del paciente en tarjeta peque√±a
        patient_info_card = tk.Frame(invoice_content, bg='#F8FAFC', relief='solid', bd=1)
        patient_info_card.pack(fill='x', pady=(0, 15))
        
        patient_info_inner = tk.Frame(patient_info_card, bg='#F8FAFC', padx=15, pady=10)
        patient_info_inner.pack(fill='x')
        
        self.patient_info_label = tk.Label(patient_info_inner, text="Seleccione una cita para continuar",
                                          bg='#F8FAFC', fg='#E67E22', font=('Arial', 11, 'bold'))
        self.patient_info_label.pack()
        
        # Servicios seleccionados en la factura
        selected_services_card = tk.Frame(invoice_content, bg='#F8FAFC', relief='solid', bd=1)
        selected_services_card.pack(fill='both', expand=True, pady=(0, 15))
        
        selected_header = tk.Frame(selected_services_card, bg='#64748B', height=40)
        selected_header.pack(fill='x')
        selected_header.pack_propagate(False)
        
        tk.Label(selected_header, text="üõí Servicios Seleccionados", 
                font=('Arial', 12, 'bold'), bg='#64748B', fg='white').pack(expand=True)
        
        selected_content = tk.Frame(selected_services_card, bg='#F8FAFC', padx=15, pady=15)
        selected_content.pack(fill='both', expand=True)
        
        # Lista de servicios seleccionados como tarjetas peque√±as
        self.selected_services_frame = tk.Frame(selected_content, bg='#F8FAFC')
        self.selected_services_frame.pack(fill='both', expand=True)
        
        # Mantener TreeView oculto para compatibilidad
        self.invoice_services_tree = ttk.Treeview(selected_content, columns=('Servicio', 'Cantidad', 'Precio Unit.', 'Total'), 
                                                 show='headings', height=0)
        
        # Botones de servicio en dise√±o moderno
        service_buttons_card = tk.Frame(invoice_content, bg='#F8FAFC', relief='solid', bd=1)
        service_buttons_card.pack(fill='x', pady=(0, 15))
        
        buttons_inner = tk.Frame(service_buttons_card, bg='#F8FAFC', padx=15, pady=10)
        buttons_inner.pack(fill='x')
        
        tk.Button(buttons_inner, text="‚ùå Quitar Seleccionado", command=self.remove_service_from_invoice,
                 bg='#DC2626', fg='white', font=('Arial', 10, 'bold'), relief='flat',
                 padx=15, pady=8).pack(side='left', padx=(0, 10))
        tk.Button(buttons_inner, text="‚úèÔ∏è Editar Cantidad", command=self.edit_service_in_invoice,
                 bg='#F59E0B', fg='white', font=('Arial', 10, 'bold'), relief='flat',
                 padx=15, pady=8).pack(side='left')
        
        # Panel de c√°lculos como tarjeta
        self.create_modern_billing_calculations_panel(invoice_content)
        
        # Configurar canvas scroll
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Bind para scroll con mouse wheel
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        canvas.bind("<MouseWheel>", _on_mousewheel)
    
    def create_modern_billing_calculations_panel(self, parent):
        """Panel de c√°lculos de facturaci√≥n con dise√±o moderno de tarjetas"""
        calc_card = tk.Frame(parent, bg='white', relief='solid', bd=2)
        calc_card.pack(fill='x', pady=(0, 15))
        
        # Header de c√°lculos
        calc_header = tk.Frame(calc_card, bg='#16A085', height=45)
        calc_header.pack(fill='x')
        calc_header.pack_propagate(False)
        
        tk.Label(calc_header, text="üí∞ Resumen de Facturaci√≥n", 
                font=('Arial', 12, 'bold'), bg='#16A085', fg='white').pack(expand=True)
        
        # Contenido de c√°lculos
        calc_content = tk.Frame(calc_card, bg='white', padx=20, pady=15)
        calc_content.pack(fill='both', expand=True)
        
        # Grid de c√°lculos en formato tarjetas
        calc_grid = tk.Frame(calc_content, bg='white')
        calc_grid.pack(fill='x', pady=(0, 15))
        
        # Subtotal card
        subtotal_card = tk.Frame(calc_grid, bg='#F8FAFC', relief='solid', bd=1, padx=15, pady=10)
        subtotal_card.grid(row=0, column=0, sticky='ew', padx=(0, 5))
        
        tk.Label(subtotal_card, text="üíµ Subtotal", bg='#F8FAFC', fg='#1E293B', 
                font=('Arial', 10, 'bold')).pack()
        tk.Label(subtotal_card, textvariable=self.subtotal_var, bg='#F8FAFC', fg='#16A085', 
                font=('Arial', 12, 'bold')).pack()
        
        # Descuento card
        discount_card = tk.Frame(calc_grid, bg='#F8FAFC', relief='solid', bd=1, padx=15, pady=10)
        discount_card.grid(row=0, column=1, sticky='ew', padx=5)
        
        tk.Label(discount_card, text="üé´ Descuento", bg='#F8FAFC', fg='#1E293B', 
                font=('Arial', 10, 'bold')).pack()
        
        discount_frame = tk.Frame(discount_card, bg='#F8FAFC')
        discount_frame.pack()
        
        self.discount_entry = tk.Entry(discount_frame, textvariable=self.discount_var, 
                                      width=8, font=('Arial', 9), relief='solid', bd=1)
        self.discount_entry.pack(side='left')
        self.discount_entry.bind('<KeyRelease>', self.calculate_totals)
        
        tk.Button(discount_frame, text="‚úì", command=self.apply_discount,
                 bg='#16A085', fg='white', font=('Arial', 8, 'bold'), relief='flat',
                 padx=5).pack(side='left', padx=(2, 0))
        
        # Total card
        total_card = tk.Frame(calc_grid, bg='#16A085', relief='solid', bd=2, padx=15, pady=10)
        total_card.grid(row=0, column=2, sticky='ew', padx=(5, 0))
        
        tk.Label(total_card, text="üí≥ TOTAL", bg='#16A085', fg='white', 
                font=('Arial', 11, 'bold')).pack()
        tk.Label(total_card, textvariable=self.total_var, bg='#16A085', fg='white', 
                font=('Arial', 14, 'bold')).pack()
        
        # Configurar grid weights
        calc_grid.columnconfigure(0, weight=1)
        calc_grid.columnconfigure(1, weight=1)
        calc_grid.columnconfigure(2, weight=1)
        
        # Panel de pago como tarjeta
        payment_card = tk.Frame(calc_content, bg='#F8FAFC', relief='solid', bd=1)
        payment_card.pack(fill='x', pady=(0, 15))
        
        payment_header = tk.Frame(payment_card, bg='#F59E0B', height=35)
        payment_header.pack(fill='x')
        payment_header.pack_propagate(False)
        
        tk.Label(payment_header, text="üí≥ Informaci√≥n de Pago", 
                font=('Arial', 11, 'bold'), bg='#F59E0B', fg='white').pack(expand=True)
        
        payment_content = tk.Frame(payment_card, bg='#F8FAFC', padx=15, pady=10)
        payment_content.pack(fill='x')
        
        # Grid de pago
        payment_grid = tk.Frame(payment_content, bg='#F8FAFC')
        payment_grid.pack(fill='x')
        
        # Monto recibido
        received_frame = tk.Frame(payment_grid, bg='#F8FAFC')
        received_frame.grid(row=0, column=0, sticky='ew', padx=(0, 10))
        
        tk.Label(received_frame, text="üí∞ Monto Recibido:", bg='#F8FAFC', fg='#1E293B', 
                font=('Arial', 10, 'bold')).pack()
        
        received_input = tk.Frame(received_frame, bg='#F8FAFC')
        received_input.pack()
        
        self.payment_entry = tk.Entry(received_input, textvariable=self.payment_var, 
                                     width=12, font=('Arial', 10), relief='solid', bd=1)
        self.payment_entry.pack(side='left')
        self.payment_entry.bind('<KeyRelease>', self.calculate_change)
        
        tk.Button(received_input, text="üí° Calcular", command=self.calculate_change,
                 bg='#F59E0B', fg='white', font=('Arial', 8, 'bold'), relief='flat',
                 padx=8).pack(side='left', padx=(5, 0))
        
        # Cambio
        change_frame = tk.Frame(payment_grid, bg='#F8FAFC')
        change_frame.grid(row=0, column=1, sticky='ew', padx=(10, 0))
        
        self.change_label = tk.Label(change_frame, text="üí∏ Cambio:", bg='#F8FAFC', fg='#1E293B', 
                                    font=('Arial', 10, 'bold'))
        self.change_label.pack()
        self.change_value_label = tk.Label(change_frame, textvariable=self.change_var, bg='#F8FAFC', fg='#059669', 
                                          font=('Arial', 11, 'bold'))
        self.change_value_label.pack()
        
        payment_grid.columnconfigure(0, weight=1)
        payment_grid.columnconfigure(1, weight=1)
        
        # Botones principales como tarjetas
        buttons_card = tk.Frame(calc_content, bg='white')
        buttons_card.pack(fill='x')
        
        tk.Button(buttons_card, text="üìÑ GENERAR FACTURA PDF", command=self.generate_invoice_pdf_integrated,
                 bg='#3B82F6', fg='white', font=('Arial', 12, 'bold'), relief='flat',
                 pady=12, cursor='hand2').pack(side='left', padx=(0, 10), fill='x', expand=True)
        
        tk.Button(buttons_card, text="üíæ GUARDAR FACTURA", command=self.save_invoice_integrated,
                 bg='#059669', fg='white', font=('Arial', 12, 'bold'), relief='flat',
                 pady=12, cursor='hand2').pack(side='right', padx=(10, 0), fill='x', expand=True)
    
    
    def create_billing_calculations_panel(self, parent):
        """Panel de c√°lculos de facturaci√≥n"""
        calc_frame = tk.LabelFrame(parent, text="üí∞ C√ÅLCULOS", bg='#fff3e0', fg='#e65100',
                                  font=('Arial', 10, 'bold'), padx=10, pady=10)
        calc_frame.pack(fill='x', pady=(10, 0))
        
        # Subtotal
        subtotal_row = tk.Frame(calc_frame, bg='#fff3e0')
        subtotal_row.pack(fill='x', pady=2)
        tk.Label(subtotal_row, text="Subtotal:", bg='#fff3e0', fg='#e65100', font=('Arial', 10)).pack(side='left')
        tk.Label(subtotal_row, textvariable=self.subtotal_var, bg='#fff3e0', fg='#e65100', 
                font=('Arial', 10, 'bold')).pack(side='right')
        
        # Descuento
        discount_row = tk.Frame(calc_frame, bg='#fff3e0')
        discount_row.pack(fill='x', pady=2)
        tk.Label(discount_row, text="Descuento:", bg='#fff3e0', fg='#e65100', font=('Arial', 10)).pack(side='left')
        
        discount_frame = tk.Frame(discount_row, bg='#fff3e0')
        discount_frame.pack(side='right')
        
        self.discount_entry = tk.Entry(discount_frame, textvariable=self.discount_var, width=10, font=('Arial', 9))
        self.discount_entry.pack(side='left')
        self.discount_entry.bind('<KeyRelease>', self.calculate_totals)
        
        tk.Button(discount_frame, text="Aplicar", command=self.apply_discount,
                 bg='#2196f3', fg='white', font=('Arial', 8)).pack(side='left', padx=(5, 0))
        
        # Total
        total_row = tk.Frame(calc_frame, bg='#fff3e0')
        total_row.pack(fill='x', pady=5)
        tk.Label(total_row, text="TOTAL:", bg='#fff3e0', fg='#e65100', font=('Arial', 12, 'bold')).pack(side='left')
        tk.Label(total_row, textvariable=self.total_var, bg='#fff3e0', fg='#e65100', 
                font=('Arial', 12, 'bold')).pack(side='right')
        
        # Panel de pago
        payment_frame = tk.LabelFrame(parent, text="üí≥ INFORMACI√ìN DE PAGO", bg='#fff3e0', fg='#e65100',
                                     font=('Arial', 10, 'bold'), padx=10, pady=10)
        payment_frame.pack(fill='x', pady=(10, 0))
        
        # Monto pagado
        payment_row = tk.Frame(payment_frame, bg='#fff3e0')
        payment_row.pack(fill='x', pady=2)
        tk.Label(payment_row, text="Monto Recibido:", bg='#fff3e0', fg='#e65100', font=('Arial', 10)).pack(side='left')
        
        payment_entry_frame = tk.Frame(payment_row, bg='#fff3e0')
        payment_entry_frame.pack(side='right')
        
        self.payment_entry = tk.Entry(payment_entry_frame, textvariable=self.payment_var, width=10, font=('Arial', 9))
        self.payment_entry.pack(side='left')
        self.payment_entry.bind('<KeyRelease>', self.calculate_change)
        
        tk.Button(payment_entry_frame, text="Calcular", command=self.calculate_change,
                 bg='#4caf50', fg='white', font=('Arial', 8)).pack(side='left', padx=(5, 0))
        
        # Cambio/Faltante
        change_row = tk.Frame(payment_frame, bg='#fff3e0')
        change_row.pack(fill='x', pady=2)
        self.change_label = tk.Label(change_row, text="Cambio:", bg='#fff3e0', fg='#e65100', font=('Arial', 10))
        self.change_label.pack(side='left')
        self.change_value_label = tk.Label(change_row, textvariable=self.change_var, bg='#fff3e0', fg='#4caf50', 
                                          font=('Arial', 10, 'bold'))
        self.change_value_label.pack(side='right')
        
        # Botones principales
        buttons_frame = tk.Frame(parent, bg='#fff3e0')
        buttons_frame.pack(fill='x', pady=(10, 0))
        
        tk.Button(buttons_frame, text="üìÑ GENERAR FACTURA PDF", command=self.generate_invoice_pdf_integrated,
                 bg='#2196f3', fg='white', font=('Arial', 11, 'bold'), pady=8).pack(side='left', padx=(0, 5), fill='x', expand=True)
        
        tk.Button(buttons_frame, text="üíæ GUARDAR", command=self.save_invoice_integrated,
                 bg='#4caf50', fg='white', font=('Arial', 11, 'bold'), pady=8).pack(side='right', padx=(5, 0), fill='x', expand=True)
    
    def create_integrated_services_content(self, parent):
        """Pesta√±a de gesti√≥n de servicios m√©dicos"""
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Header
        tk.Label(main_frame, text="üè• GESTI√ìN DE SERVICIOS M√âDICOS", 
                font=('Arial', 16, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(pady=(0, 20))
        
        # Botones de acci√≥n
        buttons_frame = tk.Frame(main_frame, bg='#F8FAFC')
        buttons_frame.pack(fill='x', pady=(0, 20))
        
        tk.Button(buttons_frame, text="‚ûï Nuevo Servicio", command=self.add_new_service,
                 bg='#4caf50', fg='white', font=('Arial', 10, 'bold')).pack(side='left', padx=(0, 10))
        tk.Button(buttons_frame, text="‚úèÔ∏è Editar Servicio", command=self.edit_selected_service,
                 bg='#ff9800', fg='white', font=('Arial', 10, 'bold')).pack(side='left', padx=(0, 10))
        tk.Button(buttons_frame, text="‚ùå Eliminar Servicio", command=self.delete_selected_service,
                 bg='#f44336', fg='white', font=('Arial', 10, 'bold')).pack(side='left')
        
        # Tabla de servicios
        # Frame contenedor para tabla y scrollbars
        table_frame_mgmt = tk.Frame(main_frame, bg='#F8FAFC')
        table_frame_mgmt.pack(fill='both', expand=True)
        
        columns = ('C√≥digo', 'Nombre', 'Categor√≠a', 'Precio')
        self.services_management_tree = ttk.Treeview(table_frame_mgmt, columns=columns, show='headings', height=15)
        
        for col in columns:
            self.services_management_tree.heading(col, text=col)
            self.services_management_tree.column(col, width=150, anchor='center')
        
        # Scrollbars verticales y horizontales con mejor visibilidad
        scroll_services_mgmt_y = ttk.Scrollbar(table_frame_mgmt, orient="vertical", command=self.services_management_tree.yview)
        scroll_services_mgmt_x = ttk.Scrollbar(table_frame_mgmt, orient="horizontal", command=self.services_management_tree.xview)
        self.services_management_tree.configure(yscrollcommand=scroll_services_mgmt_y.set, xscrollcommand=scroll_services_mgmt_x.set)
        
        # Layout con grid para mejor control de scrollbars con padding
        self.services_management_tree.grid(row=0, column=0, sticky='nsew', padx=(5, 0), pady=(5, 0))
        scroll_services_mgmt_y.grid(row=0, column=1, sticky='ns', padx=(0, 5), pady=(5, 0))
        scroll_services_mgmt_x.grid(row=1, column=0, sticky='ew', padx=(5, 0), pady=(0, 5))
        
        # Configurar expansi√≥n con m√≠nimo para scrollbars
        table_frame_mgmt.grid_rowconfigure(0, weight=1)
        table_frame_mgmt.grid_rowconfigure(1, weight=0, minsize=20)
        table_frame_mgmt.grid_columnconfigure(0, weight=1)
        table_frame_mgmt.grid_columnconfigure(1, weight=0, minsize=20)
        
        # Cargar servicios
        self.load_services_management()
    
    def create_integrated_reports_content(self, parent):
        """Pesta√±a de reportes del sistema de facturaci√≥n"""
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Header
        tk.Label(main_frame, text="üìä REPORTES DE FACTURACI√ìN", 
                font=('Arial', 16, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(pady=(0, 20))
        
        # Panel de estad√≠sticas
        stats_frame = tk.LabelFrame(main_frame, text="üìà ESTAD√çSTICAS R√ÅPIDAS", 
                                   font=('Arial', 12, 'bold'), bg='#e3f2fd', fg='#1565c0',
                                   padx=20, pady=15)
        stats_frame.pack(fill='x', pady=(0, 20))
        
        # Grid de estad√≠sticas
        stats_grid = tk.Frame(stats_frame, bg='#e3f2fd')
        stats_grid.pack()
        
        try:
            # Obtener estad√≠sticas de la base de datos
            stats = self.get_billing_statistics_integrated()
            
            stats_items = [
                ("üí∞", "Ingresos Hoy", f"RD$ {stats.get('ingresos_hoy', 0):,.2f}", "#4caf50"),
                ("üìã", "Facturas Hoy", str(stats.get('facturas_hoy', 0)), "#2196f3"),
                ("‚è≥", "Pendientes", str(stats.get('pendientes', 0)), "#ff9800"),
                ("üìÖ", "Este Mes", f"RD$ {stats.get('ingresos_mes', 0):,.2f}", "#9c27b0")
            ]
            
            for i, (icon, title, value, color) in enumerate(stats_items):
                col = i % 4
                
                stat_frame = tk.Frame(stats_grid, bg='white', relief='raised', bd=2)
                stat_frame.grid(row=0, column=col, padx=10, pady=10)
                
                tk.Label(stat_frame, text=icon, font=('Arial', 20), bg='white').pack(pady=(10, 5))
                tk.Label(stat_frame, text=title, font=('Arial', 10, 'bold'), bg='white', fg='#1E3A8A').pack()
                tk.Label(stat_frame, text=value, font=('Arial', 12, 'bold'), bg='white', fg=color).pack(pady=(5, 10))
                
        except Exception as e:
            tk.Label(stats_grid, text=f"Error cargando estad√≠sticas: {str(e)}", 
                    bg='#e3f2fd', fg='red').pack()
        
        # Botones de reportes
        reports_frame = tk.LabelFrame(main_frame, text="üìÑ GENERAR REPORTES", 
                                     font=('Arial', 12, 'bold'), bg='#f1f8e9', fg='#2e7d32',
                                     padx=20, pady=15)
        reports_frame.pack(fill='x', pady=(0, 20))
        
        reports_buttons = [
            ("üìä Reporte Diario", self.generate_daily_report_integrated, "#4caf50"),
            ("üìà Reporte Mensual", self.generate_monthly_report_integrated, "#2196f3"),
            ("üìã Facturas Pendientes", self.generate_pending_report_integrated, "#ff9800"),
            ("üí∞ Ingresos por Servicio", self.generate_services_report_integrated, "#9c27b0")
        ]
        
        reports_grid = tk.Frame(reports_frame, bg='#f1f8e9')
        reports_grid.pack()
        
        for i, (text, command, color) in enumerate(reports_buttons):
            row = i // 2
            col = i % 2
            
            btn = tk.Button(reports_grid, text=text, command=command,
                           bg=color, fg='white', font=('Arial', 10, 'bold'),
                           padx=20, pady=10)
            btn.grid(row=row, column=col, padx=10, pady=10, sticky='ew')
            
        reports_grid.grid_columnconfigure(0, weight=1)
        reports_grid.grid_columnconfigure(1, weight=1)
    
    def create_billing_status_bar(self, parent):
        """Barra de estado para el sistema de facturaci√≥n"""
        status_frame = tk.Frame(parent, bg='#0B5394', height=30)
        status_frame.pack(fill='x', side='bottom')
        status_frame.pack_propagate(False)
        
        self.status_label = tk.Label(status_frame, text="Sistema de facturaci√≥n listo", 
                                    bg='#0B5394', fg='white', font=('Arial', 10))
        self.status_label.pack(side='left', padx=10, pady=5)
        
        # Fecha y hora actual
        current_time = datetime.now().strftime('%d/%m/%Y %H:%M')
        tk.Label(status_frame, text=current_time, bg='#0B5394', fg='#CBD5E1', 
                font=('Arial', 9)).pack(side='right', padx=10, pady=5)
    
    # ==================== FUNCIONES DE L√ìGICA DEL SISTEMA DE FACTURACI√ìN INTEGRADO ====================
    
    def load_integrated_billing_data(self):
        """Cargar datos del sistema de facturaci√≥n integrado"""
        try:
            self.load_appointments_for_billing()
            self.load_services_for_billing()
            self.update_status("Datos cargados correctamente")
        except Exception as e:
            self.update_status(f"Error cargando datos: {str(e)}")
    
    def load_appointments_for_billing(self):
        """Cargar citas para facturaci√≥n en formato de tarjetas"""
        print("üîÑ DEBUG: Ejecutando load_appointments_for_billing()")
        if not hasattr(self, 'appointments_cards_frame'):
            print("‚ùå DEBUG: No existe appointments_cards_frame")
            return
            
        try:
            # Limpiar tarjetas anteriores
            for widget in self.appointments_cards_frame.winfo_children():
                widget.destroy()
            
            # Tambi√©n actualizar el TreeView oculto para compatibilidad
            if hasattr(self, 'appointments_tree_billing'):
                for item in self.appointments_tree_billing.get_children():
                    self.appointments_tree_billing.delete(item)
            
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            filter_value = self.appointment_filter_var.get()
            print(f"üîç DEBUG: Filtro actual: {filter_value}")
            
            if filter_value == "completadas":
                query = """
                SELECT c.id, 
                       DATE(c.fecha_hora) as fecha_cita, 
                       TIME(c.fecha_hora) as hora_cita,
                       p.nombre || ' ' || p.apellido as paciente,
                       u.nombre || ' ' || u.apellido as doctor,
                       c.estado,
                       'No' as facturada
                FROM citas c
                JOIN usuarios p ON c.paciente_id = p.id
                JOIN usuarios u ON c.doctor_id = u.id
                LEFT JOIN facturas f ON c.id = f.cita_id
                WHERE c.estado = 'completada' AND f.id IS NULL
                ORDER BY c.fecha_hora DESC
                """
            elif filter_value == "hoy":
                query = """
                SELECT c.id, 
                       DATE(c.fecha_hora) as fecha_cita, 
                       TIME(c.fecha_hora) as hora_cita,
                       p.nombre || ' ' || p.apellido as paciente,
                       u.nombre || ' ' || u.apellido as doctor,
                       c.estado,
                       'No' as facturada
                FROM citas c
                JOIN usuarios p ON c.paciente_id = p.id
                JOIN usuarios u ON c.doctor_id = u.id
                LEFT JOIN facturas f ON c.id = f.cita_id
                WHERE DATE(c.fecha_hora) = DATE('now', 'localtime') AND f.id IS NULL
                ORDER BY c.fecha_hora
                """
            else:  # todas
                query = """
                SELECT c.id, 
                       DATE(c.fecha_hora) as fecha_cita, 
                       TIME(c.fecha_hora) as hora_cita,
                       p.nombre || ' ' || p.apellido as paciente,
                       u.nombre || ' ' || u.apellido as doctor,
                       c.estado,
                       'No' as facturada
                FROM citas c
                JOIN usuarios p ON c.paciente_id = p.id
                JOIN usuarios u ON c.doctor_id = u.id
                LEFT JOIN facturas f ON c.id = f.cita_id
                WHERE f.id IS NULL
                ORDER BY c.fecha_hora DESC
                """
            
            cursor.execute(query)
            appointments = cursor.fetchall()
            
            print(f"üìä DEBUG: Se encontraron {len(appointments)} citas para facturar")
            
            # Crear tarjetas para cada cita
            for i, appointment in enumerate(appointments):
                print(f"‚ûï DEBUG: Creando tarjeta para cita {appointment[0]} - {appointment[3]}")
                self.create_appointment_card(appointment, i)
                
                # Tambi√©n agregar al TreeView oculto para compatibilidad
                if hasattr(self, 'appointments_tree_billing'):
                    self.appointments_tree_billing.insert('', 'end', values=appointment)
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            print(f"Error cargando citas para facturaci√≥n: {str(e)}")
    
    def create_appointment_card(self, appointment_data, index):
        """Crear tarjeta individual para cada cita"""
        # Frame de la tarjeta
        card = tk.Frame(self.appointments_cards_frame, bg='white', relief='solid', bd=1)
        card.pack(fill='x', pady=5, padx=5)
        
        # Variable para almacenar datos de la cita
        card.appointment_data = appointment_data
        
        # Contenido de la tarjeta
        card_content = tk.Frame(card, bg='white', padx=15, pady=10)
        card_content.pack(fill='x')
        
        # Fila superior: ID y estado
        top_row = tk.Frame(card_content, bg='white')
        top_row.pack(fill='x', pady=(0, 5))
        
        # ID de la cita
        tk.Label(top_row, text=f"Cita #{appointment_data[0]}", 
                font=('Arial', 10, 'bold'), bg='white', fg='#1E3A8A').pack(side='left')
        
        # Estado con color
        estado = appointment_data[5]
        estado_colors = {
            'completada': '#059669',
            'confirmada': '#3B82F6',
            'pendiente': '#F59E0B',
            'cancelada': '#DC2626'
        }
        estado_color = estado_colors.get(estado, '#64748B')
        
        estado_label = tk.Label(top_row, text=estado.upper(), 
                               font=('Arial', 9, 'bold'), bg=estado_color, fg='white',
                               padx=8, pady=2)
        estado_label.pack(side='right')
        
        # Fila del paciente
        patient_row = tk.Frame(card_content, bg='white')
        patient_row.pack(fill='x', pady=2)
        
        tk.Label(patient_row, text="üë§", font=('Arial', 12), bg='white').pack(side='left')
        tk.Label(patient_row, text=appointment_data[3], 
                font=('Arial', 11, 'bold'), bg='white', fg='#1E293B').pack(side='left', padx=(5, 0))
        
        # Fila del doctor
        doctor_row = tk.Frame(card_content, bg='white')
        doctor_row.pack(fill='x', pady=2)
        
        tk.Label(doctor_row, text="üë®‚Äç‚öïÔ∏è", font=('Arial', 12), bg='white').pack(side='left')
        tk.Label(doctor_row, text=appointment_data[4], 
                font=('Arial', 10), bg='white', fg='#64748B').pack(side='left', padx=(5, 0))
        
        # Fila de fecha y hora
        datetime_row = tk.Frame(card_content, bg='white')
        datetime_row.pack(fill='x', pady=2)
        
        tk.Label(datetime_row, text="üìÖ", font=('Arial', 12), bg='white').pack(side='left')
        tk.Label(datetime_row, text=f"{appointment_data[1]} - {appointment_data[2]}", 
                font=('Arial', 10), bg='white', fg='#64748B').pack(side='left', padx=(5, 0))
        
        # Bot√≥n de selecci√≥n
        select_btn = tk.Button(card_content, text="üìã Seleccionar para Facturar",
                              bg='#3B82F6', fg='white', font=('Arial', 10, 'bold'),
                              relief='flat', padx=15, pady=8, cursor='hand2',
                              command=lambda: self.select_appointment_card(card))
        select_btn.pack(pady=(10, 0))
        
        # Efecto hover
        def on_enter(e):
            card.config(bg='#F8FAFC', relief='raised')
            card_content.config(bg='#F8FAFC')
            for child in card_content.winfo_children():
                try:
                    child.config(bg='#F8FAFC')
                    for grandchild in child.winfo_children():
                        try:
                            if grandchild.winfo_class() == 'Label' and grandchild.cget('bg') == 'white':
                                grandchild.config(bg='#F8FAFC')
                        except:
                            pass
                except:
                    pass
        
        def on_leave(e):
            if not hasattr(card, 'selected') or not card.selected:
                card.config(bg='white', relief='solid')
                card_content.config(bg='white')
                for child in card_content.winfo_children():
                    try:
                        child.config(bg='white')
                        for grandchild in child.winfo_children():
                            try:
                                if grandchild.winfo_class() == 'Label' and grandchild.cget('bg') == '#F8FAFC':
                                    grandchild.config(bg='white')
                            except:
                                pass
                    except:
                        pass
        
        card.bind("<Enter>", on_enter)
        card.bind("<Leave>", on_leave)
        card_content.bind("<Enter>", on_enter)
        card_content.bind("<Leave>", on_leave)
    
    def select_appointment_card(self, selected_card):
        """Seleccionar una tarjeta de cita"""
        # Desmarcar todas las tarjetas
        for widget in self.appointments_cards_frame.winfo_children():
            if hasattr(widget, 'selected'):
                widget.selected = False
                widget.config(bg='white', relief='solid')
        
        # Marcar la tarjeta seleccionada
        selected_card.selected = True
        selected_card.config(bg='#E3F2FD', relief='raised', bd=2)
        
        # Simular selecci√≥n en TreeView oculto para compatibilidad
        appointment_data = selected_card.appointment_data
        self.current_appointment_billing = {
            'id': appointment_data[0],
            'fecha': appointment_data[1],
            'paciente': appointment_data[3],
            'doctor': appointment_data[4],
            'estado': appointment_data[5],
            'facturada': appointment_data[6]
        }
        
        # Actualizar informaci√≥n del paciente
        if hasattr(self, 'patient_info_label'):
            info_text = f"Paciente: {appointment_data[3]} | Doctor: {appointment_data[4]} | Fecha: {appointment_data[1]}"
            self.patient_info_label.config(text=info_text)
    
    def load_services_for_billing(self):
        """Cargar servicios m√©dicos para facturaci√≥n en formato de tarjetas"""
        if not hasattr(self, 'services_grid_frame'):
            return
            
        try:
            # Limpiar tarjetas anteriores
            for widget in self.services_grid_frame.winfo_children():
                widget.destroy()
            
            # Tambi√©n actualizar TreeView oculto para compatibilidad
            if hasattr(self, 'services_tree_billing'):
                for item in self.services_tree_billing.get_children():
                    self.services_tree_billing.delete(item)
            
            # Crear grid para las tarjetas de servicios
            current_row = 0
            current_col = 0
            max_cols = 3  # 3 tarjetas por fila
            
            # Cargar servicios predefinidos
            for i, service in enumerate(self.medical_services):
                self.create_service_card(service, current_row, current_col)
                
                # Tambi√©n agregar al TreeView oculto para compatibilidad
                if hasattr(self, 'services_tree_billing'):
                    self.services_tree_billing.insert('', 'end', values=(
                        service['codigo'],
                        service['nombre'],
                        service['categoria'],
                        f"RD$ {service['precio']:,.2f}"
                    ))
                
                current_col += 1
                if current_col >= max_cols:
                    current_col = 0
                    current_row += 1
            
            # Configurar pesos de las columnas
            for i in range(max_cols):
                self.services_grid_frame.columnconfigure(i, weight=1)
            
        except Exception as e:
            print(f"Error cargando servicios: {str(e)}")
    
    def create_service_card(self, service, row, col):
        """Crear tarjeta individual para cada servicio"""
        # Frame de la tarjeta
        card = tk.Frame(self.services_grid_frame, bg='white', relief='solid', bd=1)
        card.grid(row=row, column=col, padx=5, pady=5, sticky='ew')
        
        # Variable para almacenar datos del servicio
        card.service_data = service
        
        # Header de la tarjeta con color por categor√≠a
        category_colors = {
            'Consulta': '#3B82F6',
            'Laboratorio': '#DC2626',
            'Imagen': '#059669',
            'Procedimiento': '#F59E0B',
            'Cardiolog√≠a': '#8B5CF6',
            'Prevenci√≥n': '#06B6D4'
        }
        header_color = category_colors.get(service['categoria'], '#64748B')
        
        card_header = tk.Frame(card, bg=header_color, height=35)
        card_header.pack(fill='x')
        card_header.pack_propagate(False)
        
        tk.Label(card_header, text=service['categoria'], 
                font=('Arial', 10, 'bold'), bg=header_color, fg='white').pack(expand=True)
        
        # Contenido de la tarjeta
        card_content = tk.Frame(card, bg='white', padx=10, pady=10)
        card_content.pack(fill='both', expand=True)
        
        # C√≥digo del servicio
        tk.Label(card_content, text=f"#{service['codigo']}", 
                font=('Arial', 8), bg='white', fg='#64748B').pack(anchor='w')
        
        # Nombre del servicio
        name_label = tk.Label(card_content, text=service['nombre'], 
                             font=('Arial', 10, 'bold'), bg='white', fg='#1E293B',
                             wraplength=180, justify='left')
        name_label.pack(anchor='w', pady=(2, 8))
        
        # Precio
        price_frame = tk.Frame(card_content, bg='white')
        price_frame.pack(fill='x', pady=(0, 8))
        
        tk.Label(price_frame, text="üí∞", font=('Arial', 12), bg='white').pack(side='left')
        tk.Label(price_frame, text=f"RD$ {service['precio']:,.2f}", 
                font=('Arial', 11, 'bold'), bg='white', fg='#059669').pack(side='left', padx=(5, 0))
        
        # Bot√≥n agregar
        add_btn = tk.Button(card_content, text="‚ûï Agregar",
                           bg='#059669', fg='white', font=('Arial', 9, 'bold'),
                           relief='flat', padx=10, pady=5, cursor='hand2',
                           command=lambda: self.add_service_from_card(card))
        add_btn.pack(fill='x')
        
        # Efectos hover
        def on_enter(e):
            card.config(relief='raised', bd=2)
            add_btn.config(bg='#047857')
        
        def on_leave(e):
            card.config(relief='solid', bd=1)
            add_btn.config(bg='#059669')
        
        card.bind("<Enter>", on_enter)
        card.bind("<Leave>", on_leave)
        card_content.bind("<Enter>", on_enter)
        card_content.bind("<Leave>", on_leave)
    
    def add_service_from_card(self, service_card):
        """Agregar servicio desde tarjeta a la factura"""
        if not self.current_appointment_billing:
            messagebox.showwarning("Cita", "Por favor seleccione una cita primero")
            return
        
        service = service_card.service_data
        
        # Pedir cantidad
        quantity = simpledialog.askinteger("Cantidad", f"Cantidad de '{service['nombre']}':", 
                                          initialvalue=1, minvalue=1, maxvalue=10)
        if not quantity:
            return
        
        # Agregar a la lista de servicios seleccionados
        service_invoice = {
            'codigo': service['codigo'],
            'nombre': service['nombre'],
            'cantidad': quantity,
            'precio_unitario': service['precio'],
            'total': service['precio'] * quantity
        }
        
        self.selected_services.append(service_invoice)
        self.update_selected_services_display()
        self.calculate_totals()
    
    def update_selected_services_display(self):
        """Actualizar la visualizaci√≥n de servicios seleccionados en tarjetas"""
        if not hasattr(self, 'selected_services_frame'):
            return
            
        # Limpiar tarjetas anteriores
        for widget in self.selected_services_frame.winfo_children():
            widget.destroy()
        
        # Tambi√©n actualizar TreeView oculto para compatibilidad
        if hasattr(self, 'invoice_services_tree'):
            for item in self.invoice_services_tree.get_children():
                self.invoice_services_tree.delete(item)
        
        # Crear tarjetas para servicios seleccionados
        for i, service in enumerate(self.selected_services):
            self.create_selected_service_card(service, i)
            
            # Tambi√©n agregar al TreeView oculto para compatibilidad
            if hasattr(self, 'invoice_services_tree'):
                self.invoice_services_tree.insert('', 'end', values=(
                    service['nombre'],
                    service['cantidad'],
                    f"RD$ {service['precio_unitario']:,.2f}",
                    f"RD$ {service['total']:,.2f}"
                ))
        
        # Si no hay servicios, mostrar mensaje
        if not self.selected_services:
            empty_label = tk.Label(self.selected_services_frame, 
                                  text="No hay servicios seleccionados\nAgrege servicios de la lista de la izquierda",
                                  bg='#F8FAFC', fg='#64748B', font=('Arial', 10),
                                  justify='center')
            empty_label.pack(expand=True, pady=20)
    
    def create_selected_service_card(self, service, index):
        """Crear tarjeta para servicio seleccionado en la factura"""
        # Frame de la tarjeta
        card = tk.Frame(self.selected_services_frame, bg='white', relief='solid', bd=1)
        card.pack(fill='x', pady=2, padx=2)
        
        # Variable para almacenar √≠ndice del servicio
        card.service_index = index
        
        # Contenido de la tarjeta
        card_content = tk.Frame(card, bg='white', padx=10, pady=8)
        card_content.pack(fill='x')
        
        # Fila superior: nombre y bot√≥n eliminar
        top_row = tk.Frame(card_content, bg='white')
        top_row.pack(fill='x')
        
        # Nombre del servicio
        tk.Label(top_row, text=service['nombre'], 
                font=('Arial', 10, 'bold'), bg='white', fg='#1E293B').pack(side='left')
        
        # Bot√≥n eliminar
        remove_btn = tk.Button(top_row, text="‚ùå", 
                              bg='#DC2626', fg='white', font=('Arial', 8, 'bold'),
                              relief='flat', padx=5, pady=2, cursor='hand2',
                              command=lambda: self.remove_service_by_index(index))
        remove_btn.pack(side='right')
        
        # Fila inferior: cantidad, precio unitario y total
        bottom_row = tk.Frame(card_content, bg='white')
        bottom_row.pack(fill='x', pady=(5, 0))
        
        # Cantidad
        qty_frame = tk.Frame(bottom_row, bg='white')
        qty_frame.pack(side='left')
        tk.Label(qty_frame, text=f"Cant: {service['cantidad']}", 
                font=('Arial', 9), bg='white', fg='#64748B').pack()
        
        # Precio unitario
        unit_frame = tk.Frame(bottom_row, bg='white')
        unit_frame.pack(side='left', padx=(20, 0))
        tk.Label(unit_frame, text=f"Unit: RD$ {service['precio_unitario']:,.2f}", 
                font=('Arial', 9), bg='white', fg='#64748B').pack()
        
        # Total
        total_frame = tk.Frame(bottom_row, bg='white')
        total_frame.pack(side='right')
        tk.Label(total_frame, text=f"Total: RD$ {service['total']:,.2f}", 
                font=('Arial', 9, 'bold'), bg='white', fg='#059669').pack()
    
    def remove_service_by_index(self, index):
        """Eliminar servicio por √≠ndice"""
        try:
            if 0 <= index < len(self.selected_services):
                self.selected_services.pop(index)
                self.update_selected_services_display()
                self.calculate_totals()
        except Exception as e:
            print(f"Error eliminando servicio: {e}")
    
    def filter_services(self, event=None):
        """Filtrar servicios m√©dicos en formato de tarjetas"""
        search_term = self.service_search_var.get().lower()
        
        if not hasattr(self, 'services_grid_frame'):
            return
        
        # Limpiar tarjetas anteriores
        for widget in self.services_grid_frame.winfo_children():
            widget.destroy()
        
        # Tambi√©n limpiar TreeView oculto
        if hasattr(self, 'services_tree_billing'):
            for item in self.services_tree_billing.get_children():
                self.services_tree_billing.delete(item)
        
        # Filtrar y mostrar servicios
        current_row = 0
        current_col = 0
        max_cols = 3
        
        for service in self.medical_services:
            if (search_term in service['nombre'].lower() or 
                search_term in service['categoria'].lower() or
                search_term in service['codigo'].lower()):
                
                self.create_service_card(service, current_row, current_col)
                
                # Tambi√©n agregar al TreeView oculto para compatibilidad
                if hasattr(self, 'services_tree_billing'):
                    self.services_tree_billing.insert('', 'end', values=(
                        service['codigo'],
                        service['nombre'],
                        service['categoria'],
                        f"RD$ {service['precio']:,.2f}"
                    ))
                
                current_col += 1
                if current_col >= max_cols:
                    current_col = 0
                    current_row += 1
        
        # Configurar pesos de las columnas
        for i in range(max_cols):
            self.services_grid_frame.columnconfigure(i, weight=1)
    
    def filter_appointments_billing(self, event=None):
        """Filtrar citas para facturaci√≥n"""
        self.load_appointments_for_billing()
    
    def on_appointment_select_for_billing(self, event=None):
        """Cuando se selecciona una cita (compatibilidad con TreeView)"""
        # Esta funci√≥n ahora es manejada por select_appointment_card
        pass
    
    def add_service_to_invoice(self):
        """Agregar servicio a la factura (funci√≥n de compatibilidad)"""
        # Esta funci√≥n ahora es manejada por add_service_from_card
        messagebox.showinfo("Informaci√≥n", "Use los botones '‚ûï Agregar' en las tarjetas de servicios")
    
    def update_invoice_services_display(self):
        """Actualizar la visualizaci√≥n de servicios en la factura (funci√≥n de compatibilidad)"""
        # Esta funci√≥n ahora es manejada por update_selected_services_display
        self.update_selected_services_display()
    
    def remove_service_from_invoice(self):
        """Quitar servicio de la factura"""
        if not self.selected_services:
            messagebox.showwarning("Sin servicios", "No hay servicios para eliminar")
            return
        
        # Mostrar di√°logo para seleccionar qu√© servicio eliminar
        if len(self.selected_services) == 1:
            # Si solo hay un servicio, eliminarlo directamente
            self.selected_services.pop(0)
            self.update_selected_services_display()
            self.calculate_totals()
        else:
            # Si hay m√∫ltiples servicios, mostrar lista para seleccionar
            service_names = [f"{i+1}. {s['nombre']} (Cant: {s['cantidad']})" for i, s in enumerate(self.selected_services)]
            
            # Crear ventana de selecci√≥n
            selection_window = tk.Toplevel(self.root)
            selection_window.title("Seleccionar Servicio a Eliminar")
            selection_window.geometry("400x300")
            selection_window.configure(bg='#F8FAFC')
            selection_window.transient(self.root)
            selection_window.grab_set()
            
            # Centrar ventana
            selection_window.update_idletasks()
            x = (selection_window.winfo_screenwidth() // 2) - (400 // 2)
            y = (selection_window.winfo_screenheight() // 2) - (300 // 2)
            selection_window.geometry(f"400x300+{x}+{y}")
            
            # Header
            header_frame = tk.Frame(selection_window, bg='#DC2626', height=50)
            header_frame.pack(fill='x')
            header_frame.pack_propagate(False)
            
            tk.Label(header_frame, text="‚ùå Eliminar Servicio", 
                    font=('Arial', 14, 'bold'), bg='#DC2626', fg='white').pack(expand=True)
            
            # Lista de servicios
            main_frame = tk.Frame(selection_window, bg='#F8FAFC', padx=20, pady=20)
            main_frame.pack(fill='both', expand=True)
            
            tk.Label(main_frame, text="Seleccione el servicio a eliminar:", 
                    font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E293B').pack(anchor='w', pady=(0, 10))
            
            # Variable para la selecci√≥n
            selected_var = tk.IntVar()
            
            # Crear radiobuttons para cada servicio
            for i, service_name in enumerate(service_names):
                rb = tk.Radiobutton(main_frame, text=service_name, variable=selected_var, value=i,
                                   font=('Arial', 10), bg='#F8FAFC', fg='#1E293B')
                rb.pack(anchor='w', pady=2)
            
            # Botones
            buttons_frame = tk.Frame(main_frame, bg='#F8FAFC')
            buttons_frame.pack(fill='x', pady=(20, 0))
            
            def confirm_delete():
                index = selected_var.get()
                self.remove_service_by_index(index)
                selection_window.destroy()
            
            tk.Button(buttons_frame, text="‚ùå Eliminar", command=confirm_delete,
                     bg='#DC2626', fg='white', font=('Arial', 10, 'bold'),
                     relief='flat', padx=15, pady=8).pack(side='left')
            
            tk.Button(buttons_frame, text="Cancelar", command=selection_window.destroy,
                     bg='#64748B', fg='white', font=('Arial', 10, 'bold'),
                     relief='flat', padx=15, pady=8).pack(side='left', padx=(10, 0))
    
    def edit_service_in_invoice(self):
        """Editar servicio en la factura"""
        if not hasattr(self, 'invoice_services_tree') or not self.invoice_services_tree:
            return
            
        selection = self.invoice_services_tree.selection()
        if not selection:
            messagebox.showwarning("Selecci√≥n", "Por favor seleccione un servicio para editar")
            return
        
        # Obtener √≠ndice del servicio seleccionado
        index = self.invoice_services_tree.index(selection[0])
        service = self.selected_services[index]
        
        # Pedir nueva cantidad
        new_quantity = simpledialog.askinteger("Editar Cantidad", 
                                              f"Nueva cantidad para '{service['nombre']}':", 
                                              initialvalue=service['cantidad'], minvalue=1, maxvalue=10)
        if new_quantity and new_quantity != service['cantidad']:
            service['cantidad'] = new_quantity
            service['total'] = service['precio_unitario'] * new_quantity
            self.update_invoice_services_display()
            self.calculate_totals()
    
    def calculate_totals(self, event=None):
        """Calcular totales de la factura"""
        subtotal = sum(service['total'] for service in self.selected_services)
        
        try:
            discount = float(self.discount_var.get() or 0)
        except ValueError:
            discount = 0
            self.discount_var.set("0.00")
        
        total = subtotal - discount
        if total < 0:
            total = 0
        
        self.subtotal_var.set(f"RD$ {subtotal:,.2f}")
        self.total_var.set(f"RD$ {total:,.2f}")
        
        # Recalcular cambio si hay pago ingresado
        self.calculate_change()
    
    def apply_discount(self):
        """Aplicar descuento"""
        self.calculate_totals()
    
    def calculate_change(self, event=None):
        """Calcular cambio o faltante"""
        try:
            total_str = self.total_var.get().replace('RD$', '').replace(',', '')
            total = float(total_str)
            
            payment = float(self.payment_var.get() or 0)
            
            difference = payment - total
            
            if difference > 0:
                self.change_label.config(text="Cambio:")
                self.change_var.set(f"RD$ {difference:,.2f}")
                self.change_value_label.config(fg='#4caf50')
            elif difference < 0:
                self.change_label.config(text="Faltante:")
                self.change_var.set(f"RD$ {abs(difference):,.2f}")
                self.change_value_label.config(fg='#f44336')
            else:
                self.change_label.config(text="Exacto:")
                self.change_var.set("RD$ 0.00")
                self.change_value_label.config(fg='#4caf50')
                
        except ValueError:
            self.change_var.set("RD$ 0.00")
            self.change_value_label.config(fg='#4caf50')
    
    def generate_invoice_pdf_integrated(self):
        """Generar PDF de factura integrada"""
        if not self.current_appointment_billing:
            messagebox.showwarning("Cita", "Por favor seleccione una cita primero")
            return
        
        if not self.selected_services:
            messagebox.showwarning("Servicios", "Por favor agregue al menos un servicio")
            return
        
        try:
            # Crear directorio de PDFs si no existe
            pdf_directory = "facturas_pdf"
            if not os.path.exists(pdf_directory):
                os.makedirs(pdf_directory)
            
            # Generar n√∫mero de factura
            invoice_number = f"FAC-{datetime.now().strftime('%Y-%m')}-{datetime.now().strftime('%d%H%M%S')}"
            
            # Nombre del archivo
            patient_name = self.current_appointment_billing['paciente'].replace(' ', '_')
            filename = f"Factura_{invoice_number}_{patient_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
            filepath = os.path.join(pdf_directory, filename)
            
            # Generar PDF simple (sin dependencias externas)
            self.generate_simple_pdf(filepath, invoice_number)
            
            messagebox.showinfo("PDF Generado", f"Factura guardada como:\n{filename}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error generando PDF: {str(e)}")
    
    def generate_simple_pdf(self, filepath, invoice_number):
        """Generar PDF simple de texto"""
        try:
            total_str = self.total_var.get().replace('RD$', '').replace(',', '')
            total = float(total_str)
            
            payment = float(self.payment_var.get() or 0)
            
            # Crear contenido de texto para el PDF (como fallback)
            content = f"""
=====================================
        MEDISYNC - CENTRO M√âDICO
=====================================

FACTURA M√âDICA
N√∫mero: {invoice_number}
Fecha: {datetime.now().strftime('%d/%m/%Y %H:%M')}

-------------------------------------
INFORMACI√ìN DEL PACIENTE
-------------------------------------
Paciente: {self.current_appointment_billing['paciente']}
Doctor: {self.current_appointment_billing['doctor']}
Fecha de Cita: {self.current_appointment_billing['fecha']}

-------------------------------------
SERVICIOS PRESTADOS
-------------------------------------
"""
            
            for service in self.selected_services:
                content += f"{service['nombre']:<30} x{service['cantidad']:>3} = RD$ {service['total']:>10,.2f}\n"
            
            content += f"""
-------------------------------------
RESUMEN FINANCIERO
-------------------------------------
Subtotal:           RD$ {sum(s['total'] for s in self.selected_services):>10,.2f}
Descuento:          RD$ {float(self.discount_var.get() or 0):>10,.2f}
TOTAL A PAGAR:      RD$ {total:>10,.2f}

Monto Recibido:     RD$ {payment:>10,.2f}
"""
            
            if payment >= total:
                content += f"Cambio:             RD$ {payment - total:>10,.2f}\n"
            else:
                content += f"Faltante:           RD$ {total - payment:>10,.2f}\n"
            
            content += f"""
=====================================
Gracias por confiar en nuestros servicios
Generado: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}
=====================================
"""
            
            # Guardar como archivo de texto (mejor compatibilidad)
            txt_filepath = filepath.replace('.pdf', '.txt')
            with open(txt_filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            
            # Intentar abrir el archivo
            if os.name == 'nt':  # Windows
                os.startfile(txt_filepath)
            else:  # Unix/Linux/Mac
                subprocess.call(['open', txt_filepath])
                
        except Exception as e:
            print(f"Error generando archivo: {str(e)}")
    
    def save_invoice_integrated(self):
        """Guardar factura en la base de datos"""
        if not self.current_appointment_billing:
            messagebox.showwarning("Cita", "Por favor seleccione una cita primero")
            return
        
        if not self.selected_services:
            messagebox.showwarning("Servicios", "Por favor agregue al menos un servicio")
            return
        
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Generar n√∫mero de factura
            invoice_number = f"FAC-{datetime.now().strftime('%Y-%m')}-{datetime.now().strftime('%d%H%M%S')}"
            
            # Calcular totales
            subtotal = sum(service['total'] for service in self.selected_services)
            discount = float(self.discount_var.get() or 0)
            total = subtotal - discount
            payment = float(self.payment_var.get() or 0)
            
            # Insertar factura
            cursor.execute("""
                INSERT INTO facturas (numero_factura, cita_id, fecha_creacion, monto, estado, concepto)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (
                invoice_number,
                self.current_appointment_billing['id'],
                datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                total,
                'pagada' if payment >= total else 'pendiente',
                'Servicios m√©dicos'
            ))
            
            conn.commit()
            cursor.close()
            conn.close()
            
            messagebox.showinfo("Guardado", f"Factura {invoice_number} guardada exitosamente")
            
            # Limpiar formulario
            self.clear_invoice_form()
            
            # Recargar datos
            self.load_appointments_for_billing()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error guardando factura: {str(e)}")
    
    def clear_invoice_form(self):
        """Limpiar formulario de factura"""
        self.selected_services = []
        self.current_appointment_billing = None
        
        self.subtotal_var.set("0.00")
        self.discount_var.set("0.00")
        self.total_var.set("0.00")
        self.payment_var.set("0.00")
        self.change_var.set("0.00")
        
        if hasattr(self, 'patient_info_label'):
            self.patient_info_label.config(text="Seleccione una cita para continuar")
        
        self.update_invoice_services_display()
    
    def update_status(self, message):
        """Actualizar barra de estado"""
        if hasattr(self, 'status_label'):
            self.status_label.config(text=message)
    
    # ==================== FUNCIONES DE GESTI√ìN DE SERVICIOS ====================
    
    def load_services_management(self):
        """Cargar servicios en la pesta√±a de gesti√≥n"""
        if not hasattr(self, 'services_management_tree'):
            return
            
        # Limpiar tabla
        for item in self.services_management_tree.get_children():
            self.services_management_tree.delete(item)
        
        # Cargar servicios
        for service in self.medical_services:
            self.services_management_tree.insert('', 'end', values=(
                service['codigo'],
                service['nombre'],
                service['categoria'],
                f"RD$ {service['precio']:,.2f}"
            ))
    
    def add_new_service(self):
        """Agregar nuevo servicio m√©dico"""
        # Crear ventana de di√°logo
        dialog = tk.Toplevel(self.root)
        dialog.title("Nuevo Servicio M√©dico")
        dialog.geometry("400x300")
        dialog.configure(bg='#F8FAFC')
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Centrar ventana
        dialog.geometry("+%d+%d" % (self.root.winfo_rootx() + 50, self.root.winfo_rooty() + 50))
        
        # Campos del formulario
        fields_frame = tk.Frame(dialog, bg='#F8FAFC')
        fields_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # C√≥digo
        tk.Label(fields_frame, text="C√≥digo:", bg='#F8FAFC', font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky='w', pady=5)
        codigo_var = tk.StringVar()
        tk.Entry(fields_frame, textvariable=codigo_var, width=30).grid(row=0, column=1, pady=5, padx=(10, 0))
        
        # Nombre
        tk.Label(fields_frame, text="Nombre:", bg='#F8FAFC', font=('Arial', 10, 'bold')).grid(row=1, column=0, sticky='w', pady=5)
        nombre_var = tk.StringVar()
        tk.Entry(fields_frame, textvariable=nombre_var, width=30).grid(row=1, column=1, pady=5, padx=(10, 0))
        
        # Categor√≠a
        tk.Label(fields_frame, text="Categor√≠a:", bg='#F8FAFC', font=('Arial', 10, 'bold')).grid(row=2, column=0, sticky='w', pady=5)
        categoria_var = tk.StringVar()
        categoria_combo = ttk.Combobox(fields_frame, textvariable=categoria_var, width=27,
                                      values=['Consulta', 'Laboratorio', 'Imagen', 'Procedimiento', 'Cardiolog√≠a', 'Prevenci√≥n'])
        categoria_combo.grid(row=2, column=1, pady=5, padx=(10, 0))
        
        # Precio
        tk.Label(fields_frame, text="Precio (RD$):", bg='#F8FAFC', font=('Arial', 10, 'bold')).grid(row=3, column=0, sticky='w', pady=5)
        precio_var = tk.StringVar()
        tk.Entry(fields_frame, textvariable=precio_var, width=30).grid(row=3, column=1, pady=5, padx=(10, 0))
        
        # Botones
        buttons_frame = tk.Frame(dialog, bg='#F8FAFC')
        buttons_frame.pack(fill='x', padx=20, pady=(0, 20))
        
        def save_service():
            try:
                codigo = codigo_var.get().strip()
                nombre = nombre_var.get().strip()
                categoria = categoria_var.get().strip()
                precio = float(precio_var.get().strip())
                
                if not all([codigo, nombre, categoria]) or precio <= 0:
                    messagebox.showerror("Error", "Todos los campos son obligatorios y el precio debe ser mayor a 0")
                    return
                
                # Verificar que el c√≥digo no exista
                for service in self.medical_services:
                    if service['codigo'] == codigo:
                        messagebox.showerror("Error", "Ya existe un servicio con ese c√≥digo")
                        return
                
                # Agregar servicio
                new_service = {
                    'codigo': codigo,
                    'nombre': nombre,
                    'categoria': categoria,
                    'precio': precio
                }
                
                self.medical_services.append(new_service)
                self.load_services_management()
                self.load_services_for_billing()
                
                messagebox.showinfo("√âxito", "Servicio agregado correctamente")
                dialog.destroy()
                
            except ValueError:
                messagebox.showerror("Error", "El precio debe ser un n√∫mero v√°lido")
            except Exception as e:
                messagebox.showerror("Error", f"Error guardando servicio: {str(e)}")
        
        tk.Button(buttons_frame, text="üíæ Guardar", command=save_service,
                 bg='#4caf50', fg='white', font=('Arial', 10, 'bold')).pack(side='left', padx=(0, 10))
        tk.Button(buttons_frame, text="‚ùå Cancelar", command=dialog.destroy,
                 bg='#f44336', fg='white', font=('Arial', 10, 'bold')).pack(side='left')
    
    def edit_selected_service(self):
        """Editar servicio seleccionado"""
        if not hasattr(self, 'services_management_tree'):
            return
            
        selection = self.services_management_tree.selection()
        if not selection:
            messagebox.showwarning("Selecci√≥n", "Por favor seleccione un servicio para editar")
            return
        
        # Obtener servicio seleccionado
        item = self.services_management_tree.item(selection[0])
        service_data = item['values']
        codigo_selected = service_data[0]
        
        # Buscar servicio en la lista
        service_to_edit = None
        service_index = -1
        for i, service in enumerate(self.medical_services):
            if service['codigo'] == codigo_selected:
                service_to_edit = service
                service_index = i
                break
        
        if not service_to_edit:
            return
        
        # Crear ventana de edici√≥n (similar a la de agregar)
        dialog = tk.Toplevel(self.root)
        dialog.title("Editar Servicio M√©dico")
        dialog.geometry("400x300")
        dialog.configure(bg='#F8FAFC')
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Centrar ventana
        dialog.geometry("+%d+%d" % (self.root.winfo_rootx() + 50, self.root.winfo_rooty() + 50))
        
        # Campos del formulario con valores actuales
        fields_frame = tk.Frame(dialog, bg='#F8FAFC')
        fields_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # C√≥digo (readonly)
        tk.Label(fields_frame, text="C√≥digo:", bg='#F8FAFC', font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky='w', pady=5)
        codigo_var = tk.StringVar(value=service_to_edit['codigo'])
        codigo_entry = tk.Entry(fields_frame, textvariable=codigo_var, width=30, state='readonly')
        codigo_entry.grid(row=0, column=1, pady=5, padx=(10, 0))
        
        # Nombre
        tk.Label(fields_frame, text="Nombre:", bg='#F8FAFC', font=('Arial', 10, 'bold')).grid(row=1, column=0, sticky='w', pady=5)
        nombre_var = tk.StringVar(value=service_to_edit['nombre'])
        tk.Entry(fields_frame, textvariable=nombre_var, width=30).grid(row=1, column=1, pady=5, padx=(10, 0))
        
        # Categor√≠a
        tk.Label(fields_frame, text="Categor√≠a:", bg='#F8FAFC', font=('Arial', 10, 'bold')).grid(row=2, column=0, sticky='w', pady=5)
        categoria_var = tk.StringVar(value=service_to_edit['categoria'])
        categoria_combo = ttk.Combobox(fields_frame, textvariable=categoria_var, width=27,
                                      values=['Consulta', 'Laboratorio', 'Imagen', 'Procedimiento', 'Cardiolog√≠a', 'Prevenci√≥n'])
        categoria_combo.grid(row=2, column=1, pady=5, padx=(10, 0))
        
        # Precio
        tk.Label(fields_frame, text="Precio (RD$):", bg='#F8FAFC', font=('Arial', 10, 'bold')).grid(row=3, column=0, sticky='w', pady=5)
        precio_var = tk.StringVar(value=str(service_to_edit['precio']))
        tk.Entry(fields_frame, textvariable=precio_var, width=30).grid(row=3, column=1, pady=5, padx=(10, 0))
        
        # Botones
        buttons_frame = tk.Frame(dialog, bg='#F8FAFC')
        buttons_frame.pack(fill='x', padx=20, pady=(0, 20))
        
        def update_service():
            try:
                nombre = nombre_var.get().strip()
                categoria = categoria_var.get().strip()
                precio = float(precio_var.get().strip())
                
                if not all([nombre, categoria]) or precio <= 0:
                    messagebox.showerror("Error", "Todos los campos son obligatorios y el precio debe ser mayor a 0")
                    return
                
                # Actualizar servicio
                self.medical_services[service_index] = {
                    'codigo': service_to_edit['codigo'],
                    'nombre': nombre,
                    'categoria': categoria,
                    'precio': precio
                }
                
                self.load_services_management()
                self.load_services_for_billing()
                
                messagebox.showinfo("√âxito", "Servicio actualizado correctamente")
                dialog.destroy()
                
            except ValueError:
                messagebox.showerror("Error", "El precio debe ser un n√∫mero v√°lido")
            except Exception as e:
                messagebox.showerror("Error", f"Error actualizando servicio: {str(e)}")
        
        tk.Button(buttons_frame, text="üíæ Actualizar", command=update_service,
                 bg='#ff9800', fg='white', font=('Arial', 10, 'bold')).pack(side='left', padx=(0, 10))
        tk.Button(buttons_frame, text="‚ùå Cancelar", command=dialog.destroy,
                 bg='#f44336', fg='white', font=('Arial', 10, 'bold')).pack(side='left')
    
    def delete_selected_service(self):
        """Eliminar servicio seleccionado"""
        if not hasattr(self, 'services_management_tree'):
            return
            
        selection = self.services_management_tree.selection()
        if not selection:
            messagebox.showwarning("Selecci√≥n", "Por favor seleccione un servicio para eliminar")
            return
        
        # Obtener servicio seleccionado
        item = self.services_management_tree.item(selection[0])
        service_data = item['values']
        codigo_selected = service_data[0]
        nombre_selected = service_data[1]
        
        # Confirmar eliminaci√≥n
        if messagebox.askyesno("Confirmar Eliminaci√≥n", 
                              f"¬øEst√° seguro de eliminar el servicio:\n'{nombre_selected}'?"):
            try:
                # Buscar y eliminar servicio
                for i, service in enumerate(self.medical_services):
                    if service['codigo'] == codigo_selected:
                        del self.medical_services[i]
                        break
                
                self.load_services_management()
                self.load_services_for_billing()
                
                messagebox.showinfo("√âxito", "Servicio eliminado correctamente")
                
            except Exception as e:
                messagebox.showerror("Error", f"Error eliminando servicio: {str(e)}")
    
    # ==================== FUNCIONES DE REPORTES ====================
    
    def get_billing_statistics_integrated(self):
        """Obtener estad√≠sticas de facturaci√≥n"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            today = datetime.now().strftime('%Y-%m-%d')
            this_month = datetime.now().strftime('%Y-%m')
            
            stats = {}
            
            # Ingresos de hoy
            cursor.execute("SELECT COALESCE(SUM(monto), 0) FROM facturas WHERE DATE(fecha_creacion) = ?", (today,))
            stats['ingresos_hoy'] = cursor.fetchone()[0]
            
            # Facturas de hoy
            cursor.execute("SELECT COUNT(*) FROM facturas WHERE DATE(fecha_creacion) = ?", (today,))
            stats['facturas_hoy'] = cursor.fetchone()[0]
            
            # Facturas pendientes
            cursor.execute("SELECT COUNT(*) FROM facturas WHERE estado = 'pendiente'")
            stats['pendientes'] = cursor.fetchone()[0]
            
            # Ingresos del mes
            cursor.execute("SELECT COALESCE(SUM(monto), 0) FROM facturas WHERE strftime('%Y-%m', fecha_creacion) = ?", (this_month,))
            stats['ingresos_mes'] = cursor.fetchone()[0]
            
            cursor.close()
            conn.close()
            
            return stats
            
        except Exception as e:
            print(f"Error obteniendo estad√≠sticas: {str(e)}")
            return {'ingresos_hoy': 0, 'facturas_hoy': 0, 'pendientes': 0, 'ingresos_mes': 0}
    
    def generate_daily_report_integrated(self):
        """Generar reporte diario"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            today = datetime.now().strftime('%Y-%m-%d')
            
            cursor.execute("""
                SELECT f.numero_factura, f.fecha_creacion, 
                       p.nombre || ' ' || p.apellido as paciente,
                       d.nombre || ' ' || d.apellido as doctor,
                       f.monto, f.estado
                FROM facturas f
                JOIN citas c ON f.cita_id = c.id
                JOIN usuarios p ON c.paciente_id = p.id
                JOIN usuarios d ON c.doctor_id = d.id
                WHERE DATE(f.fecha_creacion) = ?
                ORDER BY f.fecha_creacion DESC
            """, (today,))
            
            facturas = cursor.fetchall()
            
            # Generar reporte
            report_content = f"""
REPORTE DIARIO DE FACTURACI√ìN
Fecha: {datetime.now().strftime('%d/%m/%Y')}
====================================

RESUMEN:
- Total de facturas: {len(facturas)}
- Ingresos del d√≠a: RD$ {sum(f[4] for f in facturas):,.2f}

DETALLE DE FACTURAS:
"""
            
            for factura in facturas:
                report_content += f"""
Factura: {factura[0]}
Fecha: {factura[1]}
Paciente: {factura[2]}
Doctor: {factura[3]}
Monto: RD$ {factura[4]:,.2f}
Estado: {factura[5]}
-----------------------------------
"""
            
            # Guardar reporte
            reports_dir = "reportes_facturacion"
            if not os.path.exists(reports_dir):
                os.makedirs(reports_dir)
            
            filename = f"reporte_diario_{datetime.now().strftime('%Y%m%d')}.txt"
            filepath = os.path.join(reports_dir, filename)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            messagebox.showinfo("Reporte Generado", f"Reporte guardado como: {filename}")
            
            # Abrir archivo
            if os.name == 'nt':  # Windows
                os.startfile(filepath)
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error generando reporte: {str(e)}")
    
    def generate_monthly_report_integrated(self):
        """Generar reporte mensual"""
        messagebox.showinfo("Reporte Mensual", "Funci√≥n de reporte mensual en desarrollo")
    
    def generate_pending_report_integrated(self):
        """Generar reporte de facturas pendientes"""
        messagebox.showinfo("Facturas Pendientes", "Funci√≥n de reporte de pendientes en desarrollo")
    
    def generate_services_report_integrated(self):
        """Generar reporte de ingresos por servicio"""
        messagebox.showinfo("Ingresos por Servicio", "Funci√≥n de reporte por servicios en desarrollo")
        
    def create_billing_main_tab(self, parent):
        """Crear pesta√±a principal de facturaci√≥n"""
        pass
    
    def create_billing_stats_panel(self, parent):
        """Crear panel de estad√≠sticas de facturaci√≥n"""
        # Panel de estad√≠sticas
        stats_frame = tk.LabelFrame(
            parent,
            text="üìà ESTAD√çSTICAS HOY",
            font=('Arial', 11, 'bold'),
            bg='#e3f2fd',
            fg='#1565c0',
            padx=15,
            pady=15
        )
        stats_frame.pack(fill='x', pady=(0, 15))
        
        # Variables de estad√≠sticas
        self.stats_vars = {
            'facturas_hoy': tk.StringVar(value="0"),
            'ingresos_hoy': tk.StringVar(value="RD$ 0.00"),
            'pendientes': tk.StringVar(value="0"),
            'citas_sin_facturar': tk.StringVar(value="0")
        }
        
        # Crear indicadores
        stats_data = [
            ("üí∞ Facturas Hoy:", self.stats_vars['facturas_hoy'], '#16A085'),
            ("üíµ Ingresos Hoy:", self.stats_vars['ingresos_hoy'], '#059669'),
            ("‚è≥ Pendientes:", self.stats_vars['pendientes'], '#C0392B'),
            ("üìÖ Sin Facturar:", self.stats_vars['citas_sin_facturar'], '#E67E22')
        ]
        
        for label, var, color in stats_data:
            stat_row = tk.Frame(stats_frame, bg='#e3f2fd')
            stat_row.pack(fill='x', pady=8)
            
            tk.Label(stat_row, text=label, font=('Arial', 10, 'bold'),
                    bg='#e3f2fd', fg='#1565c0').pack(side='left')
            tk.Label(stat_row, textvariable=var, font=('Arial', 11, 'bold'),
                    bg='#e3f2fd', fg=color).pack(side='right')
        
        # Panel de acciones r√°pidas
        actions_frame = tk.LabelFrame(
            parent,
            text="‚ö° ACCIONES R√ÅPIDAS",
            font=('Arial', 11, 'bold'),
            bg='#fff3e0',
            fg='#e65100',
            padx=15,
            pady=15
        )
        actions_frame.pack(fill='x', pady=(0, 15))
        
        # Botones de acciones
        actions = [
            ("üíµ Nueva Factura R√°pida", self.quick_invoice, '#16A085'),
            ("üìÑ Generar Reporte PDF", self.generate_billing_report, '#0B5394'),
            ("üîç Buscar Factura", self.search_invoice, '#16A085'),
            ("üîÑ Actualizar Datos", self.refresh_billing_data, '#64748B')
        ]
        
        for text, command, color in actions:
            btn = tk.Button(
                actions_frame,
                text=text,
                command=command,
                bg=color,
                fg='white',
                font=('Arial', 9, 'bold'),
                padx=10,
                pady=8,
                relief='raised'
            )
            btn.pack(fill='x', pady=5)
        
        # Panel de citas sin facturar
        pending_frame = tk.LabelFrame(
            parent,
            text="üìã CITAS SIN FACTURAR",
            font=('Arial', 11, 'bold'),
            bg='#ffebee',
            fg='#c62828',
            padx=15,
            pady=15
        )
        pending_frame.pack(fill='both', expand=True)
        
        # Lista de citas pendientes
        self.pending_appointments_list = tk.Listbox(
            pending_frame,
            height=6,
            font=('Arial', 9),
            bg='white',
            selectmode='single'
        )
        self.pending_appointments_list.pack(fill='both', expand=True, pady=(10, 10))
        
        # Bot√≥n para facturar cita seleccionada
        bill_selected_btn = tk.Button(
            pending_frame,
            text="üí∞ Facturar Seleccionada",
            command=self.bill_selected_appointment,
            bg='#0B5394',
            fg='white',
            font=('Arial', 10, 'bold'),
            padx=15,
            pady=8
        )
        bill_selected_btn.pack(fill='x')
    
    # ==================== FUNCIONES AUXILIARES DE FACTURACI√ìN ====================
        """Instalar dependencias necesarias para PDFs autom√°ticamente"""
        try:
            import reportlab
            import qrcode
            from PIL import Image
            print("‚úÖ Dependencias para PDF disponibles")
            return True
        except ImportError:
            print("üì¶ Instalando dependencias para PDFs...")
            try:
                import subprocess
                import sys
                subprocess.check_call([sys.executable, "-m", "pip", "install", "reportlab", "qrcode[pil]", "pillow"])
                print("‚úÖ Dependencias instaladas exitosamente")
                messagebox.showinfo("Sistema de Facturaci√≥n", "Dependencias para PDFs instaladas exitosamente.\nSistema completo listo para usar.")
                return True
            except:
                print("‚ö†Ô∏è No se pudieron instalar dependencias - Usando modo b√°sico")
                messagebox.showwarning("Advertencia", "No se pudieron instalar las dependencias para PDFs.\nAlgunas funciones avanzadas pueden no estar disponibles.")
                return False
    
    def create_complete_billing_interface(self, parent):
        """Crear interfaz completa del sistema de facturaci√≥n"""
        # Header moderno
        header_frame = tk.Frame(parent, bg='#1E3A8A', height=80)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # T√≠tulo y logo
        title_frame = tk.Frame(header_frame, bg='#1E3A8A')
        title_frame.pack(expand=True, fill='both')
        
        tk.Label(title_frame, text="üßæ", font=('Arial', 24), bg='#1E3A8A', fg='white').pack(side='left', padx=(20, 10), pady=10)
        tk.Label(title_frame, text="SISTEMA DE FACTURACI√ìN COMPLETO", font=('Arial', 18, 'bold'), 
                bg='#1E3A8A', fg='white').pack(side='left', pady=10)
        
        # Botones de acci√≥n r√°pida
        actions_frame = tk.Frame(title_frame, bg='#1E3A8A')
        actions_frame.pack(side='right', padx=20, pady=10)
        
        # Crear notebook con pesta√±as
        notebook = ttk.Notebook(parent)
        notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Pesta√±a 1: Facturaci√≥n
        billing_frame = tk.Frame(notebook, bg='#F8FAFC')
        notebook.add(billing_frame, text='üßæ Facturaci√≥n')
        
        # Pesta√±a 2: Pagos
        payments_frame = tk.Frame(notebook, bg='#F8FAFC')
        notebook.add(payments_frame, text='üí≥ Procesar Pagos')
        
        # Pesta√±a 3: Reportes
        reports_frame = tk.Frame(notebook, bg='#F8FAFC')
        notebook.add(reports_frame, text='üìä Reportes')
        
        # Pesta√±a 4: Configuraci√≥n
        config_frame = tk.Frame(notebook, bg='#F8FAFC')
        notebook.add(config_frame, text='‚öôÔ∏è Configuraci√≥n')
        
        # Crear contenido de cada pesta√±a
        self.create_advanced_billing_tab(billing_frame)
        self.create_payments_tab(payments_frame)
        self.create_reports_tab(reports_frame)
        self.create_billing_config_tab(config_frame)
    
    def create_advanced_billing_tab(self, parent):
        """Crear pesta√±a avanzada de facturaci√≥n"""
        # Panel izquierdo - Citas pendientes
        left_panel = tk.Frame(parent, bg='white', relief='solid', bd=1)
        left_panel.pack(side='left', fill='both', expand=True, padx=(0, 5), pady=10)
        
        # Header del panel izquierdo
        left_header = tk.Frame(left_panel, bg='#0B5394', height=50)
        left_header.pack(fill='x')
        left_header.pack_propagate(False)
        
        tk.Label(left_header, text="üìÖ Citas para Facturar", font=('Arial', 14, 'bold'), 
                bg='#0B5394', fg='white').pack(side='left', padx=15, expand=True, anchor='w')
        
        # Bot√≥n refrescar
        tk.Button(left_header, text="üîÑ", bg='#0B5394', fg='white',
                 font=('Arial', 12, 'bold'), relief='flat',
                 command=self.load_pending_appointments).pack(side='right', padx=15, pady=10)
        
        # Lista de citas con mejor scrollbar
        appointments_frame = tk.Frame(left_panel, bg='white', relief='solid', bd=1)
        appointments_frame.pack(fill='both', expand=True, padx=15, pady=15)
        
        # Treeview para citas con altura reducida para mejor distribuci√≥n
        columns = ('ID', 'Fecha', 'Paciente', 'Doctor', 'Motivo', 'Estado')
        self.billing_appointments_tree = ttk.Treeview(appointments_frame, columns=columns, show='headings', height=8)
        
        # Configurar columnas
        column_widths = {'ID': 50, 'Fecha': 100, 'Paciente': 150, 'Doctor': 120, 'Motivo': 200, 'Estado': 80}
        for col in columns:
            self.billing_appointments_tree.heading(col, text=col)
            self.billing_appointments_tree.column(col, width=column_widths.get(col, 100))
        
        # Scrollbars con mejor visibilidad
        scrollbar_y = ttk.Scrollbar(appointments_frame, orient="vertical", command=self.billing_appointments_tree.yview)
        scrollbar_x = ttk.Scrollbar(appointments_frame, orient="horizontal", command=self.billing_appointments_tree.xview)
        self.billing_appointments_tree.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        
        # Layout con grid para mejor control de scrollbars con padding
        self.billing_appointments_tree.grid(row=0, column=0, sticky='nsew', padx=(5, 0), pady=(5, 0))
        scrollbar_y.grid(row=0, column=1, sticky='ns', padx=(0, 5), pady=(5, 0))
        scrollbar_x.grid(row=1, column=0, sticky='ew', padx=(5, 0), pady=(0, 5))
        
        # Configurar expansi√≥n con m√≠nimo para scrollbars
        appointments_frame.grid_rowconfigure(0, weight=1)
        appointments_frame.grid_rowconfigure(1, weight=0, minsize=20)
        appointments_frame.grid_columnconfigure(0, weight=1)
        appointments_frame.grid_columnconfigure(1, weight=0, minsize=20)
        
        # Bind para selecci√≥n
        self.billing_appointments_tree.bind('<<TreeviewSelect>>', self.on_appointment_select_billing)
        
        # Agregar scroll con mouse wheel mejorado
        def scroll_appointments(event):
            self.billing_appointments_tree.yview_scroll(int(-1 * (event.delta / 120)), "units")
        self.billing_appointments_tree.bind("<MouseWheel>", scroll_appointments)
        
        # Bind adicional para mejor control del scroll
        def on_appointments_focus_in(event):
            self.billing_appointments_tree.focus_set()
        self.billing_appointments_tree.bind("<Button-1>", on_appointments_focus_in)
        
        # Separador entre citas y facturas
        separator_frame = tk.Frame(left_panel, bg='white', height=20)
        separator_frame.pack(fill='x', padx=15)
        
        # Nueva secci√≥n: Facturas existentes
        invoices_header = tk.Frame(left_panel, bg='#0B5394', height=50)
        invoices_header.pack(fill='x')
        invoices_header.pack_propagate(False)
        
        tk.Label(invoices_header, text="üìÑ Facturas Generadas", font=('Arial', 14, 'bold'), 
                bg='#0B5394', fg='white').pack(side='left', padx=15, expand=True, anchor='w')
        
        # Bot√≥n refrescar facturas
        tk.Button(invoices_header, text="üîÑ", bg='#0B5394', fg='white',
                 font=('Arial', 12, 'bold'), relief='flat',
                 command=self.load_existing_invoices).pack(side='right', padx=15, pady=10)
        
        # Lista de facturas existentes con mejor scrollbar
        invoices_frame = tk.Frame(left_panel, bg='white', relief='solid', bd=1)
        invoices_frame.pack(fill='both', expand=True, padx=15, pady=15)
        
        # Treeview para facturas con altura optimizada
        invoice_columns = ('N√∫mero', 'Fecha', 'Paciente', 'Monto', 'Estado', 'Acciones')
        self.billing_invoices_tree = ttk.Treeview(invoices_frame, columns=invoice_columns, show='headings', height=12)
        
        # Configurar columnas de facturas
        invoice_column_widths = {'N√∫mero': 120, 'Fecha': 90, 'Paciente': 150, 'Monto': 100, 'Estado': 100, 'Acciones': 80}
        for col in invoice_columns:
            self.billing_invoices_tree.heading(col, text=col)
            self.billing_invoices_tree.column(col, width=invoice_column_widths.get(col, 100))
        
        # Scrollbars para facturas con mejor estilo y visibilidad
        invoices_scrollbar_y = ttk.Scrollbar(invoices_frame, orient="vertical", command=self.billing_invoices_tree.yview)
        invoices_scrollbar_x = ttk.Scrollbar(invoices_frame, orient="horizontal", command=self.billing_invoices_tree.xview)
        self.billing_invoices_tree.configure(yscrollcommand=invoices_scrollbar_y.set, xscrollcommand=invoices_scrollbar_x.set)
        
        # Layout con grid para mejor control de scrollbars con padding
        self.billing_invoices_tree.grid(row=0, column=0, sticky='nsew', padx=(5, 0), pady=(5, 0))
        invoices_scrollbar_y.grid(row=0, column=1, sticky='ns', padx=(0, 5), pady=(5, 0))
        invoices_scrollbar_x.grid(row=1, column=0, sticky='ew', padx=(5, 0), pady=(0, 5))
        
        # Configurar expansi√≥n con m√≠nimo para scrollbars
        invoices_frame.grid_rowconfigure(0, weight=1)
        invoices_frame.grid_rowconfigure(1, weight=0, minsize=20)
        invoices_frame.grid_columnconfigure(0, weight=1)
        invoices_frame.grid_columnconfigure(1, weight=0, minsize=20)
        
        # Bind para selecci√≥n de facturas
        self.billing_invoices_tree.bind('<Double-1>', self.view_invoice_details_billing)
        
        # Agregar scroll con mouse wheel mejorado
        def scroll_invoices(event):
            self.billing_invoices_tree.yview_scroll(int(-1 * (event.delta / 120)), "units")
        self.billing_invoices_tree.bind("<MouseWheel>", scroll_invoices)
        
        # Bind adicional para mejor control del scroll
        def on_invoices_focus_in(event):
            self.billing_invoices_tree.focus_set()
        self.billing_invoices_tree.bind("<Button-1>", on_invoices_focus_in)
        
        # Botones de acci√≥n para facturas
        invoice_actions_frame = tk.Frame(left_panel, bg='white')
        invoice_actions_frame.pack(fill='x', padx=15, pady=(10, 15))
        
        tk.Button(invoice_actions_frame, text="üí≥ Procesar Pago", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), command=self.process_payment_window).pack(side='left', padx=(0, 10))
        tk.Button(invoice_actions_frame, text="üëÅÔ∏è Ver Detalles", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), command=self.view_invoice_details_billing).pack(side='left', padx=10)
        tk.Button(invoice_actions_frame, text="üìÑ Reimprimir PDF", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), command=self.reprint_invoice_pdf).pack(side='left', padx=10)
        
        # Bot√≥n de debug temporal
        def debug_table():
            print(f"üîç DEBUG: Verificando tabla de facturas...")
            print(f"Widget existe: {hasattr(self, 'billing_invoices_tree')}")
            if hasattr(self, 'billing_invoices_tree'):
                children = self.billing_invoices_tree.get_children()
                print(f"Items en tabla: {len(children)}")
                for i, child in enumerate(children[:3]):  # Solo los primeros 3
                    values = self.billing_invoices_tree.item(child)['values']
                    print(f"Item {i}: {values}")
                
                # Agregar item de prueba
                test_item = self.billing_invoices_tree.insert('', 'end', values=(
                    "TEST-001", "28/07/2025", "Paciente Prueba", "RD$ 1,000.00", "üß™ TEST", "üîß"
                ))
                print(f"Item de prueba agregado: {test_item}")
                self.billing_invoices_tree.update()
                
        tk.Button(invoice_actions_frame, text="üîç DEBUG", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), command=debug_table).pack(side='right', padx=10)
        
        # Panel derecho - Crear factura (m√°s ancho)
        right_panel = tk.Frame(parent, bg='white', relief='solid', bd=1, width=650)
        right_panel.pack(side='right', fill='y', padx=(5, 0), pady=10)
        right_panel.pack_propagate(False)
        
        # Header del panel derecho
        right_header = tk.Frame(right_panel, bg='#0B5394', height=50)
        right_header.pack(fill='x')
        right_header.pack_propagate(False)
        
        tk.Label(right_header, text="üßæ Crear Factura", font=('Arial', 14, 'bold'), 
                bg='#0B5394', fg='white').pack(expand=True)
        
        # Formulario de factura
        self.create_invoice_form(right_panel)
        
        # Cargar datos iniciales despu√©s de que la interfaz est√© lista
        self.root.after(100, self.load_pending_appointments)
        self.root.after(200, self.load_existing_invoices)
    
    def load_existing_invoices(self):
        """Cargar facturas existentes (pagadas y pendientes)"""
        try:
            print("üîÑ Iniciando carga de facturas existentes...")
            
            # Verificar que el widget existe
            if not hasattr(self, 'billing_invoices_tree'):
                print("‚ùå ERROR: billing_invoices_tree no existe")
                return
            
            print(f"‚úÖ Widget billing_invoices_tree existe: {self.billing_invoices_tree}")
            
            # Limpiar tabla de facturas
            for item in self.billing_invoices_tree.get_children():
                self.billing_invoices_tree.delete(item)
                
            print("üßπ Tabla limpiada")
            
            # Obtener facturas
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            print(f"üìä Consultando facturas en base de datos...")
            
            cursor.execute("""
                SELECT f.id, f.numero_factura, f.fecha_creacion, 
                       p.nombre || ' ' || p.apellido as paciente,
                       f.monto, f.estado,
                       f.metodo_pago, f.fecha_pago
                FROM facturas f
                JOIN usuarios p ON f.paciente_id = p.id
                ORDER BY f.fecha_creacion DESC
                LIMIT 50
            """)
            
            invoices = cursor.fetchall()
            print(f"‚úÖ Se encontraron {len(invoices)} facturas en la base de datos")
            
            # Contador para verificar inserciones
            inserted_count = 0
            
            for invoice in invoices:
                try:
                    invoice_id, numero, fecha, paciente, monto, estado, metodo_pago, fecha_pago = invoice
                    
                    # Formatear fecha
                    try:
                        fecha_obj = datetime.fromisoformat(fecha)
                        fecha_formatted = fecha_obj.strftime('%d/%m/%Y')
                    except:
                        fecha_formatted = fecha
                    
                    # Formatear monto
                    monto_formatted = f"RD$ {float(monto):,.2f}"
                    
                    # Determinar estado y color
                    if estado in ['pagada', 'pagado']:
                        estado_display = "‚úÖ Pagada"
                    elif estado == 'pendiente':
                        estado_display = "‚è≥ Pendiente"
                    elif estado == 'pago_parcial':
                        estado_display = "üîµ Parcial"
                    elif estado == 'vencido':
                        estado_display = "üî¥ Vencida"
                    elif estado == 'cancelado':
                        estado_display = "‚ùå Cancelada"
                    else:
                        estado_display = f"üîß {estado}"
                    
                    # Insertar en la tabla
                    item_id = self.billing_invoices_tree.insert('', 'end', values=(
                        numero, fecha_formatted, paciente, monto_formatted, estado_display, "üîß"
                    ))
                    
                    # Verificar que se insert√≥
                    if item_id:
                        inserted_count += 1
                        print(f"‚ûï Insertada factura #{inserted_count}: {numero} - {paciente} - {estado_display}")
                    else:
                        print(f"‚ùå Error insertando factura: {numero}")
                    
                    # Guardar ID de factura como tag (si es necesario)
                    try:
                        self.billing_invoices_tree.set(item_id, '#1', invoice_id)
                    except:
                        pass
                        
                except Exception as insert_error:
                    print(f"‚ùå Error procesando factura {invoice}: {insert_error}")
                    continue
            
            cursor.close()
            conn.close()
            
            # Verificar cu√°ntos items tiene la tabla despu√©s de la carga
            children_count = len(self.billing_invoices_tree.get_children())
            print(f"üìä Items en la tabla despu√©s de carga: {children_count}")
            
            # Forzar actualizaci√≥n visual
            self.billing_invoices_tree.update()
            self.billing_invoices_tree.update_idletasks()
            
            print(f"‚úÖ Carga completada: {inserted_count} facturas insertadas correctamente")
            
            if inserted_count == 0:
                print("‚ö†Ô∏è ADVERTENCIA: No se insertaron facturas en la tabla")
            
        except Exception as e:
            error_msg = f"Error cargando facturas: {str(e)}"
            print(f"‚ùå {error_msg}")
            print(f"Error completo: {e}")
            import traceback
            traceback.print_exc()
            messagebox.showerror("Error", error_msg)
    
    def create_invoice_form(self, parent):
        """Crear formulario para crear facturas"""
        # Crear un canvas con scrollbar para el formulario completo
        canvas = tk.Canvas(parent, bg='white', highlightthickness=0)
        scrollbar_form = ttk.Scrollbar(parent, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='white')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar_form.set)
        
        # Pack canvas y scrollbar
        canvas.pack(side="left", fill="both", expand=True, padx=15, pady=15)
        scrollbar_form.pack(side="right", fill="y", pady=15)
        
        # Configurar el ancho del frame scrollable para que coincida con el canvas
        def configure_scroll_region(event):
            canvas.configure(scrollregion=canvas.bbox("all"))
            canvas.configure(width=event.width)
        
        canvas.bind('<Configure>', configure_scroll_region)
        
        # El form_frame ahora ser√° el scrollable_frame
        form_frame = scrollable_frame
        
        # Informaci√≥n de la cita seleccionada
        info_frame = tk.LabelFrame(form_frame, text="üìã Informaci√≥n de la Cita", 
                                  font=('Arial', 11, 'bold'), padx=10, pady=10)
        info_frame.pack(fill='x', pady=(0, 15))
        
        self.selected_appointment_info = tk.Label(info_frame, text="Seleccione una cita para facturar", 
                                                 font=('Arial', 10), bg='white', fg='#64748B', 
                                                 wraplength=400, justify='left')
        self.selected_appointment_info.pack(anchor='w')
        
        # Panel de informaci√≥n del doctor y seguro
        # Panel de informaci√≥n de cita - Redise√±ado con tarjetas modernas
        appointment_info_card = tk.Frame(form_frame, bg='white', relief='solid', bd=2)
        appointment_info_card.pack(fill='x', pady=(0, 20))
        
        # Header de la tarjeta
        info_header = tk.Frame(appointment_info_card, bg='#3B82F6', height=45)
        info_header.pack(fill='x')
        info_header.pack_propagate(False)
        
        tk.Label(info_header, text="üìã Informaci√≥n de la Cita", 
                font=('Arial', 12, 'bold'), bg='#3B82F6', fg='white').pack(expand=True)
        
        # Contenido de la informaci√≥n
        info_content = tk.Frame(appointment_info_card, bg='white', padx=20, pady=15)
        info_content.pack(fill='both', expand=True)
        
        # Grid de informaci√≥n b√°sica
        basic_info_frame = tk.Frame(info_content, bg='white')
        basic_info_frame.pack(fill='x', pady=(0, 15))
        
        # Fila 1: Fecha y Estado
        row1 = tk.Frame(basic_info_frame, bg='white')
        row1.pack(fill='x', pady=5)
        
        # Fecha
        fecha_frame = tk.Frame(row1, bg='#F8FAFC', relief='solid', bd=1)
        fecha_frame.pack(side='left', fill='x', expand=True, padx=(0, 10))
        
        fecha_inner = tk.Frame(fecha_frame, bg='#F8FAFC', padx=10, pady=8)
        fecha_inner.pack(fill='x')
        
        tk.Label(fecha_inner, text="üìÖ Fecha", font=('Arial', 9, 'bold'), 
                bg='#F8FAFC', fg='#64748B').pack(anchor='w')
        self.appointment_date_label = tk.Label(fecha_inner, text="--/--/----", 
                                             font=('Arial', 10, 'bold'), bg='#F8FAFC', fg='#1E293B')
        self.appointment_date_label.pack(anchor='w')
        
        # Estado
        estado_frame = tk.Frame(row1, bg='#F8FAFC', relief='solid', bd=1)
        estado_frame.pack(side='right', fill='x', expand=True, padx=(10, 0))
        
        estado_inner = tk.Frame(estado_frame, bg='#F8FAFC', padx=10, pady=8)
        estado_inner.pack(fill='x')
        
        tk.Label(estado_inner, text="üìä Estado", font=('Arial', 9, 'bold'), 
                bg='#F8FAFC', fg='#64748B').pack(anchor='w')
        self.appointment_status_label = tk.Label(estado_inner, text="Sin seleccionar", 
                                               font=('Arial', 10, 'bold'), bg='#F8FAFC', fg='#059669')
        self.appointment_status_label.pack(anchor='w')
        
        # Fila 2: Paciente
        patient_card = tk.Frame(info_content, bg='#F1F5F9', relief='solid', bd=1)
        patient_card.pack(fill='x', pady=(0, 10))
        
        patient_inner = tk.Frame(patient_card, bg='#F1F5F9', padx=15, pady=10)
        patient_inner.pack(fill='x')
        
        tk.Label(patient_inner, text="üë§ Paciente", font=('Arial', 10, 'bold'), 
                bg='#F1F5F9', fg='#475569').pack(anchor='w')
        self.appointment_patient_label = tk.Label(patient_inner, text="Seleccione una cita", 
                                                font=('Arial', 11, 'bold'), bg='#F1F5F9', fg='#1E293B')
        self.appointment_patient_label.pack(anchor='w', pady=(2, 0))
        
        # Fila 3: Motivo
        motivo_card = tk.Frame(info_content, bg='#F1F5F9', relief='solid', bd=1)
        motivo_card.pack(fill='x')
        
        motivo_inner = tk.Frame(motivo_card, bg='#F1F5F9', padx=15, pady=10)
        motivo_inner.pack(fill='x')
        
        tk.Label(motivo_inner, text="üí≠ Motivo de la Consulta", font=('Arial', 10, 'bold'), 
                bg='#F1F5F9', fg='#475569').pack(anchor='w')
        self.appointment_motivo_label = tk.Label(motivo_inner, text="--", 
                                               font=('Arial', 10), bg='#F1F5F9', fg='#64748B',
                                               wraplength=600, justify='left')
        self.appointment_motivo_label.pack(anchor='w', pady=(2, 0))
        
        # Panel Doctor & Seguro redise√±ado
        doctor_insurance_card = tk.Frame(form_frame, bg='white', relief='solid', bd=2)
        doctor_insurance_card.pack(fill='x', pady=(0, 20))
        
        # Header
        di_header = tk.Frame(doctor_insurance_card, bg='#059669', height=45)
        di_header.pack(fill='x')
        di_header.pack_propagate(False)
        
        tk.Label(di_header, text="üë®‚Äç‚öïÔ∏è Informaci√≥n M√©dica y Seguro", 
                font=('Arial', 12, 'bold'), bg='#059669', fg='white').pack(expand=True)
        
        # Contenido en grid
        di_content = tk.Frame(doctor_insurance_card, bg='white', padx=20, pady=15)
        di_content.pack(fill='both', expand=True)
        
        # Grid 2x2 para Doctor y Seguro
        grid_frame = tk.Frame(di_content, bg='white')
        grid_frame.pack(fill='x')
        
        # DOCTOR - Columna izquierda
        doctor_section = tk.Frame(grid_frame, bg='white')
        doctor_section.grid(row=0, column=0, sticky='ew', padx=(0, 10))
        
        # Header doctor
        doctor_header = tk.Frame(doctor_section, bg='#3B82F6', height=35)
        doctor_header.pack(fill='x')
        doctor_header.pack_propagate(False)
        
        tk.Label(doctor_header, text="üë®‚Äç‚öïÔ∏è DOCTOR", font=('Arial', 10, 'bold'), 
                bg='#3B82F6', fg='white').pack(expand=True)
        
        # Contenido doctor
        doctor_content = tk.Frame(doctor_section, bg='#F8FAFC', padx=15, pady=12)
        doctor_content.pack(fill='both', expand=True)
        
        # Nombre del doctor
        self.doctor_name_label = tk.Label(doctor_content, text="Dr. No seleccionado", 
                                         font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E293B')
        self.doctor_name_label.pack(anchor='w')
        
        # Especialidad
        specialty_row = tk.Frame(doctor_content, bg='#F8FAFC')
        specialty_row.pack(fill='x', pady=(5, 0))
        tk.Label(specialty_row, text="ü©∫", font=('Arial', 10), bg='#F8FAFC').pack(side='left')
        self.doctor_specialty_label = tk.Label(specialty_row, text="--", 
                                             font=('Arial', 9), bg='#F8FAFC', fg='#64748B')
        self.doctor_specialty_label.pack(side='left', padx=(5, 0))
        
        # Tarifa
        tarifa_row = tk.Frame(doctor_content, bg='#F8FAFC')
        tarifa_row.pack(fill='x', pady=(3, 0))
        tk.Label(tarifa_row, text="üí∞", font=('Arial', 10), bg='#F8FAFC').pack(side='left')
        self.doctor_tarifa_label = tk.Label(tarifa_row, text="RD$ 0.00", 
                                          font=('Arial', 9, 'bold'), bg='#F8FAFC', fg='#059669')
        self.doctor_tarifa_label.pack(side='left', padx=(5, 0))
        
        # Acepta seguros
        seguros_row = tk.Frame(doctor_content, bg='#F8FAFC')
        seguros_row.pack(fill='x', pady=(3, 0))
        tk.Label(seguros_row, text="üè•", font=('Arial', 10), bg='#F8FAFC').pack(side='left')
        self.doctor_seguros_label = tk.Label(seguros_row, text="--", 
                                           font=('Arial', 9), bg='#F8FAFC', fg='#64748B')
        self.doctor_seguros_label.pack(side='left', padx=(5, 0))
        
        # Contacto
        contact_row = tk.Frame(doctor_content, bg='#F8FAFC')
        contact_row.pack(fill='x', pady=(3, 0))
        tk.Label(contact_row, text="üìß", font=('Arial', 10), bg='#F8FAFC').pack(side='left')
        self.doctor_email_label = tk.Label(contact_row, text="--", 
                                         font=('Arial', 8), bg='#F8FAFC', fg='#64748B')
        self.doctor_email_label.pack(side='left', padx=(5, 0))
        
        # SEGURO - Columna derecha
        insurance_section = tk.Frame(grid_frame, bg='white')
        insurance_section.grid(row=0, column=1, sticky='ew', padx=(10, 0))
        
        # Header seguro
        insurance_header = tk.Frame(insurance_section, bg='#F59E0B', height=35)
        insurance_header.pack(fill='x')
        insurance_header.pack_propagate(False)
        
        tk.Label(insurance_header, text="üè• SEGURO M√âDICO", font=('Arial', 10, 'bold'), 
                bg='#F59E0B', fg='white').pack(expand=True)
        
        # Contenido seguro
        insurance_content = tk.Frame(insurance_section, bg='#FFFBEB', padx=15, pady=12)
        insurance_content.pack(fill='both', expand=True)
        
        # Estado del seguro (principal)
        self.insurance_status_frame = tk.Frame(insurance_content, bg='#FFFBEB')
        self.insurance_status_frame.pack(fill='x', pady=(0, 8))
        
        self.insurance_main_label = tk.Label(self.insurance_status_frame, text="Sin seguro", 
                                           font=('Arial', 10, 'bold'), bg='#FFFBEB', fg='#92400E')
        self.insurance_main_label.pack(anchor='w')
        
        # Detalles del seguro
        self.insurance_details_frame = tk.Frame(insurance_content, bg='#FFFBEB')
        self.insurance_details_frame.pack(fill='x')
        
        # Configurar grid weights
        grid_frame.columnconfigure(0, weight=1)
        grid_frame.columnconfigure(1, weight=1)
        
        # Reemplazar self.selected_appointment_info con las nuevas etiquetas
        # Esta variable se mantendr√° por compatibilidad pero no se mostrar√°
        self.selected_appointment_info = tk.Label(form_frame, text="", bg='white', fg='white', height=0)
        self.selected_appointment_info.pack_forget()  # Ocultar completamente
        
        # Servicios y precios
        services_frame = tk.LabelFrame(form_frame, text="üí∞ Servicios y Precios", 
                                      font=('Arial', 11, 'bold'), padx=10, pady=10)
        services_frame.pack(fill='x', pady=(0, 15))
        
        # Lista de servicios con scrollbar
        services_list_frame = tk.Frame(services_frame)
        services_list_frame.pack(fill='both', expand=True, pady=(5, 0))
        
        # Frame para la tabla con scrollbar
        table_container = tk.Frame(services_list_frame, relief='sunken', bd=1)
        table_container.pack(fill='both', expand=True)
        
        # Treeview para servicios con altura aumentada
        columns = ('Servicio', 'Precio')
        self.services_tree = ttk.Treeview(table_container, columns=columns, show='headings', height=12)
        
        for col in columns:
            self.services_tree.heading(col, text=col)
            self.services_tree.column(col, width=250 if col == 'Servicio' else 150, anchor='center')
        
        # Scrollbar para servicios
        services_scrollbar = ttk.Scrollbar(table_container, orient="vertical", command=self.services_tree.yview)
        self.services_tree.configure(yscrollcommand=services_scrollbar.set)
        
        # Pack tabla y scrollbar
        self.services_tree.pack(side='left', fill='both', expand=True)
        services_scrollbar.pack(side='right', fill='y')
        
        # Botones para servicios con mejor espaciado
        services_btn_frame = tk.Frame(services_frame)
        services_btn_frame.pack(fill='x', pady=(15, 0))
        
        tk.Button(services_btn_frame, text="‚ûï Agregar Servicio", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), width=15, command=self.add_service_to_invoice).pack(side='left', padx=(0, 8))
        tk.Button(services_btn_frame, text="‚ûñ Quitar Servicio", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), width=15, command=self.remove_service_from_invoice).pack(side='left', padx=8)
        tk.Button(services_btn_frame, text="üìù Editar Precio", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), width=15, command=self.edit_service_price).pack(side='left', padx=8)
        
        # Totales
        totals_frame = tk.LabelFrame(form_frame, text="üíµ Totales", 
                                    font=('Arial', 11, 'bold'), padx=10, pady=10)
        totals_frame.pack(fill='x', pady=(0, 15))
        
        # Subtotal
        subtotal_frame = tk.Frame(totals_frame)
        subtotal_frame.pack(fill='x', pady=2)
        tk.Label(subtotal_frame, text="Subtotal:", font=('Arial', 10, 'bold')).pack(side='left')
        self.subtotal_label = tk.Label(subtotal_frame, text="RD$ 0.00", font=('Arial', 10), fg='#1E3A8A')
        self.subtotal_label.pack(side='right')
        
        # ITBIS
        itbis_frame = tk.Frame(totals_frame)
        itbis_frame.pack(fill='x', pady=2)
        tk.Label(itbis_frame, text="ITBIS (18%):", font=('Arial', 10, 'bold')).pack(side='left')
        self.itbis_label = tk.Label(itbis_frame, text="RD$ 0.00", font=('Arial', 10), fg='#1E3A8A')
        self.itbis_label.pack(side='right')
        
        # Total
        total_frame = tk.Frame(totals_frame)
        total_frame.pack(fill='x', pady=2)
        tk.Label(total_frame, text="TOTAL:", font=('Arial', 12, 'bold')).pack(side='left')
        self.total_label = tk.Label(total_frame, text="RD$ 0.00", font=('Arial', 12, 'bold'), fg='#C0392B')
        self.total_label.pack(side='right')
        
        # Observaciones
        obs_frame = tk.LabelFrame(form_frame, text="üìù Observaciones", 
                                 font=('Arial', 11, 'bold'), padx=10, pady=10)
        obs_frame.pack(fill='x', pady=(0, 15))
        
        self.observations_text = tk.Text(obs_frame, height=4, font=('Arial', 10), wrap='word')
        self.observations_text.pack(fill='x', pady=(5, 0))
        
        # Botones de acci√≥n principales con mejor dise√±o
        actions_frame = tk.Frame(form_frame)
        actions_frame.pack(fill='x', pady=(20, 0))
        
        tk.Button(actions_frame, text="üßæ Crear Factura", bg='#0B5394', fg='white',
                 font=('Arial', 12, 'bold'), width=18, pady=8,
                 command=self.create_invoice_from_appointment).pack(side='left', padx=(0, 8))
        tk.Button(actions_frame, text="ÔøΩ Procesar Pago", bg='#0B5394', fg='white',
                 font=('Arial', 12, 'bold'), width=18, pady=8,
                 command=self.open_payment_window).pack(side='left', padx=8)
        tk.Button(actions_frame, text="üóëÔ∏è Limpiar", bg='#0B5394', fg='white',
                 font=('Arial', 12, 'bold'), width=12, pady=8,
                 command=self.clear_invoice_form).pack(side='right')
        
        # Cargar servicios predeterminados
        self.load_default_services()
        
        # Habilitar scroll con rueda del mouse
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        # Bind del scroll del mouse al canvas y todos sus widgets
        canvas.bind_all("<MouseWheel>", _on_mousewheel)
        scrollable_frame.bind_all("<MouseWheel>", _on_mousewheel)
    
    def load_pending_appointments(self):
        """Cargar citas pendientes de facturaci√≥n"""
        try:
            # Limpiar tabla
            for item in self.billing_appointments_tree.get_children():
                self.billing_appointments_tree.delete(item)
            
            # Obtener citas completadas pero no facturadas
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT c.id, 
                       DATE(c.fecha_hora) as fecha_cita, 
                       TIME(c.fecha_hora) as hora_cita,
                       p.nombre || ' ' || p.apellido as paciente,
                       d.nombre || ' ' || d.apellido as doctor,
                       c.motivo, c.estado
                FROM citas c
                JOIN usuarios p ON c.paciente_id = p.id
                JOIN usuarios d ON c.doctor_id = d.id
                WHERE c.estado IN ('completada', 'realizada') 
                ORDER BY c.fecha_hora DESC
            """)
            
            appointments = cursor.fetchall()
            
            for appointment in appointments:
                # Formatear fecha
                fecha = datetime.fromisoformat(appointment[1]).strftime('%d/%m/%Y') if appointment[1] else ''
                
                self.billing_appointments_tree.insert('', 'end', values=(
                    appointment[0],  # ID
                    fecha,           # Fecha
                    appointment[3],  # Paciente
                    appointment[4],  # Doctor
                    appointment[5],  # Motivo
                    appointment[6].title()  # Estado
                ))
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error cargando citas: {str(e)}")
    
    def load_default_services(self):
        """Cargar servicios predeterminados"""
        # Servicios comunes con precios
        default_services = [
            ("Consulta General", 2500.00),
            ("Consulta Especializada", 3500.00),
            ("Consulta Pedi√°trica", 2800.00),
            ("Consulta Cardiol√≥gica", 4000.00),
            ("Consulta Ginecol√≥gica", 3200.00),
            ("Consulta Dermatol√≥gica", 3800.00),
            ("Consulta Neurol√≥gica", 4500.00),
            ("Consulta Oftalmol√≥gica", 3000.00),
            ("An√°lisis de Laboratorio", 1500.00),
            ("An√°lisis de Sangre Completo", 2200.00),
            ("An√°lisis de Orina", 800.00),
            ("Perfil Lip√≠dico", 1800.00),
            ("Glicemia", 600.00),
            ("Hemoglobina Glicosilada", 1200.00),
            ("Radiograf√≠a", 3000.00),
            ("Radiograf√≠a de T√≥rax", 2500.00),
            ("Radiograf√≠a de Extremidades", 2800.00),
            ("Electrocardiograma", 2000.00),
            ("Ecograf√≠a", 4500.00),
            ("Ecograf√≠a Abdominal", 4000.00),
            ("Ecograf√≠a P√©lvica", 3800.00),
            ("Mamograf√≠a", 5000.00),
            ("Tomograf√≠a", 8000.00),
            ("Resonancia Magn√©tica", 12000.00),
            ("Procedimiento Menor", 3500.00),
            ("Sutura Simple", 2000.00),
            ("Curaci√≥n", 1000.00),
            ("Inyecci√≥n Intramuscular", 500.00),
            ("Vacunaci√≥n", 800.00),
            ("Terapia F√≠sica", 2500.00)
        ]
        
        for service, price in default_services:
            self.services_tree.insert('', 'end', values=(service, f"RD$ {price:,.2f}"))
    
    def on_appointment_select_billing(self, event):
        """Manejar selecci√≥n de cita para facturar con nuevo dise√±o"""
        try:
            selection = self.billing_appointments_tree.selection()
            if not selection:
                print("DEBUG: No hay selecci√≥n")
                return
            
            item = self.billing_appointments_tree.item(selection[0])
            values = item['values']
            
            print(f"DEBUG: Valores seleccionados: {values}")
            
            # Obtener informaci√≥n del doctor y paciente
            doctor_info = self.get_doctor_billing_info(values[3])
            patient_info = self.get_patient_insurance_info(values[2])
            
            print(f"DEBUG: Doctor info obtenida: {doctor_info}")
            print(f"DEBUG: Patient info obtenida: {patient_info}")
            
            # Verificar que obtuvimos informaci√≥n v√°lida
            if not doctor_info:
                print("ERROR: No se pudo obtener informaci√≥n del doctor")
                return
            if not patient_info:
                print("ERROR: No se pudo obtener informaci√≥n del paciente")
                return
            
            # Actualizar informaci√≥n b√°sica de la cita con nuevo dise√±o
            if hasattr(self, 'appointment_date_label'):
                self.appointment_date_label.config(text=values[1])
                self.appointment_patient_label.config(text=values[2])
                self.appointment_motivo_label.config(text=values[4])
                
                # Estado con color
                estado = values[5]
                if estado.lower() == 'completada':
                    status_color = '#059669'
                    status_text = '‚úì Completada'
                elif estado.lower() == 'confirmada':
                    status_color = '#3B82F6'
                    status_text = '‚óè Confirmada'
                elif estado.lower() == 'pendiente':
                    status_color = '#F59E0B'
                    status_text = '‚è≥ Pendiente'
                else:
                    status_color = '#64748B'
                    status_text = estado
                
                self.appointment_status_label.config(text=status_text, fg=status_color)
                
            # Actualizar informaci√≥n del doctor con dise√±o moderno
            if doctor_info:
                print(f"DEBUG: Actualizando info del doctor: {doctor_info}")
                self.update_doctor_panel_info(doctor_info)
            
            # Actualizar informaci√≥n del seguro con dise√±o moderno
            if patient_info and doctor_info:
                print(f"DEBUG: Actualizando info del seguro: {patient_info}")
                self.update_modern_insurance_info(patient_info, doctor_info.get('acepta_seguros', True))
            
            # Mantener funcionalidad original para compatibilidad
            info_text = f"""üìÖ Fecha: {values[1]}
üë§ Paciente: {values[2]}
üë®‚Äç‚öïÔ∏è Doctor: {values[3]}
üí∞ Tarifa Doctor: RD$ {doctor_info['tarifa']:,.2f}
üè• Acepta Seguros: {'‚úÖ S√≠' if doctor_info['acepta_seguros'] else '‚ùå No'}
ÔøΩÔ∏è Seguro Paciente: {patient_info['seguro'] if patient_info['seguro'] else 'Sin Seguro'}
ÔøΩüí≠ Motivo: {values[4]}
üìä Estado: {values[5]}

‚úÖ Cita lista para facturar"""
            
            # Mantener por compatibilidad pero oculto
            if hasattr(self, 'selected_appointment_info'):
                self.selected_appointment_info.config(text=info_text, fg='#16A085')
            
            # Guardar informaci√≥n para facturar
            self.selected_appointment_id = values[0]
            self.selected_doctor_info = doctor_info
            self.selected_patient_info = patient_info
            
            # Recargar servicios con tarifa del doctor
            self.load_doctor_services(doctor_info)
            
            # Actualizar paneles de informaci√≥n (mantener para compatibilidad)
            if hasattr(self, 'doctor_info_label'):
                self.update_doctor_info_panel(doctor_info)
            if hasattr(self, 'insurance_info_label'):
                self.update_insurance_info_panel(patient_info, doctor_info['acepta_seguros'])
                
        except Exception as e:
            print(f"ERROR en on_appointment_select_billing: {e}")
            import traceback
            traceback.print_exc()
    
    def get_doctor_billing_info(self, doctor_name):
        """Obtener informaci√≥n de facturaci√≥n del doctor"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Buscar informaci√≥n del doctor
            cursor.execute('''
                SELECT u.nombre, u.apellido, u.telefono, u.email,
                       COALESCE(d.tarifa_consulta, 3000.00) as tarifa,
                       COALESCE(d.acepta_seguros, 1) as acepta_seguros,
                       COALESCE(d.especialidad, 'Medicina General') as especialidad
                FROM usuarios u
                LEFT JOIN doctores d ON u.id = d.id
                WHERE (u.nombre || ' ' || u.apellido) LIKE ? AND u.tipo_usuario = 'doctor'
                LIMIT 1
            ''', (f'%{doctor_name}%',))
            
            result = cursor.fetchone()
            cursor.close()
            conn.close()
            
            if result:
                return {
                    'nombre_completo': f"{result[0]} {result[1]}",
                    'telefono': result[2] or 'No especificado',
                    'email': result[3] or 'No especificado',
                    'tarifa': float(result[4]),
                    'acepta_seguros': bool(result[5]),
                    'especialidad': result[6]
                }
            else:
                # Valores por defecto si no se encuentra el doctor
                return {
                    'nombre_completo': doctor_name,
                    'telefono': 'No especificado',
                    'email': 'No especificado',
                    'tarifa': 3000.00,
                    'acepta_seguros': True,
                    'especialidad': 'Medicina General'
                }
                
        except Exception as e:
            print(f"Error obteniendo info del doctor: {e}")
            return {
                'nombre_completo': doctor_name,
                'telefono': 'No especificado',
                'email': 'No especificado',
                'tarifa': 3000.00,
                'acepta_seguros': True,
                'especialidad': 'Medicina General'
            }
    
    def get_patient_insurance_info(self, patient_name):
        """Obtener informaci√≥n del seguro del paciente"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Buscar informaci√≥n del paciente
            cursor.execute('''
                SELECT u.nombre, u.apellido, u.telefono, u.email,
                       p.seguro_medico, p.numero_seguro, p.porcentaje_cobertura
                FROM usuarios u
                LEFT JOIN pacientes p ON u.id = p.id
                WHERE (u.nombre || ' ' || u.apellido) LIKE ? AND u.tipo_usuario = 'paciente'
                LIMIT 1
            ''', (f'%{patient_name}%',))
            
            result = cursor.fetchone()
            cursor.close()
            conn.close()
            
            if result:
                return {
                    'nombre_completo': f"{result[0]} {result[1]}",
                    'telefono': result[2] or 'No especificado',
                    'email': result[3] or 'No especificado',
                    'seguro': result[4] or None,
                    'numero_seguro': result[5] or None,
                    'cobertura': float(result[6]) if result[6] else 0.0
                }
            else:
                return {
                    'nombre_completo': patient_name,
                    'telefono': 'No especificado',
                    'email': 'No especificado',
                    'seguro': None,
                    'numero_seguro': None,
                    'cobertura': 0.0
                }
                
        except Exception as e:
            print(f"Error obteniendo info del paciente: {e}")
            return {
                'nombre_completo': patient_name,
                'telefono': 'No especificado',
                'email': 'No especificado',
                'seguro': None,
                'numero_seguro': None,
                'cobertura': 0.0
            }
    
    def load_doctor_services(self, doctor_info):
        """Cargar servicios con la tarifa espec√≠fica del doctor"""
        # Limpiar servicios actuales
        for item in self.services_tree.get_children():
            self.services_tree.delete(item)
        
        # Servicios base ajustados con la tarifa del doctor
        base_price = doctor_info['tarifa']
        specialty = doctor_info['especialidad']
        
        # Servicios espec√≠ficos seg√∫n especialidad y tarifa del doctor
        if 'Cardiolog' in specialty:
            services = [
                ("Consulta Cardiol√≥gica", base_price),
                ("Electrocardiograma", base_price * 0.7),
                ("Ecocardiograma", base_price * 1.8),
                ("Prueba de Esfuerzo", base_price * 2.0),
                ("Holter 24h", base_price * 2.5)
            ]
        elif 'Ginecolog' in specialty:
            services = [
                ("Consulta Ginecol√≥gica", base_price),
                ("Ecograf√≠a P√©lvica", base_price * 1.5),
                ("Papanicolaou", base_price * 0.8),
                ("Colposcopia", base_price * 1.3),
                ("Control Prenatal", base_price * 0.9)
            ]
        elif 'Pediatr' in specialty:
            services = [
                ("Consulta Pedi√°trica", base_price),
                ("Control de Ni√±o Sano", base_price * 0.8),
                ("Vacunaci√≥n", base_price * 0.3),
                ("Nebulizaci√≥n", base_price * 0.5),
                ("Evaluaci√≥n Desarrollo", base_price * 1.2)
            ]
        elif 'Dermatolog' in specialty:
            services = [
                ("Consulta Dermatol√≥gica", base_price),
                ("Biopsia de Piel", base_price * 1.5),
                ("Criocirug√≠a", base_price * 1.8),
                ("Dermatoscopia", base_price * 1.2),
                ("Tratamiento Acn√©", base_price * 0.9)
            ]
        elif 'Neurolog' in specialty:
            services = [
                ("Consulta Neurol√≥gica", base_price),
                ("Electroencefalograma", base_price * 1.8),
                ("Evaluaci√≥n Neurol√≥gica", base_price * 1.3),
                ("Test Cognitivo", base_price * 1.1),
                ("Tratamiento Migra√±a", base_price * 0.9)
            ]
        else:
            # Medicina General - servicios est√°ndar
            services = [
                ("Consulta General", base_price),
                ("Consulta de Control", base_price * 0.8),
                ("Certificado M√©dico", base_price * 0.5),
                ("Inyecci√≥n Intramuscular", base_price * 0.2),
                ("Curaci√≥n", base_price * 0.4),
                ("Sutura Simple", base_price * 0.8),
                ("Electrocardiograma", base_price * 0.7),
                ("Toma de Presi√≥n", base_price * 0.2)
            ]
        
        # Agregar servicios adicionales comunes
        additional_services = [
            ("An√°lisis de Laboratorio", 1500.00),
            ("An√°lisis de Sangre", 2200.00),
            ("An√°lisis de Orina", 800.00),
            ("Radiograf√≠a", 3000.00),
            ("Ecograf√≠a", 4500.00)
        ]
        
        # Insertar servicios en el tree
        for service, price in services + additional_services:
            self.services_tree.insert('', 'end', values=(service, f"RD$ {price:,.2f}"))
        
        # Calcular totales
        self.calculate_totals()
    
    def update_doctor_info_panel(self, doctor_info):
        """Actualizar panel de informaci√≥n del doctor"""
        doctor_text = f"""üìã {doctor_info['especialidad']}
üí∞ Tarifa: RD$ {doctor_info['tarifa']:,.2f}
üè• Acepta Seguros: {'‚úÖ S√ç' if doctor_info['acepta_seguros'] else '‚ùå NO'}
üìß {doctor_info['email'][:20]}{'...' if len(doctor_info['email']) > 20 else ''}
üìû {doctor_info['telefono']}"""
        
        self.doctor_info_label.config(text=doctor_text)
    
    def update_insurance_info_panel(self, patient_info, doctor_acepta_seguros):
        """Actualizar panel de informaci√≥n del seguro"""
        if patient_info['seguro'] and doctor_acepta_seguros:
            # Paciente tiene seguro y doctor acepta
            insurance_text = f"""‚úÖ {patient_info['seguro']}
üìã No. {patient_info['numero_seguro'] or 'No especificado'}
üí∞ Cobertura: {patient_info['cobertura']:.0f}%
üìä Estado: APLICABLE
üí° Se aplicar√° descuento"""
            color = '#1565c0'
        elif patient_info['seguro'] and not doctor_acepta_seguros:
            # Paciente tiene seguro pero doctor no acepta
            insurance_text = f"""‚ö†Ô∏è {patient_info['seguro']}
üìã No. {patient_info['numero_seguro'] or 'No especificado'}
üí∞ Cobertura: {patient_info['cobertura']:.0f}%
üìä Estado: NO APLICABLE
‚ùå Doctor no acepta seguros"""
            color = '#f57c00'
        elif not patient_info['seguro'] and doctor_acepta_seguros:
            # Doctor acepta seguros pero paciente no tiene
            insurance_text = f"""‚ÑπÔ∏è SIN SEGURO M√âDICO
üìä Estado: NO APLICABLE
üí° Paciente pagar√° precio completo
‚úÖ Doctor acepta seguros"""
            color = '#64748B'
        else:
            # Ni el doctor acepta ni el paciente tiene
            insurance_text = f"""‚ùå SIN SEGURO M√âDICO
üìä Estado: NO APLICABLE
üí° Paciente pagar√° precio completo
‚ùå Doctor no acepta seguros"""
            color = '#64748B'
        
        self.insurance_info_label.config(text=insurance_text, fg=color)
    
    def update_doctor_panel_info(self, doctor_info):
        """Actualizar panel de informaci√≥n del doctor con dise√±o moderno - VERSI√ìN SEGURA"""
        if not hasattr(self, 'doctor_name_label'):
            print("DEBUG: No se encontr√≥ doctor_name_label")
            return
            
        try:
            # Verificar estructura del diccionario
            print(f"DEBUG: Estructura doctor_info: {doctor_info}")
            
            # Nombre completo del doctor (adaptado a la estructura actual)
            if 'nombre_completo' in doctor_info:
                doctor_full_name = f"Dr. {doctor_info['nombre_completo']}"
            else:
                doctor_full_name = "Dr. No especificado"
            
            self.doctor_name_label.config(text=doctor_full_name)
            
            # Especialidad
            especialidad = doctor_info.get('especialidad', 'Medicina General')
            if hasattr(self, 'doctor_specialty_label'):
                self.doctor_specialty_label.config(text=especialidad)
            
            # Tarifa
            tarifa = doctor_info.get('tarifa', 3000.00)
            tarifa_text = f"RD$ {tarifa:,.2f}"
            if hasattr(self, 'doctor_tarifa_label'):
                self.doctor_tarifa_label.config(text=tarifa_text)
            
            # Acepta seguros
            acepta_seguros = doctor_info.get('acepta_seguros', True)
            if hasattr(self, 'doctor_seguros_label'):
                if acepta_seguros:
                    seguros_text = "Acepta seguros"
                    seguros_color = '#059669'
                else:
                    seguros_text = "No acepta seguros"
                    seguros_color = '#DC2626'
                self.doctor_seguros_label.config(text=seguros_text, fg=seguros_color)
            
            # Email (truncado)
            email = doctor_info.get('email', 'No especificado')
            if len(email) > 25:
                email_display = email[:22] + '...'
            else:
                email_display = email
            if hasattr(self, 'doctor_email_label'):
                self.doctor_email_label.config(text=email_display)
                
            print("DEBUG: Doctor info actualizada correctamente")
            
        except Exception as e:
            print(f"ERROR en update_doctor_panel_info: {e}")
            import traceback
            traceback.print_exc()

    def update_modern_insurance_info(self, patient_info, doctor_acepta_seguros):
        """Actualizar panel de informaci√≥n del seguro con dise√±o moderno"""
        if not hasattr(self, 'insurance_main_label'):
            print("DEBUG: No se encontr√≥ insurance_main_label")
            return
            
        try:
            print(f"DEBUG: Estructura patient_info: {patient_info}")
            print(f"DEBUG: Doctor acepta seguros: {doctor_acepta_seguros}")
            
            # Limpiar detalles anteriores
            if hasattr(self, 'insurance_details_frame'):
                for widget in self.insurance_details_frame.winfo_children():
                    widget.destroy()
            
            # Obtener informaci√≥n del seguro del paciente
            seguro = patient_info.get('seguro', None)
            numero_seguro = patient_info.get('numero_seguro', 'No especificado')
            cobertura = patient_info.get('cobertura', 0)
            
            if seguro and doctor_acepta_seguros:
                # Paciente tiene seguro y doctor acepta - CASO √ìPTIMO
                self.insurance_main_label.config(text=f"‚úÖ {seguro}", fg='#059669')
                
                if hasattr(self, 'insurance_details_frame'):
                    # N√∫mero de p√≥liza
                    numero_row = tk.Frame(self.insurance_details_frame, bg='#FFFBEB')
                    numero_row.pack(fill='x', pady=1)
                    tk.Label(numero_row, text="üìã", font=('Arial', 9), bg='#FFFBEB').pack(side='left')
                    tk.Label(numero_row, text=f"No. {numero_seguro}", font=('Arial', 8), 
                            bg='#FFFBEB', fg='#64748B').pack(side='left', padx=(3, 0))
                    
                    # Cobertura
                    cobertura_row = tk.Frame(self.insurance_details_frame, bg='#FFFBEB')
                    cobertura_row.pack(fill='x', pady=1)
                    tk.Label(cobertura_row, text="üí∞", font=('Arial', 9), bg='#FFFBEB').pack(side='left')
                    tk.Label(cobertura_row, text=f"Cobertura: {cobertura:.0f}%", 
                            font=('Arial', 8, 'bold'), bg='#FFFBEB', fg='#059669').pack(side='left', padx=(3, 0))
                    
                    # Estado
                    status_row = tk.Frame(self.insurance_details_frame, bg='#FFFBEB')
                    status_row.pack(fill='x', pady=1)
                    tk.Label(status_row, text="‚úÖ", font=('Arial', 9), bg='#FFFBEB').pack(side='left')
                    tk.Label(status_row, text="Descuento aplicable", font=('Arial', 8, 'bold'), 
                            bg='#FFFBEB', fg='#059669').pack(side='left', padx=(3, 0))
                
            elif seguro and not doctor_acepta_seguros:
                # Paciente tiene seguro pero doctor no acepta
                self.insurance_main_label.config(text=f"‚ö†Ô∏è {seguro}", fg='#F59E0B')
                
                if hasattr(self, 'insurance_details_frame'):
                    # N√∫mero de p√≥liza
                    numero_row = tk.Frame(self.insurance_details_frame, bg='#FFFBEB')
                    numero_row.pack(fill='x', pady=1)
                    tk.Label(numero_row, text="üìã", font=('Arial', 9), bg='#FFFBEB').pack(side='left')
                    tk.Label(numero_row, text=f"No. {numero_seguro}", font=('Arial', 8), 
                            bg='#FFFBEB', fg='#64748B').pack(side='left', padx=(3, 0))
                    
                    # Estado
                    status_row = tk.Frame(self.insurance_details_frame, bg='#FFFBEB')
                    status_row.pack(fill='x', pady=1)
                    tk.Label(status_row, text="‚ùå", font=('Arial', 9), bg='#FFFBEB').pack(side='left')
                    tk.Label(status_row, text="Doctor no acepta seguros", font=('Arial', 8), 
                            bg='#FFFBEB', fg='#F59E0B').pack(side='left', padx=(3, 0))
                    
                    # Precio completo
                    precio_row = tk.Frame(self.insurance_details_frame, bg='#FFFBEB')
                    precio_row.pack(fill='x', pady=1)
                    tk.Label(precio_row, text="üí≥", font=('Arial', 9), bg='#FFFBEB').pack(side='left')
                    tk.Label(precio_row, text="Pago completo requerido", font=('Arial', 8), 
                            bg='#FFFBEB', fg='#64748B').pack(side='left', padx=(3, 0))
                
            elif not seguro and doctor_acepta_seguros:
                # Doctor acepta seguros pero paciente no tiene
                self.insurance_main_label.config(text="‚ÑπÔ∏è Sin seguro m√©dico", fg='#64748B')
                
                if hasattr(self, 'insurance_details_frame'):
                    # Estado
                    status_row = tk.Frame(self.insurance_details_frame, bg='#FFFBEB')
                    status_row.pack(fill='x', pady=1)
                    tk.Label(status_row, text="üí°", font=('Arial', 9), bg='#FFFBEB').pack(side='left')
                    tk.Label(status_row, text="Doctor acepta seguros", font=('Arial', 8), 
                            bg='#FFFBEB', fg='#3B82F6').pack(side='left', padx=(3, 0))
                    
                    # Precio completo
                    precio_row = tk.Frame(self.insurance_details_frame, bg='#FFFBEB')
                    precio_row.pack(fill='x', pady=1)
                    tk.Label(precio_row, text="üí≥", font=('Arial', 9), bg='#FFFBEB').pack(side='left')
                    tk.Label(precio_row, text="Pago completo requerido", font=('Arial', 8), 
                            bg='#FFFBEB', fg='#64748B').pack(side='left', padx=(3, 0))
                
            else:
                # Ni el doctor acepta ni el paciente tiene
                self.insurance_main_label.config(text="‚ùå Sin cobertura", fg='#DC2626')
                
                if hasattr(self, 'insurance_details_frame'):
                    # Estado
                    status_row = tk.Frame(self.insurance_details_frame, bg='#FFFBEB')
                    status_row.pack(fill='x', pady=1)
                    tk.Label(status_row, text="‚ùå", font=('Arial', 9), bg='#FFFBEB').pack(side='left')
                    tk.Label(status_row, text="Sin seguro disponible", font=('Arial', 8), 
                            bg='#FFFBEB', fg='#DC2626').pack(side='left', padx=(3, 0))
                    
                    # Precio completo
                    precio_row = tk.Frame(self.insurance_details_frame, bg='#FFFBEB')
                    precio_row.pack(fill='x', pady=1)
                    tk.Label(precio_row, text="üí≥", font=('Arial', 9), bg='#FFFBEB').pack(side='left')
                    tk.Label(precio_row, text="Pago completo requerido", font=('Arial', 8), 
                            bg='#FFFBEB', fg='#64748B').pack(side='left', padx=(3, 0))
                            
            print("DEBUG: Insurance info actualizada correctamente")
            
        except Exception as e:
            print(f"ERROR en update_modern_insurance_info: {e}")
            import traceback
            traceback.print_exc()
    
    def add_service_to_invoice(self):
        """Agregar servicio con men√∫ desplegable y cantidad"""
        
        # Verificar si hay una cita seleccionada O una factura seleccionada
        appointment_selected = hasattr(self, 'billing_appointments_tree') and self.billing_appointments_tree.selection()
        invoice_selected = hasattr(self, 'billing_invoices_tree') and self.billing_invoices_tree.selection()
        
        if not appointment_selected and not invoice_selected:
            messagebox.showwarning("Selecci√≥n requerida", 
                "Por favor, seleccione una cita de la tabla 'Citas para Facturar' O una factura de la tabla 'Facturas Generadas'")
            return
        
        # Si hay una factura seleccionada, usar esa; sino usar la cita
        if invoice_selected:
            # Obtener informaci√≥n de la factura seleccionada
            item = self.billing_invoices_tree.selection()[0]
            invoice_values = self.billing_invoices_tree.item(item, 'values')
            numero_factura = invoice_values[0]
            print(f"DEBUG: Agregando servicio a factura existente: {numero_factura}")
        else:
            print(f"DEBUG: Agregando servicio desde cita seleccionada")
        
        # Di√°logo moderno para agregar servicio
        dialog = tk.Toplevel()
        dialog.title("‚ûï Agregar Servicio")
        dialog.geometry("500x400")
        dialog.configure(bg='#F8FAFC')
        dialog.transient(self.root)
        dialog.grab_set()
        dialog.resizable(False, False)
        
        # Centrar el di√°logo
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (500 // 2)
        y = (dialog.winfo_screenheight() // 2) - (400 // 2)
        dialog.geometry(f"500x400+{x}+{y}")
        
        # Header
        header_frame = tk.Frame(dialog, bg='#3B82F6', height=60)
        header_frame.pack(fill='x', padx=0, pady=0)
        header_frame.pack_propagate(False)
        
        tk.Label(header_frame, text="üè• Seleccionar Servicio M√©dico", 
                font=('Arial', 14, 'bold'), bg='#3B82F6', fg='white').pack(expand=True)
        
        # Container principal
        main_frame = tk.Frame(dialog, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Servicios predefinidos con categor√≠as
        services_data = {
            "üíä Consultas": [
                ("Consulta General", 2500.00),
                ("Consulta Especializada", 3500.00),
                ("Consulta de Seguimiento", 1500.00),
                ("Consulta de Emergencia", 4000.00)
            ],
            "üî¨ Ex√°menes": [
                ("Laboratorio B√°sico", 1200.00),
                ("Laboratorio Completo", 2500.00),
                ("Electrocardiograma", 800.00),
                ("Radiograf√≠a", 1500.00),
                ("Ecograf√≠a", 2800.00),
                ("Resonancia Magn√©tica", 8000.00)
            ],
            "üíâ Procedimientos": [
                ("Inyecci√≥n", 300.00),
                ("Curaci√≥n", 500.00),
                ("Sutura", 1000.00),
                ("Extracci√≥n", 800.00),
                ("Biopsia", 2500.00)
            ],
            "üèÉ Terapias": [
                ("Fisioterapia", 1200.00),
                ("Terapia Respiratoria", 1500.00),
                ("Terapia Ocupacional", 1800.00),
                ("Rehabilitaci√≥n", 2000.00)
            ]
        }
        
        # Selecci√≥n de categor√≠a
        tk.Label(main_frame, text="üìã Categor√≠a:", font=('Arial', 12, 'bold'), 
                bg='#F8FAFC', fg='#1F2937').pack(anchor='w', pady=(0, 5))
        
        category_var = tk.StringVar()
        categories_list = list(services_data.keys())
        category_combo = ttk.Combobox(main_frame, textvariable=category_var, 
                                     values=categories_list,
                                     font=('Arial', 11), state='readonly', width=45)
        category_combo.pack(fill='x', pady=(0, 15))
        
        # Selecci√≥n de servicio
        tk.Label(main_frame, text="üîß Servicio:", font=('Arial', 12, 'bold'), 
                bg='#F8FAFC', fg='#1F2937').pack(anchor='w', pady=(0, 5))
        
        service_var = tk.StringVar()
        service_combo = ttk.Combobox(main_frame, textvariable=service_var,
                                    font=('Arial', 11), state='readonly', width=45)
        service_combo.pack(fill='x', pady=(0, 15))
        
        # Mostrar precio del servicio seleccionado
        price_label = tk.Label(main_frame, text="üí∞ Precio: RD$ 0.00", 
                              font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#059669')
        price_label.pack(anchor='w', pady=(0, 15))
        
        # Cantidad
        tk.Label(main_frame, text="üìä Cantidad:", font=('Arial', 12, 'bold'), 
                bg='#F8FAFC', fg='#1F2937').pack(anchor='w', pady=(0, 5))
        
        quantity_frame = tk.Frame(main_frame, bg='#F8FAFC')
        quantity_frame.pack(fill='x', pady=(0, 15))
        
        quantity_var = tk.IntVar(value=1)
        quantity_spinbox = tk.Spinbox(quantity_frame, from_=1, to=99, textvariable=quantity_var,
                                     font=('Arial', 11), width=10, justify='center')
        quantity_spinbox.pack(side='left')
        
        # Total calculado
        total_label = tk.Label(quantity_frame, text="Total: RD$ 0.00", 
                              font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#DC2626')
        total_label.pack(side='right')
        
        # Variables para almacenar datos
        current_services = {}
        current_price = 0.0
        
        def update_services(*args):
            """Actualizar servicios cuando cambie la categor√≠a"""
            category = category_var.get()
            if category in services_data:
                services = [f"{name} - RD$ {price:,.2f}" for name, price in services_data[category]]
                service_combo['values'] = services
                service_combo.set('')
                price_label.config(text="üí∞ Precio: RD$ 0.00")
                total_label.config(text="Total: RD$ 0.00")
                
                # Actualizar diccionario de servicios
                current_services.clear()
                for name, price in services_data[category]:
                    current_services[f"{name} - RD$ {price:,.2f}"] = (name, price)
        
        def update_price(*args):
            """Actualizar precio cuando cambie el servicio"""
            nonlocal current_price
            service_key = service_var.get()
            if service_key in current_services:
                name, price = current_services[service_key]
                current_price = price
                price_label.config(text=f"üí∞ Precio: RD$ {price:,.2f}")
                update_total()
        
        def update_total(*args):
            """Actualizar total cuando cambie la cantidad"""
            quantity = quantity_var.get()
            total = current_price * quantity
            total_label.config(text=f"Total: RD$ {total:,.2f}")
        
        # Conectar eventos
        category_var.trace('w', update_services)
        service_var.trace('w', update_price)
        quantity_var.trace('w', update_total)
        
        # Inicializar con la primera categor√≠a
        if categories_list:
            category_combo.current(0)  # Seleccionar la primera categor√≠a
            update_services()  # Poblar servicios
        
        # Botones
        btn_frame = tk.Frame(main_frame, bg='#F8FAFC')
        btn_frame.pack(fill='x', pady=(20, 0))
        
        def add_service():
            if not service_var.get():
                messagebox.showwarning("Selecci√≥n requerida", "Por favor seleccione un servicio")
                return
            
            service_key = service_var.get()
            service_name, service_price = current_services[service_key]
            quantity = quantity_var.get()
            total_price = service_price * quantity
            
            print(f"DEBUG: Agregando servicio - {service_name}, Cantidad: {quantity}, Total: {total_price}")
            
            # Si estamos agregando a una factura existente, guardar en BD
            if invoice_selected:
                try:
                    conn = self.db_manager.get_connection()
                    cursor = conn.cursor()
                    
                    # Buscar la factura en la BD para obtener su ID
                    cursor.execute("SELECT id FROM facturas WHERE numero_factura = ?", (numero_factura,))
                    factura_result = cursor.fetchone()
                    
                    if factura_result:
                        factura_id = factura_result[0]
                        
                        # Agregar el servicio a la tabla servicios_factura (si existe)
                        try:
                            cursor.execute("""
                                INSERT INTO servicios_factura (factura_id, servicio_nombre, cantidad, precio_unitario, precio_total)
                                VALUES (?, ?, ?, ?, ?)
                            """, (factura_id, service_name, quantity, service_price, total_price))
                            
                            # Actualizar el monto total de la factura
                            cursor.execute("""
                                UPDATE facturas 
                                SET monto = monto + ?
                                WHERE id = ?
                            """, (total_price, factura_id))
                            
                            conn.commit()
                            print(f"DEBUG: Servicio guardado en BD para factura {numero_factura}")
                            
                        except Exception as e:
                            print(f"DEBUG: Tabla servicios_factura no existe o error: {e}")
                            # Si no existe la tabla, solo actualizamos el monto total
                            cursor.execute("""
                                UPDATE facturas 
                                SET monto = monto + ?
                                WHERE id = ?
                            """, (total_price, factura_id))
                            conn.commit()
                            print(f"DEBUG: Solo se actualiz√≥ el monto total de la factura")
                    
                    cursor.close()
                    conn.close()
                    
                except Exception as e:
                    print(f"DEBUG: Error guardando servicio en BD: {e}")
            
            # IMPORTANTE: Agregar al widget correcto que se muestra en la interfaz
            if hasattr(self, 'services_tree') and self.services_tree:
                # Agregar el servicio con cantidad incluida en el nombre
                service_display = f"{service_name} (x{quantity})"
                self.services_tree.insert('', 'end', values=(
                    service_display,
                    f"RD$ {total_price:,.2f}"
                ))
                print(f"DEBUG: Servicio agregado al services_tree principal: {service_display}")
            else:
                print("DEBUG: No se encontr√≥ services_tree principal")
            
            # Tambi√©n agregar al tree de facturaci√≥n oculto para compatibilidad
            if hasattr(self, 'invoice_services_tree') and self.invoice_services_tree:
                self.invoice_services_tree.insert('', 'end', values=(
                    service_name, 
                    quantity, 
                    f"RD$ {service_price:,.2f}", 
                    f"RD$ {total_price:,.2f}"
                ))
                print("DEBUG: Servicio agregado al invoice_services_tree para compatibilidad")
            
            # Actualizar totales
            if hasattr(self, 'calculate_totals'):
                self.calculate_totals()
                print("DEBUG: Totales actualizados")
            
            # Agregar al tree de servicios seleccionados
            if hasattr(self, 'selected_services_frame'):
                # Crear tarjeta de servicio en el panel de servicios seleccionados
                service_card = tk.Frame(self.selected_services_frame, bg='white', relief='solid', bd=1)
                service_card.pack(fill='x', padx=5, pady=2)
                
                # Contenido de la tarjeta
                content_frame = tk.Frame(service_card, bg='white')
                content_frame.pack(fill='x', padx=10, pady=8)
                
                # Nombre del servicio
                name_label = tk.Label(content_frame, text=service_name, 
                                     font=('Arial', 10, 'bold'), bg='white', fg='#1F2937')
                name_label.pack(anchor='w')
                
                # Detalles
                details_frame = tk.Frame(content_frame, bg='white')
                details_frame.pack(fill='x', pady=(2, 0))
                
                tk.Label(details_frame, text=f"Cantidad: {quantity}", 
                        font=('Arial', 9), bg='white', fg='#6B7280').pack(side='left')
                
                tk.Label(details_frame, text=f"RD$ {total_price:,.2f}", 
                        font=('Arial', 9, 'bold'), bg='white', fg='#059669').pack(side='right')
                
                # Bot√≥n eliminar
                def remove_service():
                    service_card.destroy()
                    self.update_billing_totals()
                
                tk.Button(details_frame, text="‚ùå", font=('Arial', 8), bg='white', fg='#DC2626',
                         border=0, cursor='hand2', command=remove_service).pack(side='right', padx=(5, 0))
            
            # Actualizar totales
            if hasattr(self, 'update_billing_totals'):
                self.update_billing_totals()
            
            # Cerrar di√°logo
            dialog.destroy()
            
            # Si agregamos a una factura existente, actualizar la tabla de facturas
            if invoice_selected and hasattr(self, 'load_existing_invoices'):
                self.load_existing_invoices()
                print("DEBUG: Tabla de facturas actualizada")
            
            # Mostrar confirmaci√≥n
            messagebox.showinfo("Servicio agregado", 
                              f"‚úÖ {service_name} (x{quantity}) agregado exitosamente")
        
        def add_custom_service():
            """Agregar servicio personalizado"""
            custom_dialog = tk.Toplevel(dialog)
            custom_dialog.title("‚ûï Servicio Personalizado")
            custom_dialog.geometry("400x250")
            custom_dialog.configure(bg='#F8FAFC')
            custom_dialog.transient(dialog)
            custom_dialog.grab_set()
            
            # Centrar
            custom_dialog.update_idletasks()
            x = (custom_dialog.winfo_screenwidth() // 2) - (400 // 2)
            y = (custom_dialog.winfo_screenheight() // 2) - (250 // 2)
            custom_dialog.geometry(f"400x250+{x}+{y}")
            
            tk.Label(custom_dialog, text="üîß Crear Servicio Personalizado", 
                    font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1F2937').pack(pady=20)
            
            tk.Label(custom_dialog, text="Nombre del servicio:", bg='#F8FAFC').pack(anchor='w', padx=20)
            custom_name_entry = tk.Entry(custom_dialog, font=('Arial', 11), width=40)
            custom_name_entry.pack(padx=20, pady=5)
            
            tk.Label(custom_dialog, text="Precio (RD$):", bg='#F8FAFC').pack(anchor='w', padx=20, pady=(10, 0))
            custom_price_entry = tk.Entry(custom_dialog, font=('Arial', 11), width=20)
            custom_price_entry.pack(padx=20, pady=5)
            
            def save_custom():
                name = custom_name_entry.get().strip()
                price_str = custom_price_entry.get().strip()
                
                if not name or not price_str:
                    messagebox.showwarning("Campos requeridos", "Complete todos los campos")
                    return
                
                try:
                    price = float(price_str)
                    if price <= 0:
                        raise ValueError("El precio debe ser mayor que 0")
                except ValueError:
                    messagebox.showerror("Error", "Ingrese un precio v√°lido")
                    return
                
                # Agregar a servicios personalizados
                if "üîß Personalizados" not in services_data:
                    services_data["üîß Personalizados"] = []
                
                services_data["üîß Personalizados"].append((name, price))
                
                # Actualizar combobox de categor√≠as
                category_combo['values'] = list(services_data.keys())
                
                custom_dialog.destroy()
                messagebox.showinfo("Servicio creado", f"‚úÖ {name} agregado a servicios personalizados")
            
            tk.Button(custom_dialog, text="üíæ Guardar Servicio", bg='#059669', fg='white',
                     font=('Arial', 10, 'bold'), command=save_custom).pack(pady=20)
        
        # Botones principales
        tk.Button(btn_frame, text="‚ûï Agregar al Carrito", bg='#059669', fg='white',
                 font=('Arial', 11, 'bold'), command=add_service, width=20).pack(side='left')
        
        tk.Button(btn_frame, text="üîß Servicio Personalizado", bg='#F59E0B', fg='white',
                 font=('Arial', 10), command=add_custom_service, width=20).pack(side='left', padx=(10, 0))
        
        tk.Button(btn_frame, text="‚ùå Cancelar", bg='#6B7280', fg='white',
                 font=('Arial', 11), command=dialog.destroy, width=15).pack(side='right')
        
        # Establecer foco inicial
        category_combo.focus_set()
        
        tk.Button(btn_frame, text="Agregar", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), command=add_service).pack(side='left', padx=5)
        tk.Button(btn_frame, text="Cancelar", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), command=dialog.destroy).pack(side='left', padx=5)
    
    def calculate_totals(self):
        """Calcular totales de la factura con descuentos por seguro"""
        subtotal = 0.0
        
        # Sumar todos los servicios
        for item in self.services_tree.get_children():
            values = self.services_tree.item(item)['values']
            price_str = values[1].replace('RD$ ', '').replace(',', '')
            try:
                price = float(price_str)
                subtotal += price
            except ValueError:
                continue
        
        # Verificar si aplica descuento por seguro
        descuento_seguro = 0.0
        doctor_acepta_seguro = False
        paciente_tiene_seguro = False
        cobertura_porcentaje = 0.0
        
        if hasattr(self, 'selected_doctor_info') and hasattr(self, 'selected_patient_info'):
            doctor_acepta_seguro = self.selected_doctor_info.get('acepta_seguros', False)
            paciente_tiene_seguro = bool(self.selected_patient_info.get('seguro'))
            cobertura_porcentaje = self.selected_patient_info.get('cobertura', 0.0)
            
            # Aplicar descuento solo si el doctor acepta seguros Y el paciente tiene seguro
            if doctor_acepta_seguro and paciente_tiene_seguro and cobertura_porcentaje > 0:
                descuento_seguro = subtotal * (cobertura_porcentaje / 100)
        
        # Subtotal despu√©s del descuento
        subtotal_con_descuento = subtotal - descuento_seguro
        
        # Calcular ITBIS (18%) sobre el monto despu√©s del descuento
        itbis = subtotal_con_descuento * 0.18
        total = subtotal_con_descuento + itbis
        
        # Actualizar labels con informaci√≥n detallada
        if descuento_seguro > 0:
            seguro_info = self.selected_patient_info.get('seguro', 'Seguro M√©dico')
            
            # Mostrar informaci√≥n completa
            self.subtotal_label.config(
                text=f"Subtotal: RD$ {subtotal:,.2f}\n" +
                     f"Desc. {seguro_info} ({cobertura_porcentaje}%): -RD$ {descuento_seguro:,.2f}\n" +
                     f"Subtotal Final: RD$ {subtotal_con_descuento:,.2f}",
                justify='left'
            )
        else:
            self.subtotal_label.config(text=f"RD$ {subtotal:,.2f}")
        
        self.itbis_label.config(text=f"RD$ {itbis:,.2f}")
        self.total_label.config(text=f"RD$ {total:,.2f}")
        
        # Guardar valores para usar en facturaci√≥n
        self.current_subtotal = subtotal
        self.current_descuento = descuento_seguro
        self.current_itbis = itbis
        self.current_total = total
    
    def generate_unique_invoice_number(self):
        """Generar un n√∫mero de factura √∫nico"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            fecha_actual = datetime.now()
            year = fecha_actual.strftime('%Y')
            
            # Buscar el √∫ltimo n√∫mero de factura del a√±o actual
            cursor.execute("""
                SELECT numero_factura FROM facturas 
                WHERE numero_factura LIKE ? 
                ORDER BY numero_factura DESC 
                LIMIT 1
            """, (f"FAC-{year}-%",))
            
            result = cursor.fetchone()
            
            if result:
                # Extraer el n√∫mero de secuencia del √∫ltimo n√∫mero de factura
                try:
                    last_number = int(result[0].split('-')[-1])
                    next_number = last_number + 1
                except:
                    next_number = 1
            else:
                next_number = 1
            
            # Generar n√∫mero con timestamp para garantizar unicidad
            timestamp = fecha_actual.strftime('%m%d%H%M%S')
            numero_factura = f"FAC-{year}-{str(next_number).zfill(4)}-{timestamp}"
            
            # Verificar que no existe (por seguridad)
            cursor.execute("SELECT COUNT(*) FROM facturas WHERE numero_factura = ?", (numero_factura,))
            if cursor.fetchone()[0] > 0:
                # Si por alguna raz√≥n existe, usar timestamp completo
                numero_factura = f"FAC-{year}-{fecha_actual.strftime('%m%d%H%M%S%f')[:14]}"
            
            cursor.close()
            conn.close()
            
            return numero_factura
            
        except Exception as e:
            print(f"Error generando n√∫mero de factura: {e}")
            # Fallback a timestamp completo
            fecha_actual = datetime.now()
            return f"FAC-{fecha_actual.strftime('%Y%m%d%H%M%S%f')[:17]}"
    
    def create_invoice_from_appointment(self):
        """Crear factura desde la cita seleccionada"""
        if not hasattr(self, 'selected_appointment_id'):
            messagebox.showwarning("Selecci√≥n requerida", "Seleccione una cita para facturar")
            return
        
        try:
            # Recopilar servicios
            services = []
            for item in self.services_tree.get_children():
                values = self.services_tree.item(item)['values']
                service_name = values[0]
                price_str = values[1].replace('RD$ ', '').replace(',', '')
                try:
                    price = float(price_str)
                    services.append({'nombre': service_name, 'precio': price})
                except ValueError:
                    continue
            
            if not services:
                messagebox.showwarning("Servicios requeridos", "Agregue al menos un servicio a la factura")
                return
            
            # Calcular totales
            subtotal = sum(s['precio'] for s in services)
            itbis = subtotal * 0.18
            total = subtotal + itbis
            
            # Obtener observaciones
            observations = self.observations_text.get("1.0", tk.END).strip()
            
            # Crear factura en la base de datos
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Obtener datos de la cita
            cursor.execute("""
                SELECT c.paciente_id, c.doctor_id, p.nombre, p.apellido 
                FROM citas c
                JOIN usuarios p ON c.paciente_id = p.id
                WHERE c.id = ?
            """, (self.selected_appointment_id,))
            
            cita_data = cursor.fetchone()
            
            if not cita_data:
                messagebox.showerror("Error", "No se encontraron datos de la cita")
                return
            
            # Generar n√∫mero de factura √∫nico
            fecha_actual = datetime.now()
            numero_factura = self.generate_unique_invoice_number()
            
            # Insertar factura
            cursor.execute("""
                INSERT INTO facturas (numero_factura, fecha_creacion, fecha_vencimiento, 
                                    paciente_id, concepto, monto, estado, cita_id, notas)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                numero_factura,
                fecha_actual.isoformat(),
                (fecha_actual + timedelta(days=30)).isoformat(),
                cita_data[0],
                f"Servicios m√©dicos - {', '.join([s['nombre'] for s in services[:2]])}{'...' if len(services) > 2 else ''}",
                total,
                'pendiente',
                self.selected_appointment_id,
                observations
            ))
            
            factura_id = cursor.lastrowid
            
            # Insertar detalles de servicios (si existe tabla de detalles)
            try:
                for service in services:
                    cursor.execute("""
                        INSERT INTO facturas_detalle (factura_id, servicio, precio, cantidad)
                        VALUES (?, ?, ?, ?)
                    """, (factura_id, service['nombre'], service['precio'], 1))
            except:
                # Si no existe tabla de detalles, continuar sin error
                pass
            
            conn.commit()
            cursor.close()
            conn.close()
            
            # Mostrar confirmaci√≥n
            messagebox.showinfo("Factura Creada", 
                              f"‚úÖ Factura {numero_factura} creada exitosamente\n\n"
                              f"Paciente: {cita_data[2]} {cita_data[3]}\n"
                              f"Total: RD$ {total:,.2f}\n"
                              f"Estado: Pendiente")
            
            # Limpiar formulario
            self.clear_invoice_form()
            
            # Refrescar lista de citas
            self.load_pending_appointments()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error creando factura: {str(e)}")
    
    def clear_invoice_form(self):
        """Limpiar formulario de factura"""
        # Limpiar servicios
        for item in self.services_tree.get_children():
            self.services_tree.delete(item)
        
        # Recargar servicios predeterminados
        self.load_default_services()
        
        # Limpiar observaciones
        self.observations_text.delete("1.0", tk.END)
        
        # Limpiar informaci√≥n de cita
        self.selected_appointment_info.config(text="Seleccione una cita para facturar", fg='#64748B')
        
        # Resetear totales
        self.subtotal_label.config(text="RD$ 0.00")
        self.itbis_label.config(text="RD$ 0.00")
        self.total_label.config(text="RD$ 0.00")
        
        # Limpiar selecci√≥n
        if hasattr(self, 'selected_appointment_id'):
            delattr(self, 'selected_appointment_id')
    
    def remove_service_from_invoice(self):
        """Quitar servicio seleccionado de la factura"""
        selection = self.services_tree.selection()
        if selection:
            self.services_tree.delete(selection[0])
            self.calculate_totals()
        else:
            messagebox.showwarning("Selecci√≥n requerida", "Seleccione un servicio para quitar")
    
    def edit_service_price(self):
        """Editar precio del servicio seleccionado"""
        selection = self.services_tree.selection()
        if not selection:
            messagebox.showwarning("Selecci√≥n requerida", "Seleccione un servicio para editar")
            return
        
        item = self.services_tree.item(selection[0])
        values = item['values']
        current_price = values[1].replace('RD$ ', '').replace(',', '')
        
        # Di√°logo para editar precio
        new_price = simpledialog.askfloat("Editar Precio", 
                                         f"Nuevo precio para '{values[0]}':",
                                         initialvalue=float(current_price))
        
        if new_price is not None and new_price > 0:
            self.services_tree.item(selection[0], values=(values[0], f"RD$ {new_price:,.2f}"))
            self.calculate_totals()
    
    def generate_invoice_pdf(self):
        """Generar PDF completo de la factura con ReportLab"""
        if not hasattr(self, 'selected_appointment_id') or not self.selected_appointment_id:
            messagebox.showwarning("Selecci√≥n requerida", "Por favor, seleccione una cita para facturar")
            return
        
        # Verificar que hay servicios agregados
        if not self.services_tree.get_children():
            messagebox.showwarning("Servicios requeridos", "Por favor, agregue al menos un servicio a la factura")
            return
        
        try:
            # Verificar si reportlab est√° disponible
            try:
                from reportlab.lib.pagesizes import letter, A4
                from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
                from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
                from reportlab.lib.units import inch
                from reportlab.lib import colors
                from reportlab.pdfgen import canvas
            except ImportError:
                messagebox.showerror("Error", "ReportLab no est√° instalado. Instalando...")
                self.install_reportlab()
                return
            
            # Crear directorio para PDFs
            pdf_dir = "facturas_pdf"
            if not os.path.exists(pdf_dir):
                os.makedirs(pdf_dir)
                
            # Obtener datos de la cita
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Obtener informaci√≥n de la cita y paciente
            cursor.execute("""
                SELECT c.id, c.fecha_hora, c.motivo, 
                       p.nombre, p.apellido, p.email, p.telefono,
                       d.nombre || ' ' || d.apellido as doctor_nombre,
                       dr.especialidad
                FROM citas c
                JOIN usuarios p ON c.paciente_id = p.id
                JOIN usuarios d ON c.doctor_id = d.id
                LEFT JOIN doctores dr ON d.id = dr.id
                WHERE c.id = ?
            """, (self.selected_appointment_id,))
            
            appointment_data = cursor.fetchone()
            
            if not appointment_data:
                messagebox.showerror("Error", "No se encontr√≥ informaci√≥n de la cita")
                return
                
            # Generar n√∫mero de factura √∫nico
            fecha_str = datetime.now().strftime('%Y%m%d%H%M%S')
            numero_factura = f"FAC-{fecha_str}"
            
            # Nombre del archivo
            paciente_nombre = f"{appointment_data[3]}_{appointment_data[4]}".replace(' ', '_')
            filename = f"Factura_{numero_factura}_{paciente_nombre}.pdf"
            filepath = os.path.join(pdf_dir, filename)
            
            # Crear el PDF
            doc = SimpleDocTemplate(filepath, pagesize=A4, rightMargin=72, leftMargin=72, 
                                   topMargin=72, bottomMargin=18)
            styles = getSampleStyleSheet()
            story = []
            
            # Estilo personalizado para el t√≠tulo
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=20,
                spaceAfter=30,
                textColor=colors.darkblue,
                alignment=1,  # Centrado
                fontName='Helvetica-Bold'
            )
            
            # Estilo para subt√≠tulos
            subtitle_style = ParagraphStyle(
                'CustomSubtitle',
                parent=styles['Heading2'],
                fontSize=14,
                spaceAfter=12,
                textColor=colors.darkblue,
                fontName='Helvetica-Bold'
            )
            
            # Header de la cl√≠nica
            story.append(Paragraph("üè• MEDISYNC", title_style))
            story.append(Paragraph("Sistema de Gesti√≥n M√©dica Integral", styles['Normal']))
            story.append(Paragraph("Tel: (809) 555-0123 | Email: info@medisync.com", styles['Normal']))
            story.append(Spacer(1, 20))
            
            # Informaci√≥n de la factura
            invoice_info = f"""
            <b>FACTURA M√âDICA</b><br/>
            <b>N√∫mero:</b> {numero_factura}<br/>
            <b>Fecha:</b> {datetime.now().strftime('%d/%m/%Y %H:%M')}<br/>
            <b>V√°lida hasta:</b> {(datetime.now() + timedelta(days=30)).strftime('%d/%m/%Y')}
            """
            story.append(Paragraph(invoice_info, subtitle_style))
            story.append(Spacer(1, 20))
            
            # Informaci√≥n del paciente y doctor
            patient_doctor_data = [
                ['DATOS DEL PACIENTE', 'DATOS DEL M√âDICO'],
                [f'Nombre: {appointment_data[3]} {appointment_data[4]}', f'Doctor: {appointment_data[7]}'],
                [f'Email: {appointment_data[5] or "No especificado"}', f'Especialidad: {appointment_data[8] or "General"}'],
                [f'Tel√©fono: {appointment_data[6] or "No especificado"}', f'Fecha Consulta: {appointment_data[1]}'],
                [f'Motivo: {appointment_data[2]}', '']
            ]
            
            patient_doctor_table = Table(patient_doctor_data, colWidths=[3*inch, 3*inch])
            patient_doctor_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.lightblue),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.lightgrey),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('VALIGN', (0, 0), (-1, -1), 'TOP')
            ]))
            
            story.append(patient_doctor_table)
            story.append(Spacer(1, 20))
            
            # Servicios m√©dicos
            story.append(Paragraph("SERVICIOS M√âDICOS", subtitle_style))
            
            # Recopilar servicios del TreeView
            services_data = [['Descripci√≥n del Servicio', 'Cantidad', 'Precio Unitario', 'Total']]
            subtotal = 0
            
            for item in self.services_tree.get_children():
                values = self.services_tree.item(item)['values']
                servicio = values[0]
                precio_str = str(values[1]).replace('RD$ ', '').replace(',', '')
                try:
                    precio = float(precio_str)
                    cantidad = 1  # Por defecto
                    total_servicio = precio * cantidad
                    subtotal += total_servicio
                    
                    services_data.append([
                        servicio,
                        str(cantidad),
                        f'RD$ {precio:,.2f}',
                        f'RD$ {total_servicio:,.2f}'
                    ])
                except ValueError:
                    # Si hay error convirtiendo precio, usar como est√°
                    services_data.append([servicio, '1', str(values[1]), str(values[1])])
            
            services_table = Table(services_data, colWidths=[3*inch, 0.8*inch, 1.1*inch, 1.1*inch])
            services_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 11),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('ALIGN', (3, 1), (3, -1), 'RIGHT'),  # Alinear totales a la derecha
            ]))
            
            story.append(services_table)
            story.append(Spacer(1, 20))
            
            # C√°lculos de totales
            descuento = 0
            if hasattr(self, 'discount_var') and self.discount_var.get():
                try:
                    descuento = float(self.discount_var.get().replace('%', ''))
                    descuento = subtotal * (descuento / 100)
                except:
                    descuento = 0
                    
            subtotal_con_descuento = subtotal - descuento
            itbis = subtotal_con_descuento * 0.18  # ITBIS 18%
            total_final = subtotal_con_descuento + itbis
            
            # Tabla de totales
            totals_data = [
                ['Subtotal:', f'RD$ {subtotal:,.2f}'],
            ]
            
            if descuento > 0:
                totals_data.append(['Descuento:', f'- RD$ {descuento:,.2f}'])
                totals_data.append(['Subtotal con descuento:', f'RD$ {subtotal_con_descuento:,.2f}'])
            
            totals_data.extend([
                ['ITBIS (18%):', f'RD$ {itbis:,.2f}'],
                ['TOTAL A PAGAR:', f'RD$ {total_final:,.2f}']
            ])
            
            totals_table = Table(totals_data, colWidths=[4*inch, 2*inch])
            totals_table.setStyle(TableStyle([
                ('ALIGN', (0, 0), (-1, -1), 'RIGHT'),
                ('FONTNAME', (0, 0), (-2, -1), 'Helvetica'),
                ('FONTNAME', (-2, -1), (-1, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-2, -1), 10),
                ('FONTSIZE', (-2, -1), (-1, -1), 12),
                ('BACKGROUND', (-2, -1), (-1, -1), colors.lightgrey),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('TEXTCOLOR', (-2, -1), (-1, -1), colors.darkblue),
            ]))
            
            story.append(totals_table)
            story.append(Spacer(1, 30))
            
            # Informaci√≥n de pago
            payment_info = """
            <b>INFORMACI√ìN DE PAGO:</b><br/>
            ‚Ä¢ Efectivo, Tarjeta de Cr√©dito/D√©bito aceptadas<br/>
            ‚Ä¢ Transferencia bancaria disponible<br/>
            ‚Ä¢ Consulte nuestros planes de financiamiento<br/>
            """
            story.append(Paragraph(payment_info, styles['Normal']))
            story.append(Spacer(1, 20))
            
            # Footer
            footer_text = f"""
            <b>¬°Gracias por confiar en MEDISYNC!</b><br/>
            Esta factura fue generada autom√°ticamente el {datetime.now().strftime('%d/%m/%Y a las %H:%M:%S')}<br/>
            Para consultas sobre esta factura, contacte a nuestro departamento de facturaci√≥n.<br/>
            <i>Documento v√°lido sin firma ni sello seg√∫n resoluci√≥n tributaria.</i>
            """
            story.append(Paragraph(footer_text, styles['Normal']))
            
            # Construir el PDF
            doc.build(story)
            
            # Guardar informaci√≥n de la factura en la base de datos
            try:
                cursor.execute("""
                    INSERT INTO facturas (
                        paciente_id, cita_id, numero_factura, concepto, monto, 
                        estado, fecha_creacion, fecha_vencimiento, notas, 
                        doctor_id, tipo_consulta, moneda
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    appointment_data[0],  # Usar el ID del paciente de la cita
                    self.selected_appointment_id,
                    numero_factura,
                    f"Consulta m√©dica - {appointment_data[2]}",
                    total_final,
                    'pendiente',
                    datetime.now().isoformat(),
                    (datetime.now() + timedelta(days=30)).isoformat(),
                    f"Factura generada para consulta con {appointment_data[7]}",
                    appointment_data[0],  # ID del doctor (simplificado)
                    appointment_data[8] or 'Consulta General',
                    'RD$'
                ))
                
                conn.commit()
                
            except Exception as db_error:
                print(f"Error guardando en BD: {db_error}")
                # Continuar a√∫n si hay error en BD
            
            cursor.close()
            conn.close()
            
            # Mostrar mensaje de √©xito y abrir PDF
            result = messagebox.askquestion(
                "PDF Generado Exitosamente", 
                f"Factura guardada como: {filename}\n\n¬øDesea abrir el PDF ahora?",
                icon='question'
            )
            
            if result == 'yes':
                try:
                    os.startfile(filepath)  # Windows
                except:
                    try:
                        os.system(f'open "{filepath}"')  # macOS
                    except:
                        try:
                            os.system(f'xdg-open "{filepath}"')  # Linux
                        except:
                            messagebox.showinfo("PDF Guardado", f"Archivo guardado en:\n{os.path.abspath(filepath)}")
            
        except ImportError:
            messagebox.showwarning("Dependencia requerida", 
                                 "ReportLab no est√° instalado.\n\nInstalando autom√°ticamente...")
            self.install_reportlab()
        except Exception as e:
            messagebox.showerror("Error", f"Error generando PDF: {str(e)}")
            print(f"Error detallado: {e}")
    
    def open_payment_window(self):
        """Abrir ventana de procesamiento de pagos amigable"""
        if not hasattr(self, 'selected_appointment_id') or not self.selected_appointment_id:
            messagebox.showwarning("Selecci√≥n requerida", "Por favor, seleccione una cita primero")
            return
        
        # Verificar que hay servicios agregados
        if not self.services_tree.get_children():
            messagebox.showwarning("Servicios requeridos", "Por favor, agregue al menos un servicio a la factura")
            return
        
        # Calcular totales actuales
        self.calculate_totals()
        
        # Obtener el total de la etiqueta
        total_text = self.total_label.cget('text')
        try:
            total_amount = float(total_text.replace('RD$ ', '').replace(',', ''))
        except:
            messagebox.showerror("Error", "No se pudo calcular el total de la factura")
            return
        
        # Crear ventana de pago
        self.create_payment_window(total_amount)
    
    def create_payment_window(self, total_amount):
        """Crear ventana moderna de procesamiento de pagos con scroll"""
        # Ventana principal
        payment_window = tk.Toplevel(self.root)
        payment_window.title("üí≥ Procesamiento de Pago - MEDISYNC")
        payment_window.geometry("850x600")
        payment_window.configure(bg='#FFFFFF')
        payment_window.resizable(True, True)
        payment_window.transient(self.root)
        payment_window.grab_set()
        
        # Centrar ventana
        payment_window.update_idletasks()
        x = (payment_window.winfo_screenwidth() // 2) - (850 // 2)
        y = (payment_window.winfo_screenheight() // 2) - (600 // 2)
        payment_window.geometry(f"850x600+{x}+{y}")
        
        # Canvas y scrollbar para hacer scroll
        canvas = tk.Canvas(payment_window, bg='#FFFFFF')
        scrollbar = ttk.Scrollbar(payment_window, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#FFFFFF')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Layout del canvas y scrollbar
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Frame principal dentro del scrollable_frame
        main_frame = tk.Frame(scrollable_frame, bg='#FFFFFF')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Header elegante
        header_frame = tk.Frame(main_frame, bg='#1E3A8A', height=80)
        header_frame.pack(fill='x', pady=(0, 20))
        header_frame.pack_propagate(False)
        
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=30, pady=15)
        
        tk.Label(header_content, text="üí≥", font=('Arial', 24), bg='#1E3A8A', fg='white').pack(side='left')
        
        title_frame = tk.Frame(header_content, bg='#1E3A8A')
        title_frame.pack(side='left', fill='both', expand=True, padx=(15, 0))
        
        tk.Label(title_frame, text="PROCESAMIENTO DE PAGO", 
                font=('Arial', 16, 'bold'), bg='#1E3A8A', fg='white').pack(anchor='w')
        tk.Label(title_frame, text="Complete la informaci√≥n del pago para generar la factura", 
                font=('Arial', 11), bg='#1E3A8A', fg='#CBD5E1').pack(anchor='w')
        
        # Informaci√≥n de la factura
        invoice_info_frame = tk.LabelFrame(main_frame, text="üßæ Informaci√≥n de la Factura", 
                                         font=('Arial', 12, 'bold'), bg='#FFFFFF', fg='#1E3A8A',
                                         padx=20, pady=15)
        invoice_info_frame.pack(fill='x', pady=(0, 20))
        
        # Obtener informaci√≥n del paciente
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            cursor.execute("""
                SELECT p.nombre || ' ' || p.apellido as paciente,
                       d.nombre || ' ' || d.apellido as doctor,
                       c.motivo, c.fecha_hora
                FROM citas c
                JOIN usuarios p ON c.paciente_id = p.id
                JOIN usuarios d ON c.doctor_id = d.id
                WHERE c.id = ?
            """, (self.selected_appointment_id,))
            
            appointment_info = cursor.fetchone()
            cursor.close()
            conn.close()
            
            if appointment_info:
                paciente, doctor, motivo, fecha_hora = appointment_info
                
                info_grid = tk.Frame(invoice_info_frame, bg='#FFFFFF')
                info_grid.pack(fill='x')
                
                # Primera fila
                tk.Label(info_grid, text="üë§ Paciente:", font=('Arial', 11, 'bold'), 
                        bg='#FFFFFF').grid(row=0, column=0, sticky='w', padx=(0, 10), pady=5)
                tk.Label(info_grid, text=paciente, font=('Arial', 11), 
                        bg='#FFFFFF', fg='#1E3A8A').grid(row=0, column=1, sticky='w', pady=5)
                
                tk.Label(info_grid, text="üë®‚Äç‚öïÔ∏è Doctor:", font=('Arial', 11, 'bold'), 
                        bg='#FFFFFF').grid(row=0, column=2, sticky='w', padx=(30, 10), pady=5)
                tk.Label(info_grid, text=doctor, font=('Arial', 11), 
                        bg='#FFFFFF', fg='#1E3A8A').grid(row=0, column=3, sticky='w', pady=5)
                
                # Segunda fila
                tk.Label(info_grid, text="üè• Motivo:", font=('Arial', 11, 'bold'), 
                        bg='#FFFFFF').grid(row=1, column=0, sticky='w', padx=(0, 10), pady=5)
                tk.Label(info_grid, text=motivo, font=('Arial', 11), 
                        bg='#FFFFFF', fg='#1E3A8A').grid(row=1, column=1, columnspan=3, sticky='w', pady=5)
                
        except Exception as e:
            print(f"Error obteniendo informaci√≥n: {e}")
        
        # Servicios incluidos
        services_frame = tk.LabelFrame(main_frame, text="üè• Servicios Incluidos", 
                                     font=('Arial', 12, 'bold'), bg='#FFFFFF', fg='#1E3A8A',
                                     padx=15, pady=10)
        services_frame.pack(fill='x', pady=(0, 20))
        
        # Lista de servicios
        services_list_frame = tk.Frame(services_frame, bg='white', relief='solid', bd=1)
        services_list_frame.pack(fill='x', pady=(10, 0))
        
        for item in self.services_tree.get_children():
            values = self.services_tree.item(item)['values']
            service_item = tk.Frame(services_list_frame, bg='white')
            service_item.pack(fill='x', padx=15, pady=5)
            
            tk.Label(service_item, text=f"‚Ä¢ {values[0]}", font=('Arial', 10), 
                    bg='white', fg='#1E3A8A').pack(side='left')
            tk.Label(service_item, text=f"{values[1]}", font=('Arial', 10, 'bold'), 
                    bg='white', fg='#16A085').pack(side='right')
        
        # Totales destacados
        totals_frame = tk.LabelFrame(main_frame, text="üí∞ Totales de Facturaci√≥n", 
                                   font=('Arial', 12, 'bold'), bg='#FFFFFF', fg='#1E3A8A',
                                   padx=20, pady=15)
        totals_frame.pack(fill='x', pady=(0, 20))
        
        # C√°lculos
        subtotal = total_amount / 1.18  # Quitar ITBIS para obtener subtotal
        itbis = total_amount - subtotal
        
        # Mostrar totales con estilo
        totals_grid = tk.Frame(totals_frame, bg='#FFFFFF')
        totals_grid.pack(fill='x')
        
        # Subtotal
        tk.Label(totals_grid, text="Subtotal:", font=('Arial', 12), bg='#FFFFFF').grid(row=0, column=0, sticky='w', pady=5)
        tk.Label(totals_grid, text=f"RD$ {subtotal:,.2f}", font=('Arial', 12), bg='#FFFFFF', fg='#1E3A8A').grid(row=0, column=1, sticky='e', pady=5)
        
        # ITBIS
        tk.Label(totals_grid, text="ITBIS (18%):", font=('Arial', 12), bg='#FFFFFF').grid(row=1, column=0, sticky='w', pady=5)
        tk.Label(totals_grid, text=f"RD$ {itbis:,.2f}", font=('Arial', 12), bg='#FFFFFF', fg='#1E3A8A').grid(row=1, column=1, sticky='e', pady=5)
        
        # Separador
        separator = tk.Frame(totals_grid, bg='#CBD5E1', height=2)
        separator.grid(row=2, column=0, columnspan=2, sticky='ew', pady=10)
        
        # Total
        tk.Label(totals_grid, text="TOTAL A PAGAR:", font=('Arial', 14, 'bold'), bg='#FFFFFF').grid(row=3, column=0, sticky='w', pady=5)
        total_amount_label = tk.Label(totals_grid, text=f"RD$ {total_amount:,.2f}", 
                                    font=('Arial', 16, 'bold'), bg='#FFFFFF', fg='#C0392B')
        total_amount_label.grid(row=3, column=1, sticky='e', pady=5)
        
        totals_grid.grid_columnconfigure(1, weight=1)
        
        # Frame de pago
        payment_details_frame = tk.LabelFrame(main_frame, text="üí≥ Detalles del Pago", 
                                            font=('Arial', 12, 'bold'), bg='#FFFFFF', fg='#1E3A8A',
                                            padx=20, pady=15)
        payment_details_frame.pack(fill='x', pady=(0, 20))
        
        payment_grid = tk.Frame(payment_details_frame, bg='#FFFFFF')
        payment_grid.pack(fill='x', pady=10)
        
        # Monto recibido del paciente
        tk.Label(payment_grid, text="üíµ Monto Recibido:", font=('Arial', 12, 'bold'), 
                bg='#FFFFFF').grid(row=0, column=0, sticky='w', pady=10)
        
        self.amount_received_var = tk.StringVar()
        amount_entry = tk.Entry(payment_grid, textvariable=self.amount_received_var, 
                              font=('Arial', 14, 'bold'), width=15, justify='center',
                              relief='solid', bd=2)
        amount_entry.grid(row=0, column=1, padx=(10, 0), pady=10)
        amount_entry.focus()
        
        # M√©todo de pago
        tk.Label(payment_grid, text="üí≥ M√©todo de Pago:", font=('Arial', 12, 'bold'), 
                bg='#FFFFFF').grid(row=1, column=0, sticky='w', pady=10)
        
        self.payment_method_var = tk.StringVar(value="Efectivo")
        payment_method_combo = ttk.Combobox(payment_grid, textvariable=self.payment_method_var,
                                          values=["Efectivo", "Tarjeta de Cr√©dito", "Tarjeta de D√©bito", 
                                                "Transferencia Bancaria", "Cheque"], 
                                          state="readonly", width=20, font=('Arial', 11))
        payment_method_combo.grid(row=1, column=1, padx=(10, 0), pady=10, sticky='w')
        
        # C√°lculo autom√°tico del cambio
        change_frame = tk.LabelFrame(main_frame, text="üí∏ C√°lculo de Cambio", 
                                   font=('Arial', 12, 'bold'), bg='#FFFFFF', fg='#1E3A8A',
                                   padx=20, pady=15)
        change_frame.pack(fill='x', pady=(0, 20))
        
        change_display = tk.Frame(change_frame, bg='#FFFFFF')
        change_display.pack(fill='x', pady=10)
        
        self.change_status_label = tk.Label(change_display, text="Ingrese el monto recibido", 
                                          font=('Arial', 14, 'bold'), bg='#FFFFFF', fg='#64748B')
        self.change_status_label.pack()
        
        self.change_amount_label = tk.Label(change_display, text="", 
                                          font=('Arial', 18, 'bold'), bg='#FFFFFF')
        self.change_amount_label.pack(pady=(10, 0))
        
        # Funci√≥n para calcular cambio en tiempo real
        def calculate_change(*args):
            try:
                received = float(self.amount_received_var.get() or 0)
                change = received - total_amount
                
                if received == 0:
                    self.change_status_label.config(text="Ingrese el monto recibido", fg='#64748B')
                    self.change_amount_label.config(text="")
                elif change >= 0:
                    self.change_status_label.config(text="üí∞ CAMBIO A DEVOLVER:", fg='#16A085')
                    self.change_amount_label.config(text=f"RD$ {change:,.2f}", fg='#16A085')
                else:
                    self.change_status_label.config(text="‚ùå MONTO INSUFICIENTE:", fg='#C0392B')
                    self.change_amount_label.config(text=f"Faltan: RD$ {abs(change):,.2f}", fg='#C0392B')
            except ValueError:
                self.change_status_label.config(text="‚ö†Ô∏è Ingrese un monto v√°lido", fg='#E67E22')
                self.change_amount_label.config(text="")
        
        self.amount_received_var.trace('w', calculate_change)
        
        # Botones de acci√≥n
        buttons_frame = tk.Frame(main_frame, bg='#FFFFFF')
        buttons_frame.pack(fill='x', pady=(20, 0))
        
        # Bot√≥n Cancelar
        cancel_btn = tk.Button(buttons_frame, text="‚ùå Cancelar", 
                             command=payment_window.destroy,
                             bg='#0B5394', fg='white', font=('Arial', 12, 'bold'),
                             width=15, pady=10, relief='raised', bd=3)
        cancel_btn.pack(side='left')
        
        # Bot√≥n Procesar y Generar PDF
        def process_payment_and_generate():
            try:
                received = float(self.amount_received_var.get() or 0)
                if received < total_amount:
                    messagebox.showwarning("Pago Insuficiente", 
                                         f"El monto recibido (RD$ {received:,.2f}) es menor al total a pagar (RD$ {total_amount:,.2f})")
                    return
                
                # Crear la factura en la base de datos
                invoice_id = self.create_invoice_in_database(total_amount, received)
                
                if invoice_id:
                    # Generar PDF autom√°ticamente
                    self.generate_final_invoice_pdf(invoice_id, total_amount, received)
                    
                    # Mostrar mensaje de √©xito
                    change = received - total_amount
                    success_msg = f"‚úÖ Pago procesado exitosamente!\n\n"
                    success_msg += f"Total: RD$ {total_amount:,.2f}\n"
                    success_msg += f"Recibido: RD$ {received:,.2f}\n"
                    if change > 0:
                        success_msg += f"Cambio: RD$ {change:,.2f}\n"
                    success_msg += f"\nüìÑ PDF generado autom√°ticamente"
                    
                    messagebox.showinfo("Pago Completado", success_msg)
                    
                    # Cerrar ventana y actualizar listas
                    payment_window.destroy()
                    self.load_existing_invoices()
                    # Actualizar tabla de citas para facturar para que desaparezca la cita procesada
                    print("üîÑ DEBUG: Llamando load_appointments_for_billing() despu√©s del pago")
                    self.load_appointments_for_billing()
                    self.clear_invoice_form()
                
            except ValueError:
                messagebox.showerror("Error", "Por favor ingrese un monto v√°lido")
            except Exception as e:
                messagebox.showerror("Error", f"Error procesando el pago: {str(e)}")
        
        process_btn = tk.Button(buttons_frame, text="üí≥ PROCESAR PAGO Y GENERAR PDF", 
                              command=process_payment_and_generate,
                              bg='#0B5394', fg='white', font=('Arial', 12, 'bold'),
                              width=35, pady=10, relief='raised', bd=3)
        process_btn.pack(side='right')
        
        # Guardar referencias para uso posterior
        payment_window.total_amount = total_amount
        self.current_payment_window = payment_window
    
    def create_invoice_in_database(self, total_amount, amount_received):
        """Crear factura en la base de datos"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Generar n√∫mero de factura √∫nico
            fecha_str = datetime.now().strftime('%Y%m%d%H%M%S')
            numero_factura = f"FAC-{fecha_str}"
            
            # Obtener informaci√≥n de la cita
            cursor.execute("""
                SELECT paciente_id, doctor_id, motivo 
                FROM citas 
                WHERE id = ?
            """, (self.selected_appointment_id,))
            
            cita_info = cursor.fetchone()
            if not cita_info:
                raise Exception("No se encontr√≥ informaci√≥n de la cita")
            
            paciente_id, doctor_id, motivo = cita_info
            
            # Determinar estado del pago
            change = amount_received - total_amount
            estado = 'pagado' if change >= 0 else 'pago_parcial'
            
            # Crear concepto basado en servicios
            servicios = []
            for item in self.services_tree.get_children():
                values = self.services_tree.item(item)['values']
                servicios.append(values[0])
            
            concepto = f"Consulta m√©dica - {motivo}" if servicios else motivo
            if servicios:
                concepto += f"\nServicios: {', '.join(servicios)}"
            
            # Insertar factura
            cursor.execute("""
                INSERT INTO facturas (
                    paciente_id, cita_id, numero_factura, concepto, monto, 
                    estado, fecha_creacion, fecha_vencimiento, notas, 
                    doctor_id, tipo_consulta, moneda, metodo_pago, fecha_pago
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                paciente_id,
                self.selected_appointment_id,
                numero_factura,
                concepto,
                total_amount,
                estado,
                datetime.now().isoformat(),
                (datetime.now() + timedelta(days=30)).isoformat(),
                f"Pago procesado - Recibido: RD$ {amount_received:,.2f}, Cambio: RD$ {change:,.2f}",
                doctor_id,
                motivo,
                'RD$',
                self.payment_method_var.get(),
                datetime.now().isoformat()
            ))
            
            # Obtener ID de la factura creada
            invoice_id = cursor.lastrowid
            
            # Insertar detalles de servicios en facturas_detalle
            for item in self.services_tree.get_children():
                values = self.services_tree.item(item)['values']
                servicio = values[0]
                precio_str = str(values[1]).replace('RD$ ', '').replace(',', '')
                try:
                    precio = float(precio_str)
                    cursor.execute("""
                        INSERT INTO facturas_detalle (
                            factura_id, servicio, cantidad, precio
                        ) VALUES (?, ?, ?, ?)
                    """, (invoice_id, servicio, 1, precio))
                except ValueError:
                    # Si hay error convirtiendo precio, usar 0
                    cursor.execute("""
                        INSERT INTO facturas_detalle (
                            factura_id, servicio, cantidad, precio
                        ) VALUES (?, ?, ?, ?)
                    """, (invoice_id, servicio, 1, 0))
            
            conn.commit()
            cursor.close()
            conn.close()
            
            return invoice_id
            
        except Exception as e:
            print(f"Error creando factura en BD: {e}")
            messagebox.showerror("Error", f"Error creando factura: {str(e)}")
            return None
    
    def generate_final_invoice_pdf(self, invoice_id, total_amount, amount_received):
        """Generar PDF final con informaci√≥n completa de pago"""
        try:
            # Verificar que reportlab est√© disponible
            try:
                from reportlab.lib.pagesizes import A4
                from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
                from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
                from reportlab.lib.units import inch
                from reportlab.lib import colors
            except ImportError:
                messagebox.showerror("Error", "ReportLab no est√° disponible para generar PDF")
                return
            
            # Crear directorio para PDFs
            pdf_dir = "facturas_pdf"
            if not os.path.exists(pdf_dir):
                os.makedirs(pdf_dir)
            
            # Obtener informaci√≥n completa de la factura
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT f.numero_factura, f.fecha_creacion, f.monto, f.concepto, 
                       f.metodo_pago, f.fecha_pago, f.notas,
                       p.nombre, p.apellido, p.email, p.telefono,
                       d.nombre as doctor_nombre, d.apellido as doctor_apellido,
                       dr.especialidad
                FROM facturas f
                JOIN usuarios p ON f.paciente_id = p.id
                JOIN usuarios d ON f.doctor_id = d.id
                LEFT JOIN doctores dr ON d.id = dr.id
                WHERE f.id = ?
            """, (invoice_id,))
            
            factura_data = cursor.fetchone()
            if not factura_data:
                raise Exception("No se encontr√≥ la factura generada")
            
            # Obtener detalles de servicios
            cursor.execute("""
                SELECT servicio, cantidad, precio, (precio * cantidad) as total
                FROM facturas_detalle
                WHERE factura_id = ?
            """, (invoice_id,))
            
            servicios_detalle = cursor.fetchall()
            
            cursor.close()
            conn.close()
            
            # Desempaquetar datos
            (numero_factura, fecha_creacion, monto, concepto, metodo_pago, fecha_pago, notas,
             nombre_paciente, apellido_paciente, email, telefono,
             doctor_nombre, doctor_apellido, especialidad) = factura_data
            
            # Generar nombre del archivo
            paciente_nombre = f"{nombre_paciente}_{apellido_paciente}".replace(' ', '_')
            filename = f"Factura_{numero_factura}_{paciente_nombre}.pdf"
            filepath = os.path.join(pdf_dir, filename)
            
            # Crear el PDF
            doc = SimpleDocTemplate(filepath, pagesize=A4, rightMargin=72, leftMargin=72, 
                                   topMargin=72, bottomMargin=18)
            styles = getSampleStyleSheet()
            story = []
            
            # Estilos personalizados
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=20,
                spaceAfter=30,
                textColor=colors.darkblue,
                alignment=1,
                fontName='Helvetica-Bold'
            )
            
            subtitle_style = ParagraphStyle(
                'CustomSubtitle',
                parent=styles['Heading2'],
                fontSize=14,
                spaceAfter=12,
                textColor=colors.darkblue,
                fontName='Helvetica-Bold'
            )
            
            # Header de la cl√≠nica
            story.append(Paragraph("üè• MEDISYNC", title_style))
            story.append(Paragraph("Sistema de Gesti√≥n M√©dica Integral", styles['Normal']))
            story.append(Paragraph("Tel: (809) 555-0123 | Email: info@medisync.com", styles['Normal']))
            story.append(Spacer(1, 20))
            
            # Informaci√≥n de la factura con estado PAGADA
            fecha_obj = datetime.fromisoformat(fecha_creacion)
            invoice_info = f"""
            <b>FACTURA M√âDICA - ‚úÖ PAGADA</b><br/>
            <b>N√∫mero:</b> {numero_factura}<br/>
            <b>Fecha de Emisi√≥n:</b> {fecha_obj.strftime('%d/%m/%Y %H:%M')}<br/>
            <b>Fecha de Pago:</b> {datetime.now().strftime('%d/%m/%Y %H:%M')}<br/>
            <b>M√©todo de Pago:</b> {metodo_pago}
            """
            story.append(Paragraph(invoice_info, subtitle_style))
            story.append(Spacer(1, 20))
            
            # Informaci√≥n del paciente y doctor
            patient_doctor_data = [
                ['DATOS DEL PACIENTE', 'DATOS DEL M√âDICO'],
                [f'Nombre: {nombre_paciente} {apellido_paciente}', f'Doctor: {doctor_nombre} {doctor_apellido}'],
                [f'Email: {email or "No especificado"}', f'Especialidad: {especialidad or "General"}'],
                [f'Tel√©fono: {telefono or "No especificado"}', '']
            ]
            
            patient_doctor_table = Table(patient_doctor_data, colWidths=[3*inch, 3*inch])
            patient_doctor_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.lightblue),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.lightgrey),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('VALIGN', (0, 0), (-1, -1), 'TOP')
            ]))
            
            story.append(patient_doctor_table)
            story.append(Spacer(1, 20))
            
            # Servicios m√©dicos
            story.append(Paragraph("SERVICIOS M√âDICOS", subtitle_style))
            
            # Tabla de servicios
            services_data = [['Descripci√≥n del Servicio', 'Cantidad', 'Precio Unitario', 'Total']]
            
            for servicio in servicios_detalle:
                servicio_nombre, cantidad, precio_unitario, total_servicio = servicio
                services_data.append([
                    servicio_nombre,
                    str(int(cantidad)),
                    f'RD$ {float(precio_unitario):,.2f}',
                    f'RD$ {float(total_servicio):,.2f}'
                ])
            
            services_table = Table(services_data, colWidths=[3*inch, 0.8*inch, 1.1*inch, 1.1*inch])
            services_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 11),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('ALIGN', (3, 1), (3, -1), 'RIGHT'),
            ]))
            
            story.append(services_table)
            story.append(Spacer(1, 20))
            
            # C√°lculos de totales
            subtotal = total_amount / 1.18
            itbis = total_amount - subtotal
            change = amount_received - total_amount
            
            # Tabla de totales con informaci√≥n de pago
            totals_data = [
                ['Subtotal:', f'RD$ {subtotal:,.2f}'],
                ['ITBIS (18%):', f'RD$ {itbis:,.2f}'],
                ['TOTAL A PAGAR:', f'RD$ {total_amount:,.2f}'],
                ['', ''],
                ['MONTO RECIBIDO:', f'RD$ {amount_received:,.2f}'],
                ['CAMBIO DEVUELTO:', f'RD$ {change:,.2f}' if change > 0 else 'RD$ 0.00']
            ]
            
            totals_table = Table(totals_data, colWidths=[4*inch, 2*inch])
            totals_table.setStyle(TableStyle([
                ('ALIGN', (0, 0), (-1, -1), 'RIGHT'),
                ('FONTNAME', (0, 0), (-1, 2), 'Helvetica'),
                ('FONTNAME', (0, 2), (-1, 2), 'Helvetica-Bold'),
                ('FONTNAME', (0, 4), (-1, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 1), 10),
                ('FONTSIZE', (0, 2), (-1, 2), 12),
                ('FONTSIZE', (0, 4), (-1, -1), 11),
                ('BACKGROUND', (0, 2), (-1, 2), colors.lightgrey),
                ('BACKGROUND', (0, 4), (-1, -1), colors.lightgreen),
                ('GRID', (0, 0), (-1, 2), 1, colors.black),
                ('GRID', (0, 4), (-1, -1), 1, colors.black),
                ('TEXTCOLOR', (0, 2), (-1, 2), colors.darkblue),
                ('TEXTCOLOR', (0, 4), (-1, -1), colors.darkgreen),
            ]))
            
            story.append(totals_table)
            story.append(Spacer(1, 30))
            
            # Estado de pago
            payment_status = f"""
            <b>‚úÖ ESTADO DEL PAGO: COMPLETADO</b><br/>
            M√©todo de pago: {metodo_pago}<br/>
            Fecha y hora de pago: {datetime.now().strftime('%d/%m/%Y a las %H:%M:%S')}<br/>
            """
            story.append(Paragraph(payment_status, styles['Normal']))
            story.append(Spacer(1, 20))
            
            # Footer
            footer_text = f"""
            <b>¬°Gracias por confiar en MEDISYNC!</b><br/>
            Esta factura ha sido pagada en su totalidad.<br/>
            Para consultas sobre esta factura, contacte a nuestro departamento de facturaci√≥n.<br/>
            <i>Documento v√°lido sin firma ni sello seg√∫n resoluci√≥n tributaria.</i>
            """
            story.append(Paragraph(footer_text, styles['Normal']))
            
            # Construir el PDF
            doc.build(story)
            
            # Abrir el PDF autom√°ticamente
            try:
                os.startfile(filepath)  # Windows
            except:
                try:
                    os.system(f'open "{filepath}"')  # macOS
                except:
                    try:
                        os.system(f'xdg-open "{filepath}"')  # Linux
                    except:
                        pass
            
            return filepath
            
        except Exception as e:
            print(f"Error generando PDF final: {e}")
            messagebox.showerror("Error", f"Error generando PDF: {str(e)}")
            return None
    
    def process_payment_window(self):
        """Abrir ventana de procesamiento de pagos para factura existente"""
        # Verificar que la tabla existe
        if not hasattr(self, 'billing_invoices_tree') or not self.billing_invoices_tree:
            messagebox.showerror("Error", "No se encontr√≥ la tabla de facturas generadas")
            return
            
        selection = self.billing_invoices_tree.selection()
        if not selection:
            messagebox.showwarning("Selecci√≥n requerida", 
                "Por favor, seleccione una factura de la tabla 'Facturas Generadas' haciendo clic en una fila")
            return
        
        # Obtener informaci√≥n de la factura seleccionada
        item = selection[0]
        values = self.billing_invoices_tree.item(item, 'values')
        
        if not values or len(values) < 3:
            messagebox.showerror("Error", "No se pudo obtener la informaci√≥n de la factura seleccionada")
            return
            
        numero_factura = values[0]
        estado_mostrado = values[4] if len(values) > 4 else "No disponible"  # Columna de estado
        
        print(f"DEBUG: Procesando pago para factura {numero_factura}, estado: {estado_mostrado}")
        
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, monto, estado
                FROM facturas
                WHERE numero_factura = ?
            """, (numero_factura,))
            
            factura_info = cursor.fetchone()
            if not factura_info:
                messagebox.showerror("Error", f"No se encontr√≥ la factura #{numero_factura} en la base de datos")
                return
            
            factura_id, monto, estado = factura_info
            
            # Verificar que la factura est√© pendiente
            if estado == 'pagado':
                messagebox.showwarning("‚ùå Factura ya pagada", 
                    f"La factura #{numero_factura} ya est√° pagada.\n\n"
                    "üí° Solo puede procesar pagos para facturas con estado '‚è≥ Pendiente'.")
                return
            
            # Confirmar que quiere procesar el pago
            confirm = messagebox.askyesno("üí≥ Confirmar procesamiento", 
                f"¬øProcesar pago para la factura #{numero_factura}?\n\n"
                f"Monto: RD$ {monto:,.2f}\n"
                f"Estado actual: {estado_mostrado}")
            
            if confirm:
                # Abrir ventana de pago para factura existente
                self.create_existing_invoice_payment_window(factura_id, float(monto))
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error procesando pago: {str(e)}")
    
    def create_existing_invoice_payment_window(self, invoice_id, total_amount):
        """Crear ventana de pago para factura existente"""
        # Ventana principal
        payment_window = tk.Toplevel(self.root)
        payment_window.title("üí≥ Procesar Pago - Factura Existente")
        payment_window.geometry("750x500")
        payment_window.configure(bg='#FFFFFF')
        payment_window.resizable(True, True)
        payment_window.transient(self.root)
        payment_window.grab_set()
        
        # Centrar ventana
        payment_window.update_idletasks()
        x = (payment_window.winfo_screenwidth() // 2) - (750 // 2)
        y = (payment_window.winfo_screenheight() // 2) - (500 // 2)
        payment_window.geometry(f"750x500+{x}+{y}")
        
        # Frame principal
        main_frame = tk.Frame(payment_window, bg='#FFFFFF')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Header elegante
        header_frame = tk.Frame(main_frame, bg='#1E3A8A', height=80)
        header_frame.pack(fill='x', pady=(0, 20))
        header_frame.pack_propagate(False)
        
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=30, pady=15)
        
        tk.Label(header_content, text="üí≥", font=('Arial', 24), bg='#1E3A8A', fg='white').pack(side='left')
        
        title_frame = tk.Frame(header_content, bg='#1E3A8A')
        title_frame.pack(side='left', fill='both', expand=True, padx=(15, 0))
        
        tk.Label(title_frame, text="PROCESAR PAGO", 
                font=('Arial', 16, 'bold'), bg='#1E3A8A', fg='white').pack(anchor='w')
        tk.Label(title_frame, text=f"Factura existente - ID: {invoice_id}", 
                font=('Arial', 11), bg='#1E3A8A', fg='#CBD5E1').pack(anchor='w')
        
        # Informaci√≥n de la factura
        invoice_info_frame = tk.LabelFrame(main_frame, text="üßæ Informaci√≥n de la Factura", 
                                         font=('Arial', 12, 'bold'), bg='#FFFFFF', fg='#1E3A8A',
                                         padx=20, pady=15)
        invoice_info_frame.pack(fill='x', pady=(0, 20))
        
        # Obtener informaci√≥n detallada de la factura
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            cursor.execute("""
                SELECT f.numero_factura, f.fecha, 
                       p.nombre || ' ' || p.apellido as paciente,
                       d.nombre || ' ' || d.apellido as doctor
                FROM facturas f
                LEFT JOIN usuarios p ON f.paciente_id = p.id
                LEFT JOIN usuarios d ON f.doctor_id = d.id
                WHERE f.id = ?
            """, (invoice_id,))
            
            invoice_detail = cursor.fetchone()
            cursor.close()
            conn.close()
            
            if invoice_detail:
                numero_factura, fecha, paciente, doctor = invoice_detail
                
                info_grid = tk.Frame(invoice_info_frame, bg='#FFFFFF')
                info_grid.pack(fill='x')
                
                # Primera fila
                tk.Label(info_grid, text="üìÑ N√∫mero:", font=('Arial', 11, 'bold'), 
                        bg='#FFFFFF').grid(row=0, column=0, sticky='w', padx=(0, 10), pady=5)
                tk.Label(info_grid, text=numero_factura, font=('Arial', 11), 
                        bg='#FFFFFF', fg='#1E3A8A').grid(row=0, column=1, sticky='w', pady=5)
                
                tk.Label(info_grid, text="üìÖ Fecha:", font=('Arial', 11, 'bold'), 
                        bg='#FFFFFF').grid(row=0, column=2, sticky='w', padx=(30, 10), pady=5)
                tk.Label(info_grid, text=fecha, font=('Arial', 11), 
                        bg='#FFFFFF', fg='#1E3A8A').grid(row=0, column=3, sticky='w', pady=5)
                
                # Segunda fila
                tk.Label(info_grid, text="üë§ Paciente:", font=('Arial', 11, 'bold'), 
                        bg='#FFFFFF').grid(row=1, column=0, sticky='w', padx=(0, 10), pady=5)
                tk.Label(info_grid, text=paciente or "N/A", font=('Arial', 11), 
                        bg='#FFFFFF', fg='#1E3A8A').grid(row=1, column=1, columnspan=3, sticky='w', pady=5)
                
        except Exception as e:
            print(f"Error obteniendo informaci√≥n de factura: {e}")
        
        # Total a pagar destacado
        total_frame = tk.LabelFrame(main_frame, text="üí∞ Total a Pagar", 
                                   font=('Arial', 12, 'bold'), bg='#FFFFFF', fg='#1E3A8A',
                                   padx=20, pady=15)
        total_frame.pack(fill='x', pady=(0, 20))
        
        total_label = tk.Label(total_frame, text=f"RD$ {total_amount:,.2f}", 
                              font=('Arial', 20, 'bold'), bg='#FFFFFF', fg='#C0392B')
        total_label.pack(pady=10)
        
        # Frame de pago
        payment_details_frame = tk.LabelFrame(main_frame, text="üí≥ Detalles del Pago", 
                                            font=('Arial', 12, 'bold'), bg='#FFFFFF', fg='#1E3A8A',
                                            padx=20, pady=15)
        payment_details_frame.pack(fill='x', pady=(0, 20))
        
        payment_grid = tk.Frame(payment_details_frame, bg='#FFFFFF')
        payment_grid.pack(fill='x', pady=10)
        
        # Monto recibido del paciente
        tk.Label(payment_grid, text="üíµ Monto Recibido:", font=('Arial', 12, 'bold'), 
                bg='#FFFFFF').grid(row=0, column=0, sticky='w', pady=10)
        
        amount_received_var = tk.StringVar()
        amount_entry = tk.Entry(payment_grid, textvariable=amount_received_var, 
                              font=('Arial', 14, 'bold'), width=15, justify='center',
                              relief='solid', bd=2)
        amount_entry.grid(row=0, column=1, padx=(10, 0), pady=10)
        amount_entry.focus()
        
        # M√©todo de pago
        tk.Label(payment_grid, text="üí≥ M√©todo de Pago:", font=('Arial', 12, 'bold'), 
                bg='#FFFFFF').grid(row=1, column=0, sticky='w', pady=10)
        
        payment_method_var = tk.StringVar(value="Efectivo")
        payment_method_combo = ttk.Combobox(payment_grid, textvariable=payment_method_var,
                                          values=["Efectivo", "Tarjeta de Cr√©dito", "Tarjeta de D√©bito", 
                                                "Transferencia Bancaria", "Cheque"], 
                                          state="readonly", width=20, font=('Arial', 11))
        payment_method_combo.grid(row=1, column=1, padx=(10, 0), pady=10, sticky='w')
        
        # C√°lculo autom√°tico del cambio
        change_frame = tk.LabelFrame(main_frame, text="üí∏ C√°lculo de Cambio", 
                                   font=('Arial', 12, 'bold'), bg='#FFFFFF', fg='#1E3A8A',
                                   padx=20, pady=15)
        change_frame.pack(fill='x', pady=(0, 20))
        
        change_display = tk.Frame(change_frame, bg='#FFFFFF')
        change_display.pack(fill='x', pady=10)
        
        change_status_label = tk.Label(change_display, text="Ingrese el monto recibido", 
                                      font=('Arial', 14, 'bold'), bg='#FFFFFF', fg='#64748B')
        change_status_label.pack()
        
        change_amount_label = tk.Label(change_display, text="", 
                                      font=('Arial', 18, 'bold'), bg='#FFFFFF')
        change_amount_label.pack(pady=(10, 0))
        
        # Funci√≥n para calcular cambio en tiempo real
        def calculate_change(*args):
            try:
                received = float(amount_received_var.get() or 0)
                change = received - total_amount
                
                if received == 0:
                    change_status_label.config(text="Ingrese el monto recibido", fg='#64748B')
                    change_amount_label.config(text="")
                elif change >= 0:
                    change_status_label.config(text="üí∞ CAMBIO A DEVOLVER:", fg='#16A085')
                    change_amount_label.config(text=f"RD$ {change:,.2f}", fg='#16A085')
                else:
                    change_status_label.config(text="‚ùå MONTO INSUFICIENTE:", fg='#C0392B')
                    change_amount_label.config(text=f"Faltan: RD$ {abs(change):,.2f}", fg='#C0392B')
            except ValueError:
                change_status_label.config(text="‚ö†Ô∏è Ingrese un monto v√°lido", fg='#E67E22')
                change_amount_label.config(text="")
        
        amount_received_var.trace('w', calculate_change)
        
        # Botones de acci√≥n
        buttons_frame = tk.Frame(main_frame, bg='#FFFFFF')
        buttons_frame.pack(fill='x', pady=(20, 0))
        
        # Bot√≥n Cancelar
        cancel_btn = tk.Button(buttons_frame, text="‚ùå Cancelar", 
                             command=payment_window.destroy,
                             bg='#0B5394', fg='white', font=('Arial', 12, 'bold'),
                             width=15, pady=10, relief='raised', bd=3)
        cancel_btn.pack(side='left')
        
        # Bot√≥n Procesar Pago
        def process_existing_payment():
            try:
                received = float(amount_received_var.get() or 0)
                if received < total_amount:
                    messagebox.showwarning("Pago Insuficiente", 
                                         f"El monto recibido (RD$ {received:,.2f}) es menor al total a pagar (RD$ {total_amount:,.2f})")
                    return
                
                # Actualizar el estado de la factura a 'pagada'
                conn = self.db_manager.get_connection()
                cursor = conn.cursor()
                
                cursor.execute("""
                    UPDATE facturas 
                    SET estado = 'pagado',
                        monto_recibido = ?,
                        metodo_pago = ?,
                        fecha_pago = datetime('now', 'localtime')
                    WHERE id = ?
                """, (received, payment_method_var.get(), invoice_id))
                
                conn.commit()
                cursor.close()
                conn.close()
                
                # Mostrar mensaje de √©xito
                change = received - total_amount
                success_msg = f"‚úÖ Pago procesado exitosamente!\n\n"
                success_msg += f"Factura ID: {invoice_id}\n"
                success_msg += f"Total: RD$ {total_amount:,.2f}\n"
                success_msg += f"Recibido: RD$ {received:,.2f}\n"
                if change > 0:
                    success_msg += f"Cambio: RD$ {change:,.2f}\n"
                success_msg += f"M√©todo: {payment_method_var.get()}"
                
                messagebox.showinfo("Pago Completado", success_msg)
                
                # Cerrar ventana y actualizar listas
                payment_window.destroy()
                self.load_existing_invoices()
                # Actualizar tabla de citas para facturar para que desaparezca la cita procesada
                print("üîÑ DEBUG: Llamando load_appointments_for_billing() despu√©s del pago de factura existente")
                self.load_appointments_for_billing()
                
            except ValueError:
                messagebox.showerror("Error", "Por favor ingrese un monto v√°lido")
            except Exception as e:
                messagebox.showerror("Error", f"Error procesando el pago: {str(e)}")
        
        process_btn = tk.Button(buttons_frame, text="üí≥ PROCESAR PAGO", 
                              command=process_existing_payment,
                              bg='#0B5394', fg='white', font=('Arial', 12, 'bold'),
                              width=20, pady=10, relief='raised', bd=3)
        process_btn.pack(side='right', padx=(10, 0))
    
    def view_invoice_details_billing(self, event=None):
        """Ver detalles de una factura seleccionada"""
        selection = self.billing_invoices_tree.selection()
        if not selection:
            messagebox.showwarning("Selecci√≥n requerida", "Por favor, seleccione una factura")
            return
        
        item = selection[0]
        values = self.billing_invoices_tree.item(item, 'values')
        numero_factura = values[0]
        
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT f.numero_factura, f.fecha_creacion, f.monto, f.concepto,
                       f.estado, f.metodo_pago, f.fecha_pago, f.notas,
                       p.nombre || ' ' || p.apellido as paciente,
                       d.nombre || ' ' || d.apellido as doctor
                FROM facturas f
                JOIN usuarios p ON f.paciente_id = p.id
                JOIN usuarios d ON f.doctor_id = d.id
                WHERE f.numero_factura = ?
            """, (numero_factura,))
            
            factura_info = cursor.fetchone()
            if factura_info:
                details = f"""
DETALLES DE LA FACTURA

N√∫mero: {factura_info[0]}
Fecha: {factura_info[1]}
Paciente: {factura_info[8]}
Doctor: {factura_info[9]}
Concepto: {factura_info[3]}
Monto: RD$ {float(factura_info[2]):,.2f}
Estado: {factura_info[4]}
M√©todo de Pago: {factura_info[5] or 'No especificado'}
Fecha de Pago: {factura_info[6] or 'Pendiente'}
Notas: {factura_info[7] or 'Sin notas'}
                """
                messagebox.showinfo("Detalles de Factura", details)
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error obteniendo detalles: {str(e)}")
    
    def reprint_invoice_pdf(self):
        """Reimprimir PDF de una factura existente"""
        selection = self.billing_invoices_tree.selection()
        if not selection:
            messagebox.showwarning("Selecci√≥n requerida", "Por favor, seleccione una factura")
            return
        
        item = selection[0]
        values = self.billing_invoices_tree.item(item, 'values')
        numero_factura = values[0]
        
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id
                FROM facturas
                WHERE numero_factura = ?
            """, (numero_factura,))
            
            result = cursor.fetchone()
            if result:
                invoice_id = result[0]
                # Reimprimir usando la funci√≥n existente
                self.generate_final_invoice_pdf(invoice_id, 0, 0)  # Monto 0 para reimpresi√≥n
                messagebox.showinfo("PDF Reimpreso", f"PDF de la factura {numero_factura} generado nuevamente")
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error reimprimiendo PDF: {str(e)}")
    
    def install_reportlab(self):
        """Instalar ReportLab autom√°ticamente"""
        try:
            import subprocess
            import sys
            
            result = messagebox.askquestion("Instalar ReportLab", 
                                          "¬øDesea instalar ReportLab para generar PDFs?")
            if result == 'yes':
                subprocess.check_call([sys.executable, "-m", "pip", "install", "reportlab"])
                messagebox.showinfo("Instalaci√≥n completada", 
                                   "ReportLab instalado correctamente.\nYa puede generar PDFs.")
        except Exception as e:
            messagebox.showerror("Error de instalaci√≥n", 
                                f"No se pudo instalar ReportLab autom√°ticamente.\n{str(e)}")
    
    def export_billing_report_pdf(self):
        """Exportar reporte de facturaci√≥n a PDF"""
        try:
            from tkinter import filedialog
            from reportlab.lib.pagesizes import letter
            from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
            from reportlab.lib.styles import getSampleStyleSheet
            from reportlab.lib import colors
            
            # Obtener datos de facturas
            if not hasattr(self, 'billing_tree') or not self.billing_tree.get_children():
                messagebox.showwarning("Sin datos", "No hay facturas para exportar")
                return
            
            # Crear archivo PDF
            filename = filedialog.asksaveasfilename(
                defaultextension=".pdf",
                filetypes=[("PDF files", "*.pdf")],
                title="Guardar reporte de facturaci√≥n"
            )
            
            if not filename:
                return
                
            doc = SimpleDocTemplate(filename, pagesize=letter)
            styles = getSampleStyleSheet()
            story = []
            
            # T√≠tulo
            story.append(Paragraph("<b>REPORTE DE FACTURACI√ìN</b>", styles['Title']))
            story.append(Spacer(1, 20))
            
            # Tabla de facturas
            data = [['N√∫mero', 'Fecha', 'Paciente', 'Monto', 'Estado']]
            
            for item in self.billing_tree.get_children():
                values = self.billing_tree.item(item)['values']
                data.append([str(val) for val in values])
            
            table = Table(data)
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 10),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            
            story.append(table)
            doc.build(story)
            
            messagebox.showinfo("PDF Generado", f"Reporte guardado como: {filename}")
            
        except ImportError:
            messagebox.showerror("ReportLab no encontrado", 
                               "Necesita instalar ReportLab para generar PDFs")
        except Exception as e:
            messagebox.showerror("Error", f"Error generando PDF: {str(e)}")
    
    def refresh_billing_data(self):
        """Actualizar datos de facturaci√≥n"""
        pass
    
    def create_payments_tab(self, parent):
        """Crear pesta√±a de procesamiento de pagos"""
        tk.Label(parent, text="üí≥ M√≥dulo de Pagos", font=('Arial', 16, 'bold'), 
                bg='#F8FAFC').pack(pady=20)
        tk.Label(parent, text="En desarrollo - Pr√≥ximamente", font=('Arial', 12), 
                bg='#F8FAFC', fg='#64748B').pack()
    
    def create_reports_tab(self, parent):
        """Crear pesta√±a de reportes"""
        tk.Label(parent, text="üìä M√≥dulo de Reportes", font=('Arial', 16, 'bold'), 
                bg='#F8FAFC').pack(pady=20)
        tk.Label(parent, text="En desarrollo - Pr√≥ximamente", font=('Arial', 12), 
                bg='#F8FAFC', fg='#64748B').pack()
    
    def create_billing_config_tab(self, parent):
        """Crear pesta√±a de configuraci√≥n de facturaci√≥n"""
        tk.Label(parent, text="‚öôÔ∏è Configuraci√≥n de Facturaci√≥n", font=('Arial', 16, 'bold'), 
                bg='#F8FAFC').pack(pady=20)
        tk.Label(parent, text="En desarrollo - Pr√≥ximamente", font=('Arial', 12), 
                bg='#F8FAFC', fg='#64748B').pack()
    
    def load_billing_data_integrated(self):
        """Cargar datos de facturaci√≥n integrados"""
        try:
            # Limpiar tabla
            for item in self.billing_tree.get_children():
                self.billing_tree.delete(item)
            
            # Obtener facturas recientes (√∫ltimos 30 d√≠as)
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            thirty_days_ago = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
            
            cursor.execute('''
            SELECT numero_factura, fecha_creacion, 
                   (SELECT nombre || ' ' || apellido FROM usuarios WHERE id = f.paciente_id) as paciente_nombre,
                   monto, estado
            FROM facturas f
            WHERE DATE(fecha_creacion) >= ?
            ORDER BY fecha_creacion DESC
            LIMIT 20
            ''', (thirty_days_ago,))
            
            invoices = cursor.fetchall()
            
            for invoice in invoices:
                # Formatear fecha
                fecha = invoice[1]
                if fecha:
                    try:
                        dt = datetime.fromisoformat(fecha)
                        fecha = dt.strftime('%d/%m/%Y')
                    except:
                        pass
                
                # Formatear estado
                estado = invoice[4].title() if invoice[4] else 'Desconocido'
                
                self.billing_tree.insert('', 'end', values=(
                    invoice[0] or 'N/A',  # N√∫mero
                    fecha,               # Fecha
                    invoice[2] or 'N/A', # Paciente
                    f"RD$ {float(invoice[3] or 0):,.2f}",  # Monto
                    estado               # Estado
                ))
            
            conn.close()
            
            # Actualizar estad√≠sticas
            self.update_billing_statistics()
            
            # Actualizar citas sin facturar
            self.update_pending_appointments()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error cargando datos de facturaci√≥n: {str(e)}")
    
    def update_billing_statistics(self):
        """Actualizar estad√≠sticas de facturaci√≥n"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            today = datetime.now().strftime('%Y-%m-%d')
            
            # Facturas de hoy
            cursor.execute('SELECT COUNT(*) FROM facturas WHERE DATE(fecha_creacion) = ?', (today,))
            facturas_hoy = cursor.fetchone()[0]
            self.stats_vars['facturas_hoy'].set(str(facturas_hoy))
            
            # Ingresos de hoy
            cursor.execute('SELECT COALESCE(SUM(monto), 0) FROM facturas WHERE DATE(fecha_creacion) = ? AND estado IN ("pagada", "pago_parcial")', (today,))
            ingresos_hoy = cursor.fetchone()[0]
            self.stats_vars['ingresos_hoy'].set(f"RD$ {float(ingresos_hoy):,.2f}")
            
            # Facturas pendientes
            cursor.execute('SELECT COUNT(*) FROM facturas WHERE estado = "pendiente"')
            pendientes = cursor.fetchone()[0]
            self.stats_vars['pendientes'].set(str(pendientes))
            
            # Citas sin facturar
            cursor.execute('''
            SELECT COUNT(*) FROM citas c
            LEFT JOIN facturas f ON c.id = f.cita_id
            WHERE c.estado = 'completada' AND f.cita_id IS NULL
            ''')
            sin_facturar = cursor.fetchone()[0]
            self.stats_vars['citas_sin_facturar'].set(str(sin_facturar))
            
            conn.close()
            
        except Exception as e:
            print(f"Error actualizando estad√≠sticas: {e}")
    
    def update_pending_appointments(self):
        """Actualizar lista de citas sin facturar"""
        try:
            self.pending_appointments_list.delete(0, tk.END)
            
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            cursor.execute('''
            SELECT c.id, c.fecha_hora, 
                   (SELECT nombre || ' ' || apellido FROM usuarios WHERE id = c.paciente_id) as paciente_nombre,
                   c.motivo
            FROM citas c
            LEFT JOIN facturas f ON c.id = f.cita_id
            WHERE c.estado = 'completada' AND f.cita_id IS NULL
            ORDER BY c.fecha_hora DESC
            LIMIT 10
            ''')
            
            appointments = cursor.fetchall()
            
            for apt in appointments:
                fecha = apt[1]
                if fecha:
                    try:
                        dt = datetime.fromisoformat(fecha)
                        fecha = dt.strftime('%d/%m %H:%M')
                    except:
                        pass
                
                text = f"{fecha} - {apt[2]} - {apt[3][:30]}..."
                self.pending_appointments_list.insert(tk.END, text)
                # Almacenar ID de cita para uso posterior
                self.pending_appointments_list.insert(tk.END, f"ID:{apt[0]}")
            
            conn.close()
            
        except Exception as e:
            print(f"Error actualizando citas pendientes: {e}")
    
    def quick_invoice(self):
        """Crear factura r√°pida"""
        messagebox.showinfo("Factura R√°pida", "Use el 'Sistema Completo' para crear facturas con todas las funcionalidades")
    
    def generate_billing_report(self):
        """Generar reporte de facturaci√≥n"""
        try:
            if not PDF_AVAILABLE:
                messagebox.showwarning("PDF No Disponible", "La funcionalidad de reportes PDF no est√° disponible")
                return
            
            messagebox.showinfo("Reporte", "Funcionalidad de reportes disponible en el Sistema Completo")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error generando reporte: {str(e)}")
    
    def search_invoice(self):
        """Buscar factura"""
        search_term = simpledialog.askstring("Buscar Factura", "Ingrese n√∫mero de factura o nombre del paciente:")
        if search_term:
            # Implementar b√∫squeda
            messagebox.showinfo("B√∫squeda", f"Buscando: {search_term}\nUse el Sistema Completo para b√∫squedas avanzadas")
    
    def refresh_billing_data(self):
        """Actualizar datos de facturaci√≥n"""
        self.load_billing_data_integrated()
        messagebox.showinfo("Actualizado", "‚úÖ Datos de facturaci√≥n actualizados")
    
    def bill_selected_appointment(self):
        """Facturar cita seleccionada"""
        selection = self.pending_appointments_list.curselection()
        if not selection:
            messagebox.showwarning("Selecci√≥n", "Seleccione una cita para facturar")
            return
        
        messagebox.showinfo("Facturaci√≥n", "Use el 'Sistema Completo' para facturar citas con todas las funcionalidades")
    
    def show_billing_summary(self):
        """Mostrar resumen de facturaci√≥n"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Obtener datos del mes actual
            current_month = datetime.now().strftime('%Y-%m')
            
            cursor.execute('''
            SELECT 
                COUNT(*) as total_facturas,
                COALESCE(SUM(monto), 0) as total_ingresos,
                COUNT(CASE WHEN estado = 'pagado' THEN 1 END) as pagadas,
                COUNT(CASE WHEN estado = 'pendiente' THEN 1 END) as pendientes
            FROM facturas 
            WHERE strftime('%Y-%m', fecha_creacion) = ?
            ''', (current_month,))
            
            stats = cursor.fetchone()
            conn.close()
            
            summary_text = f"""üìä RESUMEN DE FACTURACI√ìN - {datetime.now().strftime('%B %Y').upper()}

üí∞ FACTURAS GENERADAS: {stats[0]}
üíµ INGRESOS TOTALES: RD${float(stats[1]):,.2f}
‚úÖ FACTURAS PAGADAS: {stats[2]}
‚è≥ FACTURAS PENDIENTES: {stats[3]}

üéØ TASA DE COBRO: {(stats[2]/stats[0]*100) if stats[0] > 0 else 0:.1f}%

üí° Use el 'Sistema Completo' para an√°lisis detallados y generaci√≥n de PDFs"""
            
            messagebox.showinfo("Resumen de Facturaci√≥n", summary_text)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error generando resumen: {str(e)}")
    
    def load_billing_data(self, tree):
        """Cargar datos de facturas (funci√≥n legacy para compatibilidad)"""
        try:
            # Limpiar tabla
            for item in tree.get_children():
                tree.delete(item)
            
            # Obtener facturas
            invoices = self.db_manager.get_all_invoices()
            
            for invoice in invoices:
                # Formatear fecha
                fecha = invoice.get('fecha_creacion', '')
                if fecha:
                    try:
                        dt = datetime.fromisoformat(fecha)
                        fecha = dt.strftime('%d/%m/%Y')
                    except:
                        pass
                
                tree.insert('', 'end', values=(
                    invoice['id'], invoice.get('numero_factura', 'N/A'),
                    fecha, invoice.get('paciente_nombre', 'N/A'),
                    invoice.get('concepto', 'N/A'),
                    f"RD${invoice.get('monto', 0):,.2f}",
                    invoice.get('estado', 'N/A').title()
                ))
                
        except Exception as e:
            messagebox.showerror("Error", f"Error cargando facturas: {str(e)}")
    
    def create_reports_tab(self, parent):
        """Crear pesta√±a de reportes con dise√±o moderno"""
        # Frame principal
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=15, pady=15)
        
        # Header moderno
        header_frame = tk.Frame(main_frame, bg='#1E3A8A', height=70)
        header_frame.pack(fill='x', pady=(0, 20))
        header_frame.pack_propagate(False)
        
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=20, pady=10)
        
        tk.Label(header_content, text="üìä", font=('Arial', 18), bg='#1E3A8A', fg='white').pack(side='left', pady=8)
        tk.Label(header_content, text="REPORTES Y ESTAD√çSTICAS", 
                font=('Arial', 14, 'bold'), bg='#1E3A8A', fg='white').pack(side='left', padx=(10, 0), pady=8)
        tk.Label(header_content, text="Informes detallados del sistema", 
                font=('Arial', 10), bg='#1E3A8A', fg='#CBD5E1').pack(side='left', padx=(15, 0), pady=8)
        
        # Contenido dividido en paneles
        content_frame = tk.Frame(main_frame, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True)
        
        # Panel izquierdo: Reportes principales
        left_panel = tk.Frame(content_frame, bg='#F8FAFC', width=400)
        left_panel.pack(side='left', fill='y', padx=(0, 15))
        left_panel.pack_propagate(False)
        
        # Panel derecho: Estad√≠sticas y reportes r√°pidos
        right_panel = tk.Frame(content_frame, bg='#F8FAFC')
        right_panel.pack(side='right', fill='both', expand=True)
        
        # Reportes principales
        reports_frame = tk.LabelFrame(
            left_panel, 
            text="üìã REPORTES PRINCIPALES", 
            font=('Arial', 12, 'bold'),
            bg='#e3f2fd',
            fg='#1565c0',
            padx=20, 
            pady=15
        )
        reports_frame.pack(fill='x', pady=(0, 15))
        
        reports_buttons = [
            ("ÔøΩ Reporte de Ingresos", self.generate_income_report, "#0B5394"),
            ("üìã Facturas Pendientes", self.generate_pending_invoices_report, "#0B5394"),
            ("üë• Estad√≠sticas de Usuarios", self.generate_users_report, "#0B5394"),
            ("üìÖ Reporte de Citas", self.generate_appointments_report, "#0B5394"),
            ("üí∞ Estado Financiero", self.generate_financial_report, "#0B5394"),
            ("üè• Reporte de Servicios", self.generate_services_report, "#0B5394")
        ]
        
        for text, command, color in reports_buttons:
            btn = tk.Button(
                reports_frame, 
                text=text, 
                command=command,
                bg=color, 
                fg='white', 
                font=('Arial', 10, 'bold'),
                relief='flat',
                padx=15,
                pady=8,
                cursor='hand2'
            )
            btn.pack(fill='x', pady=5)
            
            # Efectos hover
            def on_enter(e, button=btn, original_color=color):
                button.configure(bg=self.darken_color(original_color))
            def on_leave(e, button=btn, original_color=color):
                button.configure(bg=original_color)
            
            btn.bind("<Enter>", on_enter)
            btn.bind("<Leave>", on_leave)
        
        # Panel de exportaci√≥n
        export_frame = tk.LabelFrame(
            left_panel,
            text="üíæ EXPORTAR DATOS",
            font=('Arial', 12, 'bold'),
            bg='#fff3e0',
            fg='#e65100',
            padx=20,
            pady=15
        )
        export_frame.pack(fill='x', pady=(0, 15))
        
        export_buttons = [
            ("üìÑ Exportar a PDF", self.export_all_reports_pdf, "#0B5394"),
            ("üìä Exportar a Excel", self.export_to_excel, "#0B5394"),
            ("üìß Enviar por Email", self.email_reports, "#0B5394")
        ]
        
        for text, command, color in export_buttons:
            btn = tk.Button(
                export_frame,
                text=text,
                command=command,
                bg=color,
                fg='white',
                font=('Arial', 10, 'bold'),
                relief='flat',
                padx=15,
                pady=6
            )
            btn.pack(fill='x', pady=3)
        
        # Estad√≠sticas en tiempo real
        stats_frame = tk.LabelFrame(
            right_panel,
            text="üìä ESTAD√çSTICAS EN TIEMPO REAL",
            font=('Arial', 12, 'bold'),
            bg='#e8f5e8',
            fg='#2e7d32',
            padx=20,
            pady=15
        )
        stats_frame.pack(fill='x', pady=(0, 15))
        
        # Crear √°rea de estad√≠sticas
        self.create_stats_display(stats_frame)
        
        # Panel de filtros avanzados
        filters_frame = tk.LabelFrame(
            right_panel,
            text="üîç FILTROS AVANZADOS",
            font=('Arial', 12, 'bold'),
            bg='#fce4ec',
            fg='#c2185b',
            padx=20,
            pady=15
        )
        filters_frame.pack(fill='x', pady=(0, 15))
        
        # Crear controles de filtros
        self.create_report_filters(filters_frame)
        
        # Panel de acceso r√°pido
        quick_frame = tk.LabelFrame(
            right_panel,
            text="‚ö° ACCESO R√ÅPIDO",
            font=('Arial', 12, 'bold'),
            bg='#f3e5f5',
            fg='#7b1fa2',
            padx=20,
            pady=15
        )
        quick_frame.pack(fill='both', expand=True)
        
        quick_actions = [
            ("üìà Dashboard Ejecutivo", self.show_executive_dashboard),
            ("üîÑ Actualizar Datos", self.refresh_all_data),
            ("‚öôÔ∏è Configurar Reportes", self.configure_reports),
            ("üìã Plantillas", self.manage_report_templates)
        ]
        
        for text, command in quick_actions:
            btn = tk.Button(
                quick_frame,
                text=text,
                command=command,
                bg='#64748B',
                fg='white',
                font=('Arial', 9, 'bold'),
                relief='flat',
                padx=10,
                pady=5
            )
            btn.pack(fill='x', pady=3)

    def create_stats_display(self, parent):
        """Crear √°rea de estad√≠sticas en tiempo real"""
        try:
            stats = self.get_system_stats()
            
            # Grid de estad√≠sticas
            stats_grid = tk.Frame(parent, bg='#e8f5e8')
            stats_grid.pack(fill='x', pady=10)
            
            stats_data = [
                ("üë• Total Usuarios", stats.get('total_users', 0), "#0B5394"),
                ("ü§í Total Pacientes", stats.get('total_patients', 0), "#16A085"),
                ("üìÖ Citas Hoy", stats.get('appointments_today', 0), "#E67E22"),
                ("üí∞ Ingresos Mes", f"RD${stats.get('monthly_income', 0):,.2f}", "#059669"),
                ("üìã Fact. Pendientes", stats.get('pending_invoices', 0), "#C0392B"),
                ("üë®‚Äç‚öïÔ∏è Doctores Activos", stats.get('active_doctors', 0), "#8e44ad")
            ]
            
            for i, (label, value, color) in enumerate(stats_data):
                card = tk.Frame(stats_grid, bg='white', relief='solid', bd=1)
                card.grid(row=i//2, column=i%2, padx=8, pady=5, sticky='ew')
                
                tk.Label(card, text=str(value), font=('Arial', 16, 'bold'), 
                        fg=color, bg='white').pack(pady=(8, 2))
                tk.Label(card, text=label, font=('Arial', 9), 
                        fg='#64748B', bg='white').pack(pady=(0, 8))
            
            # Configurar grid
            stats_grid.grid_columnconfigure(0, weight=1)
            stats_grid.grid_columnconfigure(1, weight=1)
            
        except Exception as e:
            tk.Label(parent, text=f"Error cargando estad√≠sticas: {str(e)}", 
                    fg='red', bg='#e8f5e8').pack()

    def create_report_filters(self, parent):
        """Crear controles de filtros para reportes"""
        # Filtro de fechas
        date_frame = tk.Frame(parent, bg='#fce4ec')
        date_frame.pack(fill='x', pady=5)
        
        tk.Label(date_frame, text="üìÖ Per√≠odo:", font=('Arial', 10, 'bold'),
                bg='#fce4ec', fg='#c2185b').pack(side='left')
        
        self.report_period_filter = ttk.Combobox(
            date_frame, 
            values=['Hoy', 'Esta Semana', 'Este Mes', '√öltimos 3 Meses', 'Este A√±o', 'Personalizado'],
            state='readonly',
            width=15
        )
        self.report_period_filter.set('Este Mes')
        self.report_period_filter.pack(side='left', padx=(10, 0))
        
        # Filtro de tipo
        type_frame = tk.Frame(parent, bg='#fce4ec')
        type_frame.pack(fill='x', pady=5)
        
        tk.Label(type_frame, text="üìä Tipo:", font=('Arial', 10, 'bold'),
                bg='#fce4ec', fg='#c2185b').pack(side='left')
        
        self.report_type_filter = ttk.Combobox(
            type_frame,
            values=['Todos', 'Financieros', 'Operativos', 'M√©dicos', 'Administrativos'],
            state='readonly',
            width=15
        )
        self.report_type_filter.set('Todos')
        self.report_type_filter.pack(side='left', padx=(10, 0))
        
        # Bot√≥n aplicar filtros
        tk.Button(
            parent,
            text="üîç Aplicar Filtros",
            command=self.apply_report_filters,
            bg='#c2185b',
            fg='white',
            font=('Arial', 10, 'bold'),
            relief='flat',
            padx=15,
            pady=8
        ).pack(fill='x', pady=(10, 0))

    def darken_color(self, color):
        """Oscurecer un color hexadecimal para efectos hover"""
        color = color.lstrip('#')
        rgb = tuple(int(color[i:i+2], 16) for i in (0, 2, 4))
        darker_rgb = tuple(max(0, int(c * 0.8)) for c in rgb)
        return '#%02x%02x%02x' % darker_rgb

    def generate_income_report(self):
        """Generar reporte de ingresos con selecci√≥n de fechas"""
        self.show_report_dialog("Reporte de Ingresos", "income")
    
    def generate_pending_invoices_report(self):
        """Generar reporte de facturas pendientes"""
        self.show_report_dialog("Facturas Pendientes", "pending_invoices")
    
    def generate_users_report(self):
        """Generar reporte de usuarios"""
        self.show_report_dialog("Estad√≠sticas de Usuarios", "users")
    
    def generate_appointments_report(self):
        """Generar reporte de citas"""
        self.show_report_dialog("Reporte de Citas", "appointments")
        
    def generate_financial_report(self):
        """Generar reporte financiero completo"""
        self.show_report_dialog("Estado Financiero", "financial")
        
    def generate_services_report(self):
        """Generar reporte de servicios m√©dicos"""
        self.show_report_dialog("Reporte de Servicios", "services")
    
    def show_report_dialog(self, report_title, report_type):
        """Mostrar di√°logo de configuraci√≥n de reportes con selecci√≥n de fechas"""
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Configurar {report_title}")
        dialog.geometry("500x600")
        dialog.configure(bg='#F8FAFC')
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Centrar ventana
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (500 // 2)
        y = (dialog.winfo_screenheight() // 2) - (600 // 2)
        dialog.geometry(f"500x600+{x}+{y}")
        
        # Header
        header = tk.Frame(dialog, bg='#0B5394', height=70)
        header.pack(fill='x')
        header.pack_propagate(False)
        
        header_content = tk.Frame(header, bg='#0B5394')
        header_content.pack(expand=True, fill='both', padx=20, pady=15)
        
        tk.Label(header_content, text="üìä", font=('Arial', 18), bg='#0B5394', fg='white').pack(side='left')
        tk.Label(header_content, text=report_title.upper(), 
                font=('Arial', 14, 'bold'), bg='#0B5394', fg='white').pack(side='left', padx=(10, 0))
        
        # Contenido principal
        content = tk.Frame(dialog, bg='#F8FAFC')
        content.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Configuraci√≥n de fechas
        date_frame = tk.LabelFrame(content, text="üìÖ Configuraci√≥n de Fechas", 
                                  font=('Arial', 12, 'bold'), padx=15, pady=15, bg='#F8FAFC')
        date_frame.pack(fill='x', pady=(0, 15))
        
        # Tipo de per√≠odo
        period_frame = tk.Frame(date_frame, bg='#F8FAFC')
        period_frame.pack(fill='x', pady=5)
        
        tk.Label(period_frame, text="Per√≠odo:", font=('Arial', 10, 'bold'), 
                bg='#F8FAFC').pack(side='left')
        
        period_var = tk.StringVar(value="Este Mes")
        period_combo = ttk.Combobox(period_frame, textvariable=period_var,
                                   values=['Hoy', 'Ayer', 'Esta Semana', 'Semana Pasada', 
                                          'Este Mes', 'Mes Pasado', 'Este A√±o', 'A√±o Pasado', 'Personalizado'],
                                   state='readonly', width=20)
        period_combo.pack(side='left', padx=(10, 0))
        
        # Fechas personalizadas (inicialmente ocultas)
        custom_frame = tk.Frame(date_frame, bg='#F8FAFC')
        custom_frame.pack(fill='x', pady=10)
        custom_frame.pack_forget()  # Ocultar inicialmente
        
        # Fecha inicio
        start_frame = tk.Frame(custom_frame, bg='#F8FAFC')
        start_frame.pack(fill='x', pady=5)
        
        tk.Label(start_frame, text="Fecha Inicio:", font=('Arial', 10), bg='#F8FAFC').pack(side='left')
        start_date_var = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d'))
        start_date_entry = tk.Entry(start_frame, textvariable=start_date_var, width=15)
        start_date_entry.pack(side='left', padx=(10, 0))
        
        if CALENDAR_AVAILABLE:
            tk.Button(start_frame, text="üìÖ", command=lambda: self.select_date_calendar(start_date_var),
                     bg='#0B5394', fg='white', font=('Arial', 8)).pack(side='left', padx=5)
        
        # Fecha fin
        end_frame = tk.Frame(custom_frame, bg='#F8FAFC')
        end_frame.pack(fill='x', pady=5)
        
        tk.Label(end_frame, text="Fecha Fin:", font=('Arial', 10), bg='#F8FAFC').pack(side='left')
        end_date_var = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d'))
        end_date_entry = tk.Entry(end_frame, textvariable=end_date_var, width=15)
        end_date_entry.pack(side='left', padx=(10, 0))
        
        if CALENDAR_AVAILABLE:
            tk.Button(end_frame, text="üìÖ", command=lambda: self.select_date_calendar(end_date_var),
                     bg='#0B5394', fg='white', font=('Arial', 8)).pack(side='left', padx=5)
        
        # Funci√≥n para mostrar/ocultar fechas personalizadas
        def on_period_change(*args):
            if period_var.get() == 'Personalizado':
                custom_frame.pack(fill='x', pady=10)
            else:
                custom_frame.pack_forget()
        
        period_var.trace('w', on_period_change)
        
        # Opciones de formato
        format_frame = tk.LabelFrame(content, text="üìã Opciones de Formato", 
                                    font=('Arial', 12, 'bold'), padx=15, pady=15, bg='#F8FAFC')
        format_frame.pack(fill='x', pady=(0, 15))
        
        # Tipo de salida
        output_frame = tk.Frame(format_frame, bg='#F8FAFC')
        output_frame.pack(fill='x', pady=5)
        
        tk.Label(output_frame, text="Formato de Salida:", font=('Arial', 10, 'bold'), 
                bg='#F8FAFC').pack(side='left')
        
        output_var = tk.StringVar(value="PDF")
        output_combo = ttk.Combobox(output_frame, textvariable=output_var,
                                   values=['PDF', 'Excel', 'Vista Previa'], state='readonly', width=15)
        output_combo.pack(side='left', padx=(10, 0))
        
        # Opciones adicionales seg√∫n el tipo de reporte
        options_frame = tk.LabelFrame(content, text="‚öôÔ∏è Opciones Espec√≠ficas", 
                                     font=('Arial', 12, 'bold'), padx=15, pady=15, bg='#F8FAFC')
        options_frame.pack(fill='x', pady=(0, 15))
        
        # Variables para opciones espec√≠ficas
        include_charts = tk.BooleanVar(value=True)
        include_details = tk.BooleanVar(value=True)
        include_summary = tk.BooleanVar(value=True)
        
        tk.Checkbutton(options_frame, text="Incluir Gr√°ficos", variable=include_charts,
                      font=('Arial', 10), bg='#F8FAFC').pack(anchor='w', pady=2)
        tk.Checkbutton(options_frame, text="Incluir Detalles", variable=include_details,
                      font=('Arial', 10), bg='#F8FAFC').pack(anchor='w', pady=2)
        tk.Checkbutton(options_frame, text="Incluir Resumen", variable=include_summary,
                      font=('Arial', 10), bg='#F8FAFC').pack(anchor='w', pady=2)
        
        # Opciones espec√≠ficas por tipo de reporte
        if report_type == "income":
            tk.Checkbutton(options_frame, text="Desglosar por M√©todo de Pago", 
                          variable=tk.BooleanVar(value=False),
                          font=('Arial', 10), bg='#F8FAFC').pack(anchor='w', pady=2)
        elif report_type == "appointments":
            tk.Checkbutton(options_frame, text="Agrupar por Doctor", 
                          variable=tk.BooleanVar(value=True),
                          font=('Arial', 10), bg='#F8FAFC').pack(anchor='w', pady=2)
        
        # Botones de acci√≥n
        buttons_frame = tk.Frame(content, bg='#F8FAFC')
        buttons_frame.pack(fill='x', pady=(15, 0))
        
        def generate_report():
            """Generar el reporte con las configuraciones seleccionadas"""
            # Calcular fechas seg√∫n el per√≠odo seleccionado
            start_date, end_date = self.calculate_date_range(period_var.get(), 
                                                           start_date_var.get(), 
                                                           end_date_var.get())
            
            config = {
                'report_type': report_type,
                'title': report_title,
                'start_date': start_date,
                'end_date': end_date,
                'output_format': output_var.get(),
                'include_charts': include_charts.get(),
                'include_details': include_details.get(),
                'include_summary': include_summary.get()
            }
            
            dialog.destroy()
            
            # Generar reporte seg√∫n el formato seleccionado
            if config['output_format'] == 'Vista Previa':
                self.show_report_preview(config)
            else:
                self.generate_report_file(config)
        
        def preview_report():
            """Mostrar vista previa del reporte"""
            start_date, end_date = self.calculate_date_range(period_var.get(), 
                                                           start_date_var.get(), 
                                                           end_date_var.get())
            
            config = {
                'report_type': report_type,
                'title': report_title,
                'start_date': start_date,
                'end_date': end_date,
                'output_format': 'Vista Previa',
                'include_charts': include_charts.get(),
                'include_details': include_details.get(),
                'include_summary': include_summary.get()
            }
            
            self.show_report_preview(config)
        
        # Botones
        tk.Button(buttons_frame, text="üëÅÔ∏è Vista Previa", command=preview_report,
                 bg='#64748B', fg='white', font=('Arial', 10, 'bold'),
                 padx=20, pady=8).pack(side='left', padx=(0, 10))
        
        tk.Button(buttons_frame, text="üìä Generar Reporte", command=generate_report,
                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                 padx=20, pady=8).pack(side='left', padx=(0, 10))
        
        tk.Button(buttons_frame, text="‚ùå Cancelar", command=dialog.destroy,
                 bg='#C0392B', fg='white', font=('Arial', 10, 'bold'),
                 padx=20, pady=8).pack(side='right')

    def calculate_date_range(self, period, custom_start, custom_end):
        """Calcular rango de fechas seg√∫n el per√≠odo seleccionado"""
        today = datetime.now()
        
        if period == 'Hoy':
            start_date = today.replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = today.replace(hour=23, minute=59, second=59, microsecond=999999)
        elif period == 'Ayer':
            yesterday = today - timedelta(days=1)
            start_date = yesterday.replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = yesterday.replace(hour=23, minute=59, second=59, microsecond=999999)
        elif period == 'Esta Semana':
            start_date = today - timedelta(days=today.weekday())
            start_date = start_date.replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = today.replace(hour=23, minute=59, second=59, microsecond=999999)
        elif period == 'Semana Pasada':
            start_date = today - timedelta(days=today.weekday() + 7)
            start_date = start_date.replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = start_date + timedelta(days=6, hours=23, minutes=59, seconds=59, microseconds=999999)
        elif period == 'Este Mes':
            start_date = today.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
            end_date = today.replace(hour=23, minute=59, second=59, microsecond=999999)
        elif period == 'Mes Pasado':
            first_day_this_month = today.replace(day=1)
            last_day_last_month = first_day_this_month - timedelta(days=1)
            start_date = last_day_last_month.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
            end_date = last_day_last_month.replace(hour=23, minute=59, second=59, microsecond=999999)
        elif period == 'Este A√±o':
            start_date = today.replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
            end_date = today.replace(hour=23, minute=59, second=59, microsecond=999999)
        elif period == 'A√±o Pasado':
            start_date = today.replace(year=today.year-1, month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
            end_date = today.replace(year=today.year-1, month=12, day=31, hour=23, minute=59, second=59, microsecond=999999)
        else:  # Personalizado
            try:
                start_date = datetime.strptime(custom_start, '%Y-%m-%d')
                end_date = datetime.strptime(custom_end, '%Y-%m-%d')
                end_date = end_date.replace(hour=23, minute=59, second=59, microsecond=999999)
            except ValueError:
                start_date = today.replace(hour=0, minute=0, second=0, microsecond=0)
                end_date = today.replace(hour=23, minute=59, second=59, microsecond=999999)
        
        return start_date, end_date

    def select_date_calendar(self, date_var):
        """Abrir selector de fecha con calendario"""
        if not CALENDAR_AVAILABLE:
            return
        
        try:
            from tkinter import simpledialog
            date_str = simpledialog.askstring("Fecha", "Ingrese fecha (YYYY-MM-DD):", 
                                            initialvalue=date_var.get())
            if date_str:
                # Validar formato de fecha
                try:
                    datetime.strptime(date_str, '%Y-%m-%d')
                    date_var.set(date_str)
                except ValueError:
                    messagebox.showerror("Error", "Formato de fecha inv√°lido. Use YYYY-MM-DD")
        except Exception as e:
            messagebox.showerror("Error", f"Error seleccionando fecha: {str(e)}")

    def show_report_preview(self, config):
        """Mostrar vista previa del reporte en una ventana"""
        preview_window = tk.Toplevel(self.root)
        preview_window.title(f"Vista Previa - {config['title']}")
        preview_window.geometry("900x700")
        preview_window.configure(bg='#F8FAFC')
        
        # Centrar ventana
        preview_window.update_idletasks()
        x = (preview_window.winfo_screenwidth() // 2) - (900 // 2)
        y = (preview_window.winfo_screenheight() // 2) - (700 // 2)
        preview_window.geometry(f"900x700+{x}+{y}")
        
        # Header de la vista previa
        header = tk.Frame(preview_window, bg='#1E3A8A', height=60)
        header.pack(fill='x')
        header.pack_propagate(False)
        
        header_content = tk.Frame(header, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=20, pady=15)
        
        tk.Label(header_content, text="üëÅÔ∏è", font=('Arial', 16), bg='#1E3A8A', fg='white').pack(side='left')
        tk.Label(header_content, text=f"VISTA PREVIA - {config['title'].upper()}", 
                font=('Arial', 12, 'bold'), bg='#1E3A8A', fg='white').pack(side='left', padx=(10, 0))
        
        # Botones en el header
        buttons_header = tk.Frame(header_content, bg='#1E3A8A')
        buttons_header.pack(side='right')
        
        tk.Button(buttons_header, text="üìÑ Generar PDF", 
                 command=lambda: self.generate_pdf_from_preview(config),
                 bg='#0B5394', fg='white', font=('Arial', 9, 'bold')).pack(side='left', padx=5)
        
        tk.Button(buttons_header, text="üìä Generar Excel", 
                 command=lambda: self.generate_excel_from_preview(config),
                 bg='#16A085', fg='white', font=('Arial', 9, 'bold')).pack(side='left', padx=5)
        
        tk.Button(buttons_header, text="‚ùå Cerrar", 
                 command=preview_window.destroy,
                 bg='#C0392B', fg='white', font=('Arial', 9, 'bold')).pack(side='left', padx=5)
        
        # √Årea de contenido con scroll
        content_frame = tk.Frame(preview_window, bg='white')
        content_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Canvas para scroll
        canvas = tk.Canvas(content_frame, bg='white')
        scrollbar = ttk.Scrollbar(content_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='white')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Generar contenido del reporte
        self.generate_report_content(scrollable_frame, config)
        
        # Habilitar scroll con mouse
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        canvas.bind("<MouseWheel>", _on_mousewheel)

    def generate_report_content(self, parent, config):
        """Generar contenido visual del reporte"""
        try:
            # Header del reporte
            self.create_report_header(parent, config)
            
            # Separador
            tk.Frame(parent, bg='#E5E7EB', height=2).pack(fill='x', pady=10)
            
            # Resumen ejecutivo
            if config['include_summary']:
                self.create_report_summary(parent, config)
            
            # Contenido principal seg√∫n el tipo de reporte
            if config['report_type'] == 'income':
                self.create_income_report_content(parent, config)
            elif config['report_type'] == 'pending_invoices':
                self.create_pending_invoices_content(parent, config)
            elif config['report_type'] == 'users':
                self.create_users_report_content(parent, config)
            elif config['report_type'] == 'appointments':
                self.create_appointments_report_content(parent, config)
            elif config['report_type'] == 'financial':
                self.create_financial_report_content(parent, config)
            elif config['report_type'] == 'services':
                self.create_services_report_content(parent, config)
            
            # Footer del reporte
            self.create_report_footer(parent, config)
            
        except Exception as e:
            tk.Label(parent, text=f"Error generando reporte: {str(e)}", 
                    fg='red', font=('Arial', 12)).pack(pady=20)

    def create_report_header(self, parent, config):
        """Crear header del reporte"""
        header_frame = tk.Frame(parent, bg='white')
        header_frame.pack(fill='x', pady=(0, 20))
        
        # Logo y t√≠tulo principal
        title_frame = tk.Frame(header_frame, bg='white')
        title_frame.pack(fill='x')
        
        tk.Label(title_frame, text="üè• MEDISYNC", font=('Arial', 20, 'bold'), 
                fg='#1E3A8A', bg='white').pack(side='left')
        tk.Label(title_frame, text="Sistema de Gesti√≥n M√©dica", font=('Arial', 12), 
                fg='#64748B', bg='white').pack(side='left', padx=(10, 0))
        
        # Fecha y hora de generaci√≥n
        generation_time = datetime.now().strftime('%d/%m/%Y %H:%M:%S')
        tk.Label(title_frame, text=f"Generado: {generation_time}", font=('Arial', 10), 
                fg='#64748B', bg='white').pack(side='right')
        
        # T√≠tulo del reporte
        tk.Label(header_frame, text=config['title'], font=('Arial', 18, 'bold'), 
                fg='#1E3A8A', bg='white').pack(pady=10)
        
        # Per√≠odo del reporte
        period_text = f"Per√≠odo: {config['start_date'].strftime('%d/%m/%Y')} - {config['end_date'].strftime('%d/%m/%Y')}"
        tk.Label(header_frame, text=period_text, font=('Arial', 12), 
                fg='#059669', bg='white').pack()

    def create_report_summary(self, parent, config):
        """Crear resumen ejecutivo del reporte"""
        summary_frame = tk.LabelFrame(parent, text="üìä Resumen Ejecutivo", 
                                     font=('Arial', 14, 'bold'), padx=20, pady=15, bg='white')
        summary_frame.pack(fill='x', pady=(0, 20))
        
        try:
            # Obtener datos para el resumen seg√∫n el tipo de reporte
            summary_data = self.get_report_summary_data(config)
            
            # Grid de m√©tricas principales
            metrics_frame = tk.Frame(summary_frame, bg='white')
            metrics_frame.pack(fill='x')
            
            for i, (label, value, color) in enumerate(summary_data):
                metric_card = tk.Frame(metrics_frame, bg='#F8FAFC', relief='solid', bd=1)
                metric_card.grid(row=i//3, column=i%3, padx=10, pady=10, sticky='ew')
                
                tk.Label(metric_card, text=str(value), font=('Arial', 16, 'bold'), 
                        fg=color, bg='#F8FAFC').pack(pady=(10, 5))
                tk.Label(metric_card, text=label, font=('Arial', 10), 
                        fg='#64748B', bg='#F8FAFC').pack(pady=(0, 10))
            
            # Configurar expansi√≥n del grid
            for i in range(3):
                metrics_frame.grid_columnconfigure(i, weight=1)
                
        except Exception as e:
            tk.Label(summary_frame, text=f"Error en resumen: {str(e)}", 
                    fg='red', bg='white').pack()

    def create_income_report_content(self, parent, config):
        """Crear contenido espec√≠fico del reporte de ingresos"""
        content_frame = tk.LabelFrame(parent, text="üí∞ An√°lisis de Ingresos", 
                                     font=('Arial', 14, 'bold'), padx=20, pady=15, bg='white')
        content_frame.pack(fill='x', pady=(0, 20))
        
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Consulta de ingresos por per√≠odo
            cursor.execute("""
                SELECT DATE(fecha_creacion) as fecha, SUM(monto) as total_dia, COUNT(*) as num_facturas
                FROM facturas 
                WHERE fecha_creacion BETWEEN ? AND ? AND estado IN ('pagada', 'pago_parcial')
                GROUP BY DATE(fecha_creacion)
                ORDER BY fecha
            """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
            
            income_data = cursor.fetchall()
            
            if income_data:
                # Tabla de ingresos diarios
                table_frame = tk.Frame(content_frame, bg='white')
                table_frame.pack(fill='x', pady=10)
                
                # Headers
                headers = ['Fecha', 'Ingresos', 'Facturas', 'Promedio']
                header_frame = tk.Frame(table_frame, bg='#1E3A8A')
                header_frame.pack(fill='x')
                
                for header in headers:
                    tk.Label(header_frame, text=header, font=('Arial', 12, 'bold'), 
                            fg='white', bg='#1E3A8A', width=15).pack(side='left', padx=1, pady=8)
                
                # Datos
                total_income = 0
                total_invoices = 0
                
                for fecha, total_dia, num_facturas in income_data:
                    row_frame = tk.Frame(table_frame, bg='#F8FAFC')
                    row_frame.pack(fill='x')
                    
                    promedio = total_dia / num_facturas if num_facturas > 0 else 0
                    total_income += total_dia
                    total_invoices += num_facturas
                    
                    values = [
                        datetime.fromisoformat(fecha).strftime('%d/%m/%Y'),
                        f"RD${total_dia:,.2f}",
                        str(num_facturas),
                        f"RD${promedio:,.2f}"
                    ]
                    
                    for value in values:
                        tk.Label(row_frame, text=value, font=('Arial', 10), 
                                fg='#1E293B', bg='#F8FAFC', width=15).pack(side='left', padx=1, pady=5)
                
                # Totales
                total_frame = tk.Frame(table_frame, bg='#059669')
                total_frame.pack(fill='x')
                
                total_avg = total_income / total_invoices if total_invoices > 0 else 0
                total_values = [
                    'TOTAL',
                    f"RD${total_income:,.2f}",
                    str(total_invoices),
                    f"RD${total_avg:,.2f}"
                ]
                
                for value in total_values:
                    tk.Label(total_frame, text=value, font=('Arial', 12, 'bold'), 
                            fg='white', bg='#0B5394', width=15).pack(side='left', padx=1, pady=8)
            else:
                tk.Label(content_frame, text="No hay datos de ingresos para el per√≠odo seleccionado", 
                        font=('Arial', 12), fg='#64748B', bg='white').pack(pady=20)
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            tk.Label(content_frame, text=f"Error cargando datos: {str(e)}", 
                    fg='red', bg='white').pack()

    def create_appointments_report_content(self, parent, config):
        """Crear contenido del reporte de citas"""
        content_frame = tk.LabelFrame(parent, text="üìÖ An√°lisis de Citas", 
                                     font=('Arial', 14, 'bold'), padx=20, pady=15, bg='white')
        content_frame.pack(fill='x', pady=(0, 20))
        
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Citas por estado
            cursor.execute("""
                SELECT estado, COUNT(*) as cantidad
                FROM citas 
                WHERE fecha_hora BETWEEN ? AND ?
                GROUP BY estado
                ORDER BY cantidad DESC
            """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
            
            status_data = cursor.fetchall()
            
            if status_data:
                # Tabla de estados
                table_frame = tk.Frame(content_frame, bg='white')
                table_frame.pack(fill='x', pady=10)
                
                tk.Label(table_frame, text="Distribuci√≥n por Estado", font=('Arial', 12, 'bold'), 
                        fg='#1E3A8A', bg='white').pack(pady=(0, 10))
                
                for estado, cantidad in status_data:
                    row_frame = tk.Frame(table_frame, bg='#F8FAFC')
                    row_frame.pack(fill='x', pady=2)
                    
                    tk.Label(row_frame, text=f"{estado.title()}:", font=('Arial', 10, 'bold'), 
                            fg='#1E293B', bg='#F8FAFC', width=15, anchor='w').pack(side='left')
                    tk.Label(row_frame, text=str(cantidad), font=('Arial', 10), 
                            fg='#059669', bg='#F8FAFC', width=10, anchor='e').pack(side='right')
            
            # Citas por doctor
            cursor.execute("""
                SELECT u.nombre || ' ' || u.apellido as doctor, COUNT(*) as cantidad
                FROM citas c
                JOIN usuarios u ON c.doctor_id = u.id
                WHERE c.fecha_hora BETWEEN ? AND ?
                GROUP BY u.id, u.nombre, u.apellido
                ORDER BY cantidad DESC
                LIMIT 10
            """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
            
            doctor_data = cursor.fetchall()
            
            if doctor_data:
                doctor_frame = tk.Frame(content_frame, bg='white')
                doctor_frame.pack(fill='x', pady=(20, 0))
                
                tk.Label(doctor_frame, text="Top 10 Doctores por Citas", font=('Arial', 12, 'bold'), 
                        fg='#1E3A8A', bg='white').pack(pady=(0, 10))
                
                for doctor, cantidad in doctor_data:
                    row_frame = tk.Frame(doctor_frame, bg='#F8FAFC')
                    row_frame.pack(fill='x', pady=2)
                    
                    tk.Label(row_frame, text=f"Dr. {doctor}:", font=('Arial', 10), 
                            fg='#1E293B', bg='#F8FAFC', width=25, anchor='w').pack(side='left')
                    tk.Label(row_frame, text=str(cantidad), font=('Arial', 10, 'bold'), 
                            fg='#059669', bg='#F8FAFC', width=10, anchor='e').pack(side='right')
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            tk.Label(content_frame, text=f"Error cargando datos: {str(e)}", 
                    fg='red', bg='white').pack()

    def create_users_report_content(self, parent, config):
        """Crear contenido del reporte de usuarios"""
        content_frame = tk.LabelFrame(parent, text="üë• An√°lisis de Usuarios", 
                                     font=('Arial', 14, 'bold'), padx=20, pady=15, bg='white')
        content_frame.pack(fill='x', pady=(0, 20))
        
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Usuarios por rol
            cursor.execute("""
                SELECT rol, COUNT(*) as cantidad
                FROM usuarios 
                GROUP BY rol
                ORDER BY cantidad DESC
            """)
            
            role_data = cursor.fetchall()
            
            if role_data:
                table_frame = tk.Frame(content_frame, bg='white')
                table_frame.pack(fill='x', pady=10)
                
                tk.Label(table_frame, text="Distribuci√≥n por Rol", font=('Arial', 12, 'bold'), 
                        fg='#1E3A8A', bg='white').pack(pady=(0, 10))
                
                total_users = sum(cantidad for _, cantidad in role_data)
                
                for rol, cantidad in role_data:
                    percentage = (cantidad / total_users) * 100 if total_users > 0 else 0
                    
                    row_frame = tk.Frame(table_frame, bg='#F8FAFC')
                    row_frame.pack(fill='x', pady=2)
                    
                    tk.Label(row_frame, text=f"{rol.title()}:", font=('Arial', 10, 'bold'), 
                            fg='#1E293B', bg='#F8FAFC', width=15, anchor='w').pack(side='left')
                    tk.Label(row_frame, text=f"{cantidad} ({percentage:.1f}%)", font=('Arial', 10), 
                            fg='#059669', bg='#F8FAFC', width=15, anchor='e').pack(side='right')
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            tk.Label(content_frame, text=f"Error cargando datos: {str(e)}", 
                    fg='red', bg='white').pack()

    def create_pending_invoices_content(self, parent, config):
        """Crear contenido del reporte de facturas pendientes"""
        content_frame = tk.LabelFrame(parent, text="üìã Facturas Pendientes", 
                                     font=('Arial', 14, 'bold'), padx=20, pady=15, bg='white')
        content_frame.pack(fill='x', pady=(0, 20))
        
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT f.numero_factura, f.fecha_creacion, 
                       u.nombre || ' ' || u.apellido as paciente,
                       f.monto, f.estado
                FROM facturas f
                JOIN usuarios u ON f.paciente_id = u.id
                WHERE f.estado = 'pendiente' 
                AND f.fecha_creacion BETWEEN ? AND ?
                ORDER BY f.fecha_creacion DESC
            """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
            
            pending_data = cursor.fetchall()
            
            if pending_data:
                # Crear tabla de facturas pendientes
                table_frame = tk.Frame(content_frame, bg='white')
                table_frame.pack(fill='x', pady=10)
                
                # Headers
                headers = ['N√∫mero', 'Fecha', 'Paciente', 'Monto', 'D√≠as Pendiente']
                header_frame = tk.Frame(table_frame, bg='#0B5394')
                header_frame.pack(fill='x')
                
                for header in headers:
                    tk.Label(header_frame, text=header, font=('Arial', 11, 'bold'), 
                            fg='white', bg='#0B5394', width=15).pack(side='left', padx=1, pady=8)
                
                total_pending = 0
                
                for numero, fecha_str, paciente, monto, estado in pending_data:
                    row_frame = tk.Frame(table_frame, bg='#FFEBEE')
                    row_frame.pack(fill='x')
                    
                    fecha_creacion = datetime.fromisoformat(fecha_str)
                    dias_pendiente = (datetime.now() - fecha_creacion).days
                    total_pending += monto
                    
                    values = [
                        numero,
                        fecha_creacion.strftime('%d/%m/%Y'),
                        paciente[:20] + '...' if len(paciente) > 20 else paciente,
                        f"RD${monto:,.2f}",
                        f"{dias_pendiente} d√≠as"
                    ]
                    
                    for value in values:
                        tk.Label(row_frame, text=str(value), font=('Arial', 9), 
                                fg='#1E293B', bg='#FFEBEE', width=15).pack(side='left', padx=1, pady=3)
                
                # Total
                total_frame = tk.Frame(table_frame, bg='#0B5394')
                total_frame.pack(fill='x')
                
                tk.Label(total_frame, text=f"TOTAL PENDIENTE: RD${total_pending:,.2f}", 
                        font=('Arial', 12, 'bold'), fg='white', bg='#0B5394').pack(pady=8)
            else:
                tk.Label(content_frame, text="¬°Excelente! No hay facturas pendientes en este per√≠odo", 
                        font=('Arial', 12), fg='#0B5394', bg='white').pack(pady=20)
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            tk.Label(content_frame, text=f"Error cargando datos: {str(e)}", 
                    fg='red', bg='white').pack()

    def create_financial_report_content(self, parent, config):
        """Crear contenido del reporte financiero"""
        content_frame = tk.LabelFrame(parent, text="üí∞ Estado Financiero", 
                                     font=('Arial', 14, 'bold'), padx=20, pady=15, bg='white')
        content_frame.pack(fill='x', pady=(0, 20))
        
        try:
            cursor = self.db_manager.connection.cursor()
            
            # Obtener ingresos
            cursor.execute("""
                SELECT SUM(monto) as total_ingresos
                FROM facturas 
                WHERE estado = 'pagada' 
                AND fecha_pago BETWEEN ? AND ?
            """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
            ingresos_result = cursor.fetchone()
            total_ingresos = ingresos_result[0] if ingresos_result[0] else 0
            
            # Obtener facturas pendientes
            cursor.execute("""
                SELECT SUM(monto) as total_pendiente
                FROM facturas 
                WHERE estado = 'pendiente' 
                AND fecha_creacion BETWEEN ? AND ?
            """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
            pendientes_result = cursor.fetchone()
            total_pendiente = pendientes_result[0] if pendientes_result[0] else 0
            
            # Obtener n√∫mero de transacciones
            cursor.execute("""
                SELECT COUNT(*) as num_facturas_pagadas
                FROM facturas 
                WHERE estado = 'pagada' 
                AND fecha_pago BETWEEN ? AND ?
            """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
            num_pagadas = cursor.fetchone()[0]
            
            cursor.execute("""
                SELECT COUNT(*) as num_facturas_pendientes
                FROM facturas 
                WHERE estado = 'pendiente' 
                AND fecha_creacion BETWEEN ? AND ?
            """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
            num_pendientes = cursor.fetchone()[0]
            
            # Frame de m√©tricas principales
            metrics_frame = tk.Frame(content_frame, bg='white')
            metrics_frame.pack(fill='x', pady=(0, 20))
            
            # Ingresos
            income_card = tk.Frame(metrics_frame, bg='#0B5394', relief='raised', bd=2)
            income_card.pack(side='left', fill='both', expand=True, padx=(0, 10))
            tk.Label(income_card, text="üí∞ INGRESOS TOTALES", font=('Arial', 10, 'bold'), 
                    fg='white', bg='#0B5394').pack(pady=(10, 5))
            tk.Label(income_card, text=f"RD${total_ingresos:,.2f}", font=('Arial', 14, 'bold'), 
                    fg='white', bg='#0B5394').pack(pady=(0, 5))
            tk.Label(income_card, text=f"{num_pagadas} facturas pagadas", font=('Arial', 9), 
                    fg='white', bg='#0B5394').pack(pady=(0, 10))
            
            # Pendientes
            pending_card = tk.Frame(metrics_frame, bg='#0B5394', relief='raised', bd=2)
            pending_card.pack(side='left', fill='both', expand=True, padx=(5, 5))
            tk.Label(pending_card, text="‚è≥ CUENTAS POR COBRAR", font=('Arial', 10, 'bold'), 
                    fg='white', bg='#0B5394').pack(pady=(10, 5))
            tk.Label(pending_card, text=f"RD${total_pendiente:,.2f}", font=('Arial', 14, 'bold'), 
                    fg='white', bg='#0B5394').pack(pady=(0, 5))
            tk.Label(pending_card, text=f"{num_pendientes} facturas pendientes", font=('Arial', 9), 
                    fg='white', bg='#0B5394').pack(pady=(0, 10))
            
            # Total neto
            total_neto = total_ingresos + total_pendiente
            total_card = tk.Frame(metrics_frame, bg='#0B5394', relief='raised', bd=2)
            total_card.pack(side='left', fill='both', expand=True, padx=(10, 0))
            tk.Label(total_card, text="üìä FACTURACI√ìN TOTAL", font=('Arial', 10, 'bold'), 
                    fg='white', bg='#0B5394').pack(pady=(10, 5))
            tk.Label(total_card, text=f"RD${total_neto:,.2f}", font=('Arial', 14, 'bold'), 
                    fg='white', bg='#0B5394').pack(pady=(0, 5))
            tk.Label(total_card, text=f"{num_pagadas + num_pendientes} facturas totales", font=('Arial', 9), 
                    fg='white', bg='#0B5394').pack(pady=(0, 10))
            
            # An√°lisis de eficiencia de cobro
            if total_neto > 0:
                efficiency_frame = tk.Frame(content_frame, bg='white')
                efficiency_frame.pack(fill='x', pady=(10, 0))
                
                tk.Label(efficiency_frame, text="üìà An√°lisis de Eficiencia de Cobro", 
                        font=('Arial', 12, 'bold'), fg='#1E293B', bg='white').pack(anchor='w')
                
                cobro_percentage = (total_ingresos / total_neto) * 100
                pendiente_percentage = (total_pendiente / total_neto) * 100
                
                # Barra de progreso visual
                progress_frame = tk.Frame(efficiency_frame, bg='white')
                progress_frame.pack(fill='x', pady=10)
                
                # Barra de cobrado
                cobrado_width = int((cobro_percentage / 100) * 300)
                if cobrado_width > 0:
                    cobrado_bar = tk.Frame(progress_frame, bg='#0B5394', height=25)
                    cobrado_bar.pack(side='left', fill='y')
                    cobrado_bar.config(width=cobrado_width)
                    tk.Label(cobrado_bar, text=f"Cobrado: {cobro_percentage:.1f}%", 
                            font=('Arial', 9, 'bold'), fg='white', bg='#0B5394').pack(pady=3)
                
                # Barra de pendiente
                pendiente_width = int((pendiente_percentage / 100) * 300)
                if pendiente_width > 0:
                    pendiente_bar = tk.Frame(progress_frame, bg='#0B5394', height=25)
                    pendiente_bar.pack(side='left', fill='y')
                    pendiente_bar.config(width=pendiente_width)
                    tk.Label(pendiente_bar, text=f"Pendiente: {pendiente_percentage:.1f}%", 
                            font=('Arial', 9, 'bold'), fg='white', bg='#0B5394').pack(pady=3)
                
                # Recomendaciones
                recommendations_frame = tk.Frame(content_frame, bg='#F8F9FA', relief='sunken', bd=1)
                recommendations_frame.pack(fill='x', pady=(15, 0))
                
                tk.Label(recommendations_frame, text="üí° Recomendaciones", 
                        font=('Arial', 11, 'bold'), fg='#1E293B', bg='#F8F9FA').pack(anchor='w', padx=10, pady=(10, 5))
                
                if pendiente_percentage > 30:
                    tk.Label(recommendations_frame, text="‚Ä¢ Alto porcentaje de cuentas por cobrar - revisar procesos de cobro", 
                            font=('Arial', 10), fg='#0B5394', bg='#F8F9FA').pack(anchor='w', padx=20)
                elif pendiente_percentage > 15:
                    tk.Label(recommendations_frame, text="‚Ä¢ Porcentaje moderado de cuentas por cobrar - seguimiento regular", 
                            font=('Arial', 10), fg='#0B5394', bg='#F8F9FA').pack(anchor='w', padx=20)
                else:
                    tk.Label(recommendations_frame, text="‚Ä¢ Excelente eficiencia de cobro - mantener procesos actuales", 
                            font=('Arial', 10), fg='#0B5394', bg='#F8F9FA').pack(anchor='w', padx=20)
                
                if num_pendientes > 0:
                    tk.Label(recommendations_frame, text=f"‚Ä¢ Revisar {num_pendientes} facturas pendientes para acelerar cobro", 
                            font=('Arial', 10), fg='#0B5394', bg='#F8F9FA').pack(anchor='w', padx=20, pady=(0, 10))
            
        except Exception as e:
            tk.Label(content_frame, text=f"Error cargando datos financieros: {str(e)}", 
                    font=('Arial', 12), fg='red', bg='white').pack(pady=20)

    def create_services_report_content(self, parent, config):
        """Crear contenido del reporte de servicios"""
        content_frame = tk.LabelFrame(parent, text="üè• An√°lisis de Servicios", 
                                     font=('Arial', 14, 'bold'), padx=20, pady=15, bg='white')
        content_frame.pack(fill='x', pady=(0, 20))
        
        try:
            cursor = self.db_manager.connection.cursor()
            
            # Obtener estad√≠sticas de citas por estado
            cursor.execute("""
                SELECT estado, COUNT(*) as cantidad
                FROM citas 
                WHERE fecha BETWEEN ? AND ?
                GROUP BY estado
                ORDER BY cantidad DESC
            """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
            citas_estado = cursor.fetchall()
            
            # Obtener servicios m√°s solicitados (basado en motivo de citas)
            cursor.execute("""
                SELECT motivo, COUNT(*) as cantidad
                FROM citas 
                WHERE fecha BETWEEN ? AND ? AND motivo IS NOT NULL AND motivo != ''
                GROUP BY motivo
                ORDER BY cantidad DESC
                LIMIT 10
            """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
            servicios_populares = cursor.fetchall()
            
            # Obtener an√°lisis por doctor
            cursor.execute("""
                SELECT u.nombre_completo, COUNT(c.id) as num_citas, 
                       AVG(f.monto) as promedio_factura
                FROM citas c
                JOIN usuarios u ON c.doctor_id = u.id
                LEFT JOIN facturas f ON f.paciente_id = c.paciente_id 
                    AND DATE(f.fecha_creacion) = DATE(c.fecha)
                WHERE c.fecha BETWEEN ? AND ?
                GROUP BY c.doctor_id, u.nombre_completo
                ORDER BY num_citas DESC
            """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
            doctor_stats = cursor.fetchall()
            
            # Frame principal con dos columnas
            main_frame = tk.Frame(content_frame, bg='white')
            main_frame.pack(fill='x', pady=(0, 20))
            
            # Columna izquierda - Estados de citas
            left_frame = tk.Frame(main_frame, bg='white')
            left_frame.pack(side='left', fill='both', expand=True, padx=(0, 10))
            
            tk.Label(left_frame, text="üìä Estados de Citas", font=('Arial', 12, 'bold'), 
                    fg='#1E293B', bg='white').pack(anchor='w', pady=(0, 10))
            
            if citas_estado:
                total_citas = sum(cantidad for _, cantidad in citas_estado)
                
                for estado, cantidad in citas_estado:
                    porcentaje = (cantidad / total_citas) * 100
                    
                    # Determinar color seg√∫n estado
                    color = '#0B5394' if estado == 'confirmada' else \
                           '#0B5394' if estado == 'cancelada' else \
                           '#0B5394' if estado == 'pendiente' else '#6B7280'
                    
                    estado_frame = tk.Frame(left_frame, bg=color, relief='raised', bd=1)
                    estado_frame.pack(fill='x', pady=2)
                    
                    info_frame = tk.Frame(estado_frame, bg=color)
                    info_frame.pack(fill='x', padx=10, pady=5)
                    
                    tk.Label(info_frame, text=estado.capitalize(), font=('Arial', 10, 'bold'), 
                            fg='white', bg=color).pack(side='left')
                    tk.Label(info_frame, text=f"{cantidad} ({porcentaje:.1f}%)", font=('Arial', 10), 
                            fg='white', bg=color).pack(side='right')
            
            # Columna derecha - Servicios populares
            right_frame = tk.Frame(main_frame, bg='white')
            right_frame.pack(side='right', fill='both', expand=True, padx=(10, 0))
            
            tk.Label(right_frame, text="üéØ Servicios M√°s Solicitados", font=('Arial', 12, 'bold'), 
                    fg='#1E293B', bg='white').pack(anchor='w', pady=(0, 10))
            
            if servicios_populares:
                for i, (motivo, cantidad) in enumerate(servicios_populares[:5]):
                    # Gradiente de colores - solo azul est√°ndar
                    colors = ['#0B5394', '#0B5394', '#0B5394', '#0B5394', '#0B5394']
                    color = colors[i % len(colors)]
                    
                    servicio_frame = tk.Frame(right_frame, bg=color, relief='raised', bd=1)
                    servicio_frame.pack(fill='x', pady=2)
                    
                    info_frame = tk.Frame(servicio_frame, bg=color)
                    info_frame.pack(fill='x', padx=10, pady=5)
                    
                    # Truncar texto si es muy largo
                    motivo_display = motivo[:25] + '...' if len(motivo) > 25 else motivo
                    
                    tk.Label(info_frame, text=motivo_display, font=('Arial', 9, 'bold'), 
                            fg='white', bg=color).pack(side='left')
                    tk.Label(info_frame, text=f"{cantidad}", font=('Arial', 9), 
                            fg='white', bg=color).pack(side='right')
            
            # An√°lisis por doctor
            if doctor_stats:
                doctor_frame = tk.Frame(content_frame, bg='white')
                doctor_frame.pack(fill='x', pady=(15, 0))
                
                tk.Label(doctor_frame, text="üë®‚Äç‚öïÔ∏è Rendimiento por Doctor", font=('Arial', 12, 'bold'), 
                        fg='#1E293B', bg='white').pack(anchor='w', pady=(0, 10))
                
                # Headers de tabla
                header_frame = tk.Frame(doctor_frame, bg='#0B5394')
                header_frame.pack(fill='x')
                
                headers = ['Doctor', 'Citas Atendidas', 'Promedio Facturaci√≥n']
                header_widths = [30, 15, 20]
                
                for header, width in zip(headers, header_widths):
                    tk.Label(header_frame, text=header, font=('Arial', 10, 'bold'), 
                            fg='white', bg='#0B5394', width=width).pack(side='left', padx=1, pady=8)
                
                # Datos de doctores
                for doctor, num_citas, promedio in doctor_stats[:5]:  # Top 5 doctores
                    row_frame = tk.Frame(doctor_frame, bg='#F8F9FA')
                    row_frame.pack(fill='x')
                    
                    promedio_display = f"RD${promedio:,.2f}" if promedio else "N/A"
                    
                    values = [
                        doctor[:28] + '...' if len(doctor) > 28 else doctor,
                        str(num_citas),
                        promedio_display
                    ]
                    
                    for value, width in zip(values, header_widths):
                        tk.Label(row_frame, text=value, font=('Arial', 9), 
                                fg='#1E293B', bg='#F8F9FA', width=width).pack(side='left', padx=1, pady=4)
            
            # Resumen de actividad
            summary_frame = tk.Frame(content_frame, bg='#EEF2FF', relief='sunken', bd=1)
            summary_frame.pack(fill='x', pady=(15, 0))
            
            tk.Label(summary_frame, text="üìã Resumen de Actividad", font=('Arial', 11, 'bold'), 
                    fg='#1E293B', bg='#EEF2FF').pack(anchor='w', padx=10, pady=(10, 5))
            
            if citas_estado:
                total_citas = sum(cantidad for _, cantidad in citas_estado)
                confirmadas = next((cantidad for estado, cantidad in citas_estado if estado == 'confirmada'), 0)
                
                tk.Label(summary_frame, text=f"‚Ä¢ Total de citas programadas: {total_citas}", 
                        font=('Arial', 10), fg='#374151', bg='#EEF2FF').pack(anchor='w', padx=20)
                tk.Label(summary_frame, text=f"‚Ä¢ Citas confirmadas: {confirmadas} ({(confirmadas/total_citas)*100:.1f}%)", 
                        font=('Arial', 10), fg='#374151', bg='#EEF2FF').pack(anchor='w', padx=20)
                
                if servicios_populares:
                    servicio_top = servicios_populares[0][0] if servicios_populares else "N/A"
                    tk.Label(summary_frame, text=f"‚Ä¢ Servicio m√°s solicitado: {servicio_top}", 
                            font=('Arial', 10), fg='#374151', bg='#EEF2FF').pack(anchor='w', padx=20)
                
                if doctor_stats:
                    doctor_top = doctor_stats[0][0] if doctor_stats else "N/A"
                    tk.Label(summary_frame, text=f"‚Ä¢ Doctor con m√°s citas: {doctor_top}", 
                            font=('Arial', 10), fg='#374151', bg='#EEF2FF').pack(anchor='w', padx=20, pady=(0, 10))
            
        except Exception as e:
            tk.Label(content_frame, text=f"Error cargando datos de servicios: {str(e)}", 
                    font=('Arial', 12), fg='red', bg='white').pack(pady=20)

    def create_report_footer(self, parent, config):
        """Crear footer del reporte"""
        footer_frame = tk.Frame(parent, bg='white')
        footer_frame.pack(fill='x', pady=(20, 0))
        
        # Separador
        tk.Frame(footer_frame, bg='#E5E7EB', height=2).pack(fill='x', pady=(0, 15))
        
        # Informaci√≥n del footer
        footer_text = f"""
Este reporte fue generado autom√°ticamente por MEDISYNC
Fecha de generaci√≥n: {datetime.now().strftime('%d/%m/%Y a las %H:%M:%S')}
Per√≠odo analizado: {config['start_date'].strftime('%d/%m/%Y')} - {config['end_date'].strftime('%d/%m/%Y')}
        
Para consultas sobre este reporte, contacte al departamento de administraci√≥n.
¬© 2025 MEDISYNC - Sistema de Gesti√≥n M√©dica Integral
        """
        
        tk.Label(footer_frame, text=footer_text.strip(), font=('Arial', 9), 
                fg='#64748B', bg='white', justify='center').pack()

    def get_report_summary_data(self, config):
        """Obtener datos de resumen seg√∫n el tipo de reporte"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            summary_data = []
            
            if config['report_type'] == 'income':
                # Total de ingresos
                cursor.execute("""
                    SELECT SUM(monto), COUNT(*)
                    FROM facturas 
                    WHERE fecha_creacion BETWEEN ? AND ? AND estado IN ('pagada', 'pago_parcial')
                """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
                
                result = cursor.fetchone()
                total_income = result[0] if result[0] else 0
                total_invoices = result[1] if result[1] else 0
                avg_invoice = total_income / total_invoices if total_invoices > 0 else 0
                
                summary_data = [
                    ("Total de Ingresos", f"RD${total_income:,.2f}", "#059669"),
                    ("Facturas Pagadas", total_invoices, "#0B5394"),
                    ("Promedio por Factura", f"RD${avg_invoice:,.2f}", "#E67E22")
                ]
                
            elif config['report_type'] == 'appointments':
                cursor.execute("""
                    SELECT COUNT(*), 
                           SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END),
                           SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END)
                    FROM citas 
                    WHERE fecha_hora BETWEEN ? AND ?
                """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
                
                result = cursor.fetchone()
                total_appointments = result[0] if result[0] else 0
                completed = result[1] if result[1] else 0
                cancelled = result[2] if result[2] else 0
                completion_rate = (completed / total_appointments * 100) if total_appointments > 0 else 0
                
                summary_data = [
                    ("Total de Citas", total_appointments, "#0B5394"),
                    ("Citas Completadas", completed, "#059669"),
                    ("Tasa de Completaci√≥n", f"{completion_rate:.1f}%", "#E67E22")
                ]
            
            # Agregar m√°s tipos seg√∫n sea necesario
            
            cursor.close()
            conn.close()
            
            return summary_data
            
        except Exception as e:
            return [("Error", str(e), "#C0392B")]

    def generate_pdf_from_preview(self, config):
        """Generar PDF del reporte desde la vista previa"""
        try:
            # Verificar si reportlab est√° disponible
            try:
                from reportlab.lib.pagesizes import letter, A4
                from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
                from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
                from reportlab.lib.units import inch
                from reportlab.lib import colors
                from reportlab.pdfgen import canvas
            except ImportError:
                messagebox.showerror("Error", "ReportLab no est√° instalado. Instalando...")
                self.install_reportlab_for_reports()
                return
            
            # Crear directorio para reportes
            reports_dir = "reportes_pdf"
            if not os.path.exists(reports_dir):
                os.makedirs(reports_dir)
            
            # Generar nombre de archivo
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            report_type_name = config['title'].replace(' ', '_')
            filename = f"Reporte_{report_type_name}_{timestamp}.pdf"
            filepath = os.path.join(reports_dir, filename)
            
            # Crear el PDF
            doc = SimpleDocTemplate(filepath, pagesize=A4, rightMargin=72, leftMargin=72, 
                                   topMargin=72, bottomMargin=18)
            styles = getSampleStyleSheet()
            story = []
            
            # Estilo personalizado para el t√≠tulo
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=18,
                spaceAfter=30,
                textColor=colors.darkblue,
                alignment=1,  # Centrado
                fontName='Helvetica-Bold'
            )
            
            # Header de la cl√≠nica
            story.append(Paragraph("üè• MEDISYNC - Sistema de Gesti√≥n M√©dica", title_style))
            story.append(Spacer(1, 20))
            
            # T√≠tulo del reporte
            story.append(Paragraph(config['title'], styles['Heading1']))
            story.append(Spacer(1, 12))
            
            # Informaci√≥n del per√≠odo
            period_text = f"Per√≠odo: {config['start_date'].strftime('%d/%m/%Y')} - {config['end_date'].strftime('%d/%m/%Y')}"
            story.append(Paragraph(period_text, styles['Normal']))
            story.append(Paragraph(f"Generado: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}", styles['Normal']))
            story.append(Spacer(1, 30))
            
            # Obtener datos del reporte
            report_data = self.get_report_data_for_pdf(config)
            
            # Resumen ejecutivo
            if config['include_summary']:
                story.append(Paragraph("üìä Resumen Ejecutivo", styles['Heading2']))
                summary_data = self.get_report_summary_data(config)
                
                summary_table_data = [['M√©trica', 'Valor']]
                for label, value, _ in summary_data:
                    summary_table_data.append([label, str(value)])
                
                summary_table = Table(summary_table_data, colWidths=[3*inch, 2*inch])
                summary_table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.lightblue),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, 0), 12),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                    ('BACKGROUND', (0, 1), (-1, -1), colors.lightgrey),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black)
                ]))
                
                story.append(summary_table)
                story.append(Spacer(1, 30))
            
            # Contenido detallado
            if config['include_details'] and report_data:
                story.append(Paragraph("üìã Informaci√≥n Detallada", styles['Heading2']))
                
                # Crear tabla con los datos
                if config['report_type'] == 'income':
                    headers = ['Fecha', 'Ingresos', 'Facturas', 'Promedio']
                elif config['report_type'] == 'appointments':
                    headers = ['Fecha', 'Total Citas', 'Completadas', 'Canceladas']
                elif config['report_type'] == 'pending_invoices':
                    headers = ['N√∫mero Factura', 'Paciente', 'Monto', 'D√≠as Pendiente']
                else:
                    headers = ['Descripci√≥n', 'Valor']
                
                table_data = [headers]
                for row in report_data[:20]:  # Limitar a 20 filas para el PDF
                    table_data.append([str(cell) for cell in row])
                
                data_table = Table(table_data)
                data_table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, 0), 10),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                    ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                    ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                    ('FONTSIZE', (0, 1), (-1, -1), 9),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black)
                ]))
                
                story.append(data_table)
                story.append(Spacer(1, 30))
            
            # Footer
            footer_text = f"""
            Este reporte fue generado autom√°ticamente por MEDISYNC
            Fecha de generaci√≥n: {datetime.now().strftime('%d/%m/%Y a las %H:%M:%S')}
            ¬© 2025 MEDISYNC - Sistema de Gesti√≥n M√©dica Integral
            """
            story.append(Paragraph(footer_text, styles['Normal']))
            
            # Construir el PDF
            doc.build(story)
            
            # Mostrar mensaje de √©xito y abrir PDF
            result = messagebox.askquestion(
                "PDF Generado Exitosamente", 
                f"Reporte guardado como: {filename}\n\n¬øDesea abrir el PDF ahora?",
                icon='question'
            )
            
            if result == 'yes':
                try:
                    os.startfile(filepath)  # Windows
                except:
                    try:
                        os.system(f'open "{filepath}"')  # macOS
                    except:
                        try:
                            os.system(f'xdg-open "{filepath}"')  # Linux
                        except:
                            messagebox.showinfo("PDF Guardado", f"Archivo guardado en:\n{os.path.abspath(filepath)}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error generando PDF: {str(e)}")

    def generate_excel_from_preview(self, config):
        """Generar archivo Excel del reporte"""
        try:
            messagebox.showinfo("Excel", "Funci√≥n de exportaci√≥n a Excel en desarrollo.\nPor ahora use la funci√≥n PDF.")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error generando Excel: {str(e)}")

    def get_report_data_for_pdf(self, config):
        """Obtener datos del reporte para PDF"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            if config['report_type'] == 'income':
                cursor.execute("""
                    SELECT DATE(fecha_creacion) as fecha, SUM(monto) as total_dia, 
                           COUNT(*) as num_facturas
                    FROM facturas 
                    WHERE fecha_creacion BETWEEN ? AND ? AND estado IN ('pagada', 'pago_parcial')
                    GROUP BY DATE(fecha_creacion)
                    ORDER BY fecha
                """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
                
                data = cursor.fetchall()
                formatted_data = []
                for fecha, total, count in data:
                    promedio = total / count if count > 0 else 0
                    formatted_data.append([
                        datetime.fromisoformat(fecha).strftime('%d/%m/%Y'),
                        f"RD${total:,.2f}",
                        str(count),
                        f"RD${promedio:,.2f}"
                    ])
                return formatted_data
                
            elif config['report_type'] == 'appointments':
                cursor.execute("""
                    SELECT DATE(fecha_hora) as fecha, COUNT(*) as total,
                           SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as completadas,
                           SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) as canceladas
                    FROM citas 
                    WHERE fecha_hora BETWEEN ? AND ?
                    GROUP BY DATE(fecha_hora)
                    ORDER BY fecha
                """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
                
                data = cursor.fetchall()
                formatted_data = []
                for fecha, total, completadas, canceladas in data:
                    formatted_data.append([
                        datetime.fromisoformat(fecha).strftime('%d/%m/%Y'),
                        str(total),
                        str(completadas),
                        str(canceladas)
                    ])
                return formatted_data
                
            elif config['report_type'] == 'pending_invoices':
                cursor.execute("""
                    SELECT f.numero_factura, u.nombre || ' ' || u.apellido as paciente, 
                           f.monto, f.fecha_creacion
                    FROM facturas f
                    JOIN usuarios u ON f.paciente_id = u.id
                    WHERE f.estado = 'pendiente' 
                    AND f.fecha_creacion BETWEEN ? AND ?
                    ORDER BY f.fecha_creacion DESC
                """, (config['start_date'].isoformat(), config['end_date'].isoformat()))
                
                data = cursor.fetchall()
                formatted_data = []
                for numero, paciente, monto, fecha_str in data:
                    fecha_creacion = datetime.fromisoformat(fecha_str)
                    dias_pendiente = (datetime.now() - fecha_creacion).days
                    formatted_data.append([
                        numero,
                        paciente,
                        f"RD${monto:,.2f}",
                        f"{dias_pendiente} d√≠as"
                    ])
                return formatted_data
            
            cursor.close()
            conn.close()
            return []
            
        except Exception as e:
            messagebox.showerror("Error", f"Error obteniendo datos: {str(e)}")
            return []

    def install_reportlab_for_reports(self):
        """Instalar ReportLab para reportes"""
        try:
            import subprocess
            import sys
            
            result = messagebox.askquestion("Instalar ReportLab", 
                                          "¬øDesea instalar ReportLab para generar reportes en PDF?")
            if result == 'yes':
                subprocess.check_call([sys.executable, "-m", "pip", "install", "reportlab"])
                messagebox.showinfo("Instalaci√≥n completada", 
                                   "ReportLab instalado correctamente.\nYa puede generar reportes PDF.")
        except Exception as e:
            messagebox.showerror("Error de instalaci√≥n", 
                                f"No se pudo instalar ReportLab autom√°ticamente.\n{str(e)}")

    def generate_report_file(self, config):
        """Generar archivo de reporte seg√∫n el formato especificado"""
        if config['output_format'] == 'PDF':
            self.generate_pdf_from_preview(config)
        elif config['output_format'] == 'Excel':
            self.generate_excel_from_preview(config)
        else:
            messagebox.showinfo("Formato no soportado", "Formato de salida no implementado")

    # Funciones auxiliares para el sistema de reportes
    def apply_report_filters(self):
        """Aplicar filtros a los reportes"""
        period = self.report_period_filter.get()
        report_type = self.report_type_filter.get()
        
        messagebox.showinfo("Filtros", f"Filtros aplicados:\nPer√≠odo: {period}\nTipo: {report_type}")

    def export_all_reports_pdf(self):
        """Exportar todos los reportes a PDF"""
        messagebox.showinfo("Exportar", "Exportando todos los reportes disponibles...")

    def export_to_excel(self):
        """Exportar datos a Excel"""
        messagebox.showinfo("Excel", "Funci√≥n de exportaci√≥n a Excel en desarrollo")

    def email_reports(self):
        """Enviar reportes por email"""
        messagebox.showinfo("Email", "Funci√≥n de env√≠o por email en desarrollo")

    def show_executive_dashboard(self):
        """Mostrar dashboard ejecutivo"""
        messagebox.showinfo("Dashboard", "Dashboard ejecutivo en desarrollo")

    def refresh_all_data(self):
        """Actualizar todos los datos"""
        self.create_stats_display(self.stats_frame if hasattr(self, 'stats_frame') else None)
        messagebox.showinfo("Actualizado", "‚úÖ Datos actualizados correctamente")

    def configure_reports(self):
        """Configurar opciones de reportes"""
        messagebox.showinfo("Configuraci√≥n", "Configuraci√≥n de reportes en desarrollo")

    def manage_report_templates(self):
        """Gestionar plantillas de reportes"""
        messagebox.showinfo("Plantillas", "Gesti√≥n de plantillas en desarrollo")
        
    def create_doctor_menu(self, parent):
        """Crear men√∫ para doctores"""
        # Crear notebook con pesta√±as espec√≠ficas para doctores
        self.notebook = ttk.Notebook(parent)
        self.notebook.pack(fill='both', expand=True)
        
        # Pesta√±a 1: Dashboard Doctor
        dashboard_frame = ttk.Frame(self.notebook)
        self.notebook.add(dashboard_frame, text="üìä Mi Dashboard")
        self.create_doctor_dashboard(dashboard_frame)
        
        # Pesta√±a 2: Mis Citas
        appointments_frame = ttk.Frame(self.notebook)
        self.notebook.add(appointments_frame, text="üìÖ Mis Citas")
        self.create_doctor_appointments(appointments_frame)
        
        # Pesta√±a 3: Mis Pacientes
        patients_frame = ttk.Frame(self.notebook)
        self.notebook.add(patients_frame, text="ü§í Mis Pacientes")
        self.create_doctor_patients(patients_frame)
        
        # Pesta√±a 4: Historiales M√©dicos
        medical_frame = ttk.Frame(self.notebook)
        self.notebook.add(medical_frame, text="üìã Historiales")
        self.create_medical_records(medical_frame)
        
        # Pesta√±a 5: Mi Perfil
        profile_frame = ttk.Frame(self.notebook)
        self.notebook.add(profile_frame, text="üë®‚Äç‚öïÔ∏è Mi Perfil")
        self.create_doctor_profile(profile_frame)
    
    def create_secretaria_menu(self, parent):
        """Crear men√∫ moderno para secretarias con dise√±o similar al admin"""
        # Frame principal para el men√∫
        menu_container = tk.Frame(parent, bg='#F8FAFC')
        menu_container.pack(fill='both', expand=True)
        
        # Header del men√∫ con estilo moderno
        header_frame = tk.Frame(menu_container, bg='#1E3A8A', height=70)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Contenido del header
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=30, pady=10)
        
        # Logo y t√≠tulo
        title_frame = tk.Frame(header_content, bg='#1E3A8A')
        title_frame.pack(side='left', expand=True, fill='both')
        
        tk.Label(title_frame, text="üë©‚Äçüíº", font=('Arial', 20), bg='#1E3A8A', fg='white').pack(side='left', pady=5)
        tk.Label(title_frame, text="MEDISYNC", font=('Arial', 18, 'bold'), bg='#1E3A8A', fg='white').pack(side='left', padx=(10, 0), pady=5)
        tk.Label(title_frame, text="Panel de Secretar√≠a", font=('Arial', 12), bg='#1E3A8A', fg='#CBD5E1').pack(side='left', padx=(15, 0), pady=5)
        
        # Info del usuario
        user_frame = tk.Frame(header_content, bg='#1E3A8A')
        user_frame.pack(side='right')
        
        user_name = f"{self.current_user.nombre} {self.current_user.apellido}"
        tk.Label(user_frame, text=f"üë©‚ÄçÔøΩ {user_name}", font=('Arial', 11, 'bold'), bg='#1E3A8A', fg='#FFFFFF').pack(anchor='e')
        tk.Label(user_frame, text="Secretaria del Sistema", font=('Arial', 9), bg='#1E3A8A', fg='#64748B').pack(anchor='e')
        
        # Barra de navegaci√≥n moderna
        nav_frame = tk.Frame(menu_container, bg='#0B5394', height=60)
        nav_frame.pack(fill='x')
        nav_frame.pack_propagate(False)
        
        # Contenedor de botones de navegaci√≥n
        nav_content = tk.Frame(nav_frame, bg='#0B5394')
        nav_content.pack(expand=True, fill='both', padx=20, pady=5)
        
        # Definir pesta√±as de secretaria con iconos y colores
        tabs_config = [
            ("üìä", "Dashboard", "#0B5394", "Vista general del sistema"),
            ("üìÖ", "Gesti√≥n de Citas", "#16A085", "Administraci√≥n de citas m√©dicas"),
            ("ü§í", "Pacientes", "#059669", "Registro y gesti√≥n de pacientes"),
            ("üí∞", "Facturaci√≥n", "#E67E22", "Gesti√≥n de facturas y pagos"),
            ("üìà", "Reportes", "#8E44AD", "Reportes y estad√≠sticas")
        ]
        
        # Variable para controlar la pesta√±a activa
        self.active_secretaria_tab = tk.StringVar(value="Dashboard")
        
        # Crear botones de navegaci√≥n
        self.secretaria_nav_buttons = {}
        for icon, name, color, description in tabs_config:
            btn_frame = tk.Frame(nav_content, bg='#0B5394')
            btn_frame.pack(side='left', fill='both', expand=True, padx=2)
            
            btn = tk.Button(btn_frame, text=f"{icon} {name}", 
                           font=('Arial', 11, 'bold'), 
                           bg=color if name == "Dashboard" else '#0B5394', 
                           fg='white', relief='flat', bd=0,
                           padx=15, pady=12, cursor='hand2',
                           command=lambda n=name: self.switch_secretaria_tab(n))
            btn.pack(fill='both', expand=True)
            
            self.secretaria_nav_buttons[name] = (btn, color)
        
        # √Årea de contenido principal
        self.secretaria_content_area = tk.Frame(menu_container, bg='#FFFFFF')
        self.secretaria_content_area.pack(fill='both', expand=True)
        
        # Cargar contenido inicial (Dashboard)
        self.switch_secretaria_tab("Dashboard")
    
    def switch_secretaria_tab(self, tab_name):
        """Cambiar entre pesta√±as de secretaria con animaci√≥n visual"""
        # Actualizar variable de pesta√±a activa
        self.active_secretaria_tab.set(tab_name)
        
        # Actualizar colores de botones
        for name, (btn, color) in self.secretaria_nav_buttons.items():
            if name == tab_name:
                btn.configure(bg=color, relief='solid', bd=2)
            else:
                btn.configure(bg='#0B5394', relief='flat', bd=0)
        
        # Limpiar √°rea de contenido
        for widget in self.secretaria_content_area.winfo_children():
            widget.destroy()
        
        # Cargar contenido de la pesta√±a seleccionada
        if tab_name == "Dashboard":
            self.create_secretaria_dashboard(self.secretaria_content_area)
        elif tab_name == "Gesti√≥n de Citas":
            self.create_secretaria_appointments(self.secretaria_content_area)
        elif tab_name == "Pacientes":
            self.create_secretaria_patients(self.secretaria_content_area)
        elif tab_name == "Facturaci√≥n":
            self.create_secretaria_billing(self.secretaria_content_area)
        elif tab_name == "Reportes":
            self.create_secretaria_reports(self.secretaria_content_area)
    
    def create_paciente_menu(self, parent):
        """Crear men√∫ moderno para pacientes con dise√±o similar al admin"""
        # Frame principal para el men√∫
        menu_container = tk.Frame(parent, bg='#F8FAFC')
        menu_container.pack(fill='both', expand=True)
        
        # Header del men√∫ con estilo moderno
        header_frame = tk.Frame(menu_container, bg='#1E3A8A', height=70)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Contenido del header
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=30, pady=10)
        
        # Logo y t√≠tulo
        title_frame = tk.Frame(header_content, bg='#1E3A8A')
        title_frame.pack(side='left', expand=True, fill='both')
        
        tk.Label(title_frame, text="ü§í", font=('Arial', 20), bg='#1E3A8A', fg='white').pack(side='left', pady=5)
        tk.Label(title_frame, text="MEDISYNC", font=('Arial', 18, 'bold'), bg='#1E3A8A', fg='white').pack(side='left', padx=(10, 0), pady=5)
        tk.Label(title_frame, text="Portal del Paciente", font=('Arial', 12), bg='#1E3A8A', fg='#CBD5E1').pack(side='left', padx=(15, 0), pady=5)
        
        # Info del usuario
        user_frame = tk.Frame(header_content, bg='#1E3A8A')
        user_frame.pack(side='right')
        
        user_name = f"{self.current_user.nombre} {self.current_user.apellido}"
        tk.Label(user_frame, text=f"ÔøΩ {user_name}", font=('Arial', 11, 'bold'), bg='#1E3A8A', fg='#FFFFFF').pack(anchor='e')
        tk.Label(user_frame, text="Paciente del Sistema", font=('Arial', 9), bg='#1E3A8A', fg='#64748B').pack(anchor='e')
        
        # Barra de navegaci√≥n moderna
        nav_frame = tk.Frame(menu_container, bg='#0B5394', height=60)
        nav_frame.pack(fill='x')
        nav_frame.pack_propagate(False)
        
        # Contenedor de botones de navegaci√≥n
        nav_content = tk.Frame(nav_frame, bg='#0B5394')
        nav_content.pack(expand=True, fill='both', padx=20, pady=5)
        
        # Definir pesta√±as del paciente con iconos y colores
        tabs_config = [
            ("ÔøΩ", "Dashboard", "#0B5394", "Vista general de mi salud"),
            ("üìÖ", "Mis Citas", "#16A085", "Gesti√≥n de mis citas m√©dicas"),
            ("üìã", "Mi Historial", "#059669", "Mi historial m√©dico personal"),
            ("üí∞", "Mis Facturas", "#E67E22", "Estado de mis facturas y pagos"),
            ("‚öôÔ∏è", "Configuraci√≥n", "#8E44AD", "Configuraci√≥n de mi perfil")
        ]
        
        # Variable para controlar la pesta√±a activa
        self.active_patient_tab = tk.StringVar(value="Dashboard")
        
        # Crear botones de navegaci√≥n
        self.patient_nav_buttons = {}
        for icon, name, color, description in tabs_config:
            btn_frame = tk.Frame(nav_content, bg='#0B5394')
            btn_frame.pack(side='left', fill='both', expand=True, padx=2)
            
            btn = tk.Button(btn_frame, text=f"{icon} {name}", 
                           font=('Arial', 11, 'bold'), 
                           bg=color if name == "Dashboard" else '#0B5394', 
                           fg='white', relief='flat', bd=0,
                           padx=15, pady=12, cursor='hand2',
                           command=lambda n=name: self.switch_patient_tab(n))
            btn.pack(fill='both', expand=True)
            
            self.patient_nav_buttons[name] = (btn, color)
        
        # √Årea de contenido principal
        self.patient_content_area = tk.Frame(menu_container, bg='#FFFFFF')
        self.patient_content_area.pack(fill='both', expand=True)
        
        # Cargar contenido inicial (Dashboard)
        self.switch_patient_tab("Dashboard")
    
    def switch_patient_tab(self, tab_name):
        """Cambiar entre pesta√±as del paciente con animaci√≥n visual"""
        # Actualizar variable de pesta√±a activa
        self.active_patient_tab.set(tab_name)
        
        # Actualizar colores de botones
        for name, (btn, color) in self.patient_nav_buttons.items():
            if name == tab_name:
                btn.configure(bg=color, relief='solid', bd=2)
            else:
                btn.configure(bg='#0B5394', relief='flat', bd=0)
        
        # Limpiar √°rea de contenido
        for widget in self.patient_content_area.winfo_children():
            widget.destroy()
        
        # Cargar contenido de la pesta√±a seleccionada
        if tab_name == "Dashboard":
            self.create_patient_dashboard(self.patient_content_area)
        elif tab_name == "Mis Citas":
            self.create_patient_appointments(self.patient_content_area)
        elif tab_name == "Mi Historial":
            self.create_patient_medical_history(self.patient_content_area)
        elif tab_name == "Mis Facturas":
            self.create_patient_billing(self.patient_content_area)
        elif tab_name == "Configuraci√≥n":
            self.create_patient_settings(self.patient_content_area)
    
    def logout(self):
        """Cerrar sesi√≥n"""
        self.current_user = None
        self.root.destroy()
        self.__init__()
    
    # ==================== FUNCIONES PARA DOCTORES ====================
    
    def create_doctor_menu(self, parent):
        """Crear men√∫ moderno para doctores con dise√±o similar al admin"""
        # Frame principal para el men√∫
        menu_container = tk.Frame(parent, bg='#F8FAFC')
        menu_container.pack(fill='both', expand=True)
        
        # Header del men√∫ con estilo moderno
        header_frame = tk.Frame(menu_container, bg='#1E3A8A', height=70)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Contenido del header
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=30, pady=10)
        
        # Logo y t√≠tulo
        title_frame = tk.Frame(header_content, bg='#1E3A8A')
        title_frame.pack(side='left', expand=True, fill='both')
        
        tk.Label(title_frame, text="üë®‚Äç‚öïÔ∏è", font=('Arial', 20), bg='#1E3A8A', fg='white').pack(side='left', pady=5)
        tk.Label(title_frame, text="MEDISYNC", font=('Arial', 18, 'bold'), bg='#1E3A8A', fg='white').pack(side='left', padx=(10, 0), pady=5)
        tk.Label(title_frame, text="Panel M√©dico", font=('Arial', 12), bg='#1E3A8A', fg='#CBD5E1').pack(side='left', padx=(15, 0), pady=5)
        
        # Info del usuario
        user_frame = tk.Frame(header_content, bg='#1E3A8A')
        user_frame.pack(side='right')
        
        user_name = f"Dr. {self.current_user.nombre} {self.current_user.apellido}"
        tk.Label(user_frame, text=f"üë®‚Äç‚öïÔ∏è {user_name}", font=('Arial', 11, 'bold'), bg='#1E3A8A', fg='#FFFFFF').pack(anchor='e')
        tk.Label(user_frame, text="M√©dico del Sistema", font=('Arial', 9), bg='#1E3A8A', fg='#64748B').pack(anchor='e')
        
        # Barra de navegaci√≥n moderna
        nav_frame = tk.Frame(menu_container, bg='#0B5394', height=60)
        nav_frame.pack(fill='x')
        nav_frame.pack_propagate(False)
        
        # Contenedor de botones de navegaci√≥n
        nav_content = tk.Frame(nav_frame, bg='#0B5394')
        nav_content.pack(expand=True, fill='both', padx=20, pady=5)
        
        # Definir pesta√±as de doctor con iconos y colores
        tabs_config = [
            ("üìä", "Dashboard", "#0B5394", "Vista general de mi pr√°ctica"),
            ("üìÖ", "Mis Citas", "#16A085", "Gesti√≥n de mis citas m√©dicas"),
            ("ü§í", "Mis Pacientes", "#059669", "Pacientes bajo mi cuidado"),
            ("üìã", "Historiales", "#E67E22", "Gesti√≥n de historiales m√©dicos"),
            ("üë§", "Mi Perfil", "#8E44AD", "Configuraci√≥n de mi perfil")
        ]
        
        # Variable para controlar la pesta√±a activa
        self.active_doctor_tab = tk.StringVar(value="Dashboard")
        
        # Crear botones de navegaci√≥n
        self.doctor_nav_buttons = {}
        for icon, name, color, description in tabs_config:
            btn_frame = tk.Frame(nav_content, bg='#0B5394')
            btn_frame.pack(side='left', fill='both', expand=True, padx=2)
            
            btn = tk.Button(btn_frame, text=f"{icon} {name}", 
                           font=('Arial', 11, 'bold'), 
                           bg=color if name == "Dashboard" else '#0B5394', 
                           fg='white', relief='flat', bd=0,
                           padx=15, pady=12, cursor='hand2',
                           command=lambda n=name: self.switch_doctor_tab(n))
            btn.pack(fill='both', expand=True)
            
            self.doctor_nav_buttons[name] = (btn, color)
        
        # √Årea de contenido principal
        self.doctor_content_area = tk.Frame(menu_container, bg='#FFFFFF')
        self.doctor_content_area.pack(fill='both', expand=True)
        
        # Cargar contenido inicial (Dashboard)
        self.switch_doctor_tab("Dashboard")
    
    def switch_doctor_tab(self, tab_name):
        """Cambiar entre pesta√±as de doctor con animaci√≥n visual"""
        # Actualizar variable de pesta√±a activa
        self.active_doctor_tab.set(tab_name)
        
        # Actualizar colores de botones
        for name, (btn, color) in self.doctor_nav_buttons.items():
            if name == tab_name:
                btn.configure(bg=color, relief='solid', bd=2)
            else:
                btn.configure(bg='#0B5394', relief='flat', bd=0)
        
        # Limpiar √°rea de contenido
        for widget in self.doctor_content_area.winfo_children():
            widget.destroy()
        
        # Cargar contenido de la pesta√±a seleccionada
        if tab_name == "Dashboard":
            self.create_doctor_dashboard(self.doctor_content_area)
        elif tab_name == "Mis Citas":
            self.create_doctor_appointments(self.doctor_content_area)
        elif tab_name == "Mis Pacientes":
            self.create_doctor_patients(self.doctor_content_area)
        elif tab_name == "Historiales":
            self.create_medical_records(self.doctor_content_area)
        elif tab_name == "Mi Perfil":
            self.create_doctor_profile(self.doctor_content_area)
    
    def create_doctor_dashboard(self, parent):
        """Dashboard espec√≠fico para doctores"""
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # T√≠tulo personalizado
        title_label = tk.Label(main_frame, text=f"Bienvenido Dr. {self.current_user.nombre}", 
                              font=('Arial', 18, 'bold'), bg='#F8FAFC', fg='#1E3A8A')
        title_label.pack(pady=(0, 20))
        
        # Estad√≠sticas del doctor
        stats_frame = tk.Frame(main_frame, bg='#F8FAFC')
        stats_frame.pack(fill='x', pady=20)
        
        try:
            doctor_stats = self.get_doctor_stats()
            
            self.create_stats_card(stats_frame, "üìÖ Citas Hoy", 
                                 str(doctor_stats.get('appointments_today', 0)), "#0B5394", 0, 0)
            
            self.create_stats_card(stats_frame, "ü§í Total Pacientes", 
                                 str(doctor_stats.get('total_patients', 0)), "#059669", 0, 1)
            
            self.create_stats_card(stats_frame, "üí∞ Ingresos del Mes", 
                                 f"RD$ {doctor_stats.get('monthly_income', 0):,.2f}", "#E67E22", 0, 2)
            
            self.create_stats_card(stats_frame, "‚≠ê Consultas Este Mes", 
                                 str(doctor_stats.get('consultations_month', 0)), "#16A085", 0, 3)
                                 
        except Exception as e:
            tk.Label(stats_frame, text=f"Error cargando estad√≠sticas: {str(e)}", 
                    fg='red', bg='#F8FAFC').pack()
        
        # Pr√≥ximas citas
        appointments_frame = tk.LabelFrame(main_frame, text="üïê Pr√≥ximas Citas", 
                                         font=('Arial', 14, 'bold'), padx=20, pady=15)
        appointments_frame.pack(fill='both', expand=True, pady=20)
        
        # Lista de pr√≥ximas citas
        appointments_list = tk.Frame(appointments_frame, bg='white')
        appointments_list.pack(fill='both', expand=True)
        
        try:
            upcoming_appointments = self.get_doctor_upcoming_appointments()
            
            if upcoming_appointments:
                for i, apt in enumerate(upcoming_appointments[:5]):  # Mostrar solo 5
                    apt_frame = tk.Frame(appointments_list, bg='#FFFFFF', relief='solid', bd=1)
                    apt_frame.pack(fill='x', pady=5, padx=10)
                    
                    # Informaci√≥n de la cita
                    info_text = f"üïí {apt.get('fecha_hora_formatted', 'N/A')} - {apt.get('paciente_nombre', 'N/A')}"
                    tk.Label(apt_frame, text=info_text, font=('Arial', 11, 'bold'), 
                            bg='#FFFFFF', fg='#1E3A8A').pack(side='left', padx=10, pady=8)
                    
                    # Motivo
                    motivo_text = f"Motivo: {apt.get('motivo', 'Consulta general')}"
                    tk.Label(apt_frame, text=motivo_text, font=('Arial', 10), 
                            bg='#FFFFFF', fg='#64748B').pack(side='left', padx=(20, 10))
            else:
                tk.Label(appointments_list, text="No hay citas programadas", 
                        font=('Arial', 12), fg='#64748B').pack(pady=20)
                
        except Exception as e:
            tk.Label(appointments_list, text=f"Error cargando citas: {str(e)}", 
                    fg='red').pack(pady=20)
    
    def create_doctor_appointments(self, parent):
        """Gesti√≥n de citas para doctores"""
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Header con filtros
        header_frame = tk.Frame(main_frame, bg='#F8FAFC')
        header_frame.pack(fill='x', pady=(0, 20))
        
        tk.Label(header_frame, text="Mis Citas M√©dicas", 
                font=('Arial', 16, 'bold'), bg='#F8FAFC').pack(side='left')
        
        # Filtros
        filter_frame = tk.Frame(header_frame, bg='#F8FAFC')
        filter_frame.pack(side='right')
        
        tk.Label(filter_frame, text="Filtrar por:", font=('Arial', 10), bg='#F8FAFC').pack(side='left')
        
        self.appointment_filter = ttk.Combobox(filter_frame, values=['Todas', 'Hoy', 'Esta Semana', 'Este Mes'], 
                                             state='readonly', width=12)
        self.appointment_filter.set('Hoy')
        self.appointment_filter.pack(side='left', padx=5)
        self.appointment_filter.bind('<<ComboboxSelected>>', self.filter_doctor_appointments)
        
        # Tabla de citas
        columns = ('Fecha/Hora', 'Paciente', 'Motivo', 'Estado', 'Duraci√≥n', 'Acciones')
        self.doctor_appointments_tree = ttk.Treeview(main_frame, columns=columns, show='headings', height=15)
        
        # Configurar headers
        for col in columns:
            self.doctor_appointments_tree.heading(col, text=col)
            if col == 'Fecha/Hora':
                self.doctor_appointments_tree.column(col, width=150)
            elif col == 'Paciente':
                self.doctor_appointments_tree.column(col, width=200)
            elif col == 'Acciones':
                self.doctor_appointments_tree.column(col, width=120)
            else:
                self.doctor_appointments_tree.column(col, width=100)
        
        # Scrollbar
        scrollbar_y = ttk.Scrollbar(main_frame, orient="vertical", command=self.doctor_appointments_tree.yview)
        self.doctor_appointments_tree.configure(yscrollcommand=scrollbar_y.set)
        
        # Pack
        self.doctor_appointments_tree.pack(side='left', fill='both', expand=True)
        scrollbar_y.pack(side='right', fill='y')
        
        # Botones de acci√≥n
        actions_frame = tk.Frame(main_frame, bg='#F8FAFC')
        actions_frame.pack(fill='x', pady=(10, 0))
        
        tk.Button(actions_frame, text="üìã Ver Detalles", bg='#0B5394', fg='white',
                 command=self.view_appointment_details).pack(side='left', padx=5)
        tk.Button(actions_frame, text="‚úÖ Marcar Completada", bg='#0B5394', fg='white',
                 command=self.complete_appointment).pack(side='left', padx=5)
        tk.Button(actions_frame, text="‚ùå Cancelar Cita", bg='#0B5394', fg='white',
                 command=self.cancel_appointment).pack(side='left', padx=5)
        tk.Button(actions_frame, text="üìù Agregar Notas", bg='#0B5394', fg='white',
                 command=self.add_appointment_notes).pack(side='left', padx=5)
        
        # Cargar datos
        self.load_doctor_appointments()
    
    def create_doctor_patients(self, parent):
        """Lista de pacientes del doctor"""
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Header
        header_frame = tk.Frame(main_frame, bg='#F8FAFC')
        header_frame.pack(fill='x', pady=(0, 20))
        
        tk.Label(header_frame, text="Mis Pacientes", 
                font=('Arial', 16, 'bold'), bg='#F8FAFC').pack(side='left')
        
        # B√∫squeda
        search_frame = tk.Frame(header_frame, bg='#F8FAFC')
        search_frame.pack(side='right')
        
        tk.Label(search_frame, text="Buscar:", font=('Arial', 10), bg='#F8FAFC').pack(side='left')
        self.patient_search_entry = tk.Entry(search_frame, font=('Arial', 10), width=20)
        self.patient_search_entry.pack(side='left', padx=5)
        self.patient_search_entry.bind('<KeyRelease>', self.search_patients)
        
        # Tabla de pacientes
        columns = ('Nombre', 'Apellido', 'Email', 'Tel√©fono', '√öltima Consulta', 'Estado')
        self.doctor_patients_tree = ttk.Treeview(main_frame, columns=columns, show='headings', height=15)
        
        # Configurar headers
        for col in columns:
            self.doctor_patients_tree.heading(col, text=col)
            self.doctor_patients_tree.column(col, width=120)
        
        # Scrollbar
        scrollbar_y = ttk.Scrollbar(main_frame, orient="vertical", command=self.doctor_patients_tree.yview)
        self.doctor_patients_tree.configure(yscrollcommand=scrollbar_y.set)
        
        # Pack
        self.doctor_patients_tree.pack(side='left', fill='both', expand=True)
        scrollbar_y.pack(side='right', fill='y')
        
        # Botones de acci√≥n
        actions_frame = tk.Frame(main_frame, bg='#F8FAFC')
        actions_frame.pack(fill='x', pady=(10, 0))
        
        tk.Button(actions_frame, text="üë§ Ver Perfil", bg='#0B5394', fg='white',
                 command=self.view_patient_profile).pack(side='left', padx=5)
        tk.Button(actions_frame, text="üìã Ver Historial", bg='#0B5394', fg='white',
                 command=self.view_medical_history).pack(side='left', padx=5)
        tk.Button(actions_frame, text="üìÖ Nueva Cita", bg='#0B5394', fg='white',
                 command=self.schedule_appointment).pack(side='left', padx=5)
        
        # Cargar datos
        self.load_doctor_patients()
    
    def create_medical_records(self, parent):
        """Gesti√≥n de historiales m√©dicos"""
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Header
        header_frame = tk.Frame(main_frame, bg='#F8FAFC')
        header_frame.pack(fill='x', pady=(0, 20))
        
        tk.Label(header_frame, text="Historiales M√©dicos", 
                font=('Arial', 16, 'bold'), bg='#F8FAFC').pack(side='left')
        
        tk.Button(header_frame, text="‚ûï Nuevo Historial", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), command=self.create_medical_record).pack(side='right')
        
        # Panel dividido
        paned_window = ttk.PanedWindow(main_frame, orient='horizontal')
        paned_window.pack(fill='both', expand=True)
        
        # Panel izquierdo - Lista de pacientes
        left_frame = ttk.Frame(paned_window)
        paned_window.add(left_frame, weight=1)
        
        tk.Label(left_frame, text="Seleccionar Paciente", font=('Arial', 12, 'bold')).pack(pady=5)
        
        # Lista de pacientes
        self.medical_patients_listbox = tk.Listbox(left_frame, font=('Arial', 10))
        self.medical_patients_listbox.pack(fill='both', expand=True, padx=5, pady=5)
        self.medical_patients_listbox.bind('<<ListboxSelect>>', self.load_patient_medical_records)
        
        # Panel derecho - Historiales
        right_frame = ttk.Frame(paned_window)
        paned_window.add(right_frame, weight=2)
        
        tk.Label(right_frame, text="Historiales M√©dicos", font=('Arial', 12, 'bold')).pack(pady=5)
        
        # Frame contenedor para tabla con scrollbars
        table_container = tk.Frame(right_frame)
        table_container.pack(fill='both', expand=True, padx=5)
        
        # Tabla de historiales
        columns = ('Fecha', 'Diagn√≥stico', 'Tratamiento', 'Notas')
        self.medical_records_tree = ttk.Treeview(table_container, columns=columns, show='headings', height=12)
        
        for col in columns:
            self.medical_records_tree.heading(col, text=col)
            if col == 'Fecha':
                self.medical_records_tree.column(col, width=100)
            else:
                self.medical_records_tree.column(col, width=150)
        
        # Scrollbars para historiales
        records_scrollbar_y = ttk.Scrollbar(table_container, orient="vertical", command=self.medical_records_tree.yview)
        records_scrollbar_x = ttk.Scrollbar(table_container, orient="horizontal", command=self.medical_records_tree.xview)
        self.medical_records_tree.configure(yscrollcommand=records_scrollbar_y.set, xscrollcommand=records_scrollbar_x.set)
        
        # Layout con grid para mejor control
        self.medical_records_tree.grid(row=0, column=0, sticky='nsew')
        records_scrollbar_y.grid(row=0, column=1, sticky='ns')
        records_scrollbar_x.grid(row=1, column=0, sticky='ew')
        
        # Configurar expansi√≥n
        table_container.grid_rowconfigure(0, weight=1)
        table_container.grid_columnconfigure(0, weight=1)
        
        # Botones para historiales
        records_actions_frame = tk.Frame(right_frame)
        records_actions_frame.pack(fill='x', pady=5)
        
        tk.Button(records_actions_frame, text="üëÅÔ∏è Ver Detalle", bg='#0B5394', fg='white',
                 command=self.view_medical_record_detail).pack(side='left', padx=5)
        tk.Button(records_actions_frame, text="‚úèÔ∏è Editar", bg='#0B5394', fg='white',
                 command=self.edit_medical_record).pack(side='left', padx=5)
        tk.Button(records_actions_frame, text="üñ®Ô∏è Imprimir", bg='#0B5394', fg='white',
                 command=self.print_medical_record).pack(side='left', padx=5)
        
        # Cargar pacientes
        self.load_medical_patients()
    
    def create_doctor_profile(self, parent):
        """Perfil del doctor"""
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # T√≠tulo
        tk.Label(main_frame, text="Mi Perfil Profesional", 
                font=('Arial', 18, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(pady=(0, 20))
        
        # Frame principal del perfil
        profile_main_frame = tk.Frame(main_frame, bg='white', relief='solid', bd=1)
        profile_main_frame.pack(fill='both', expand=True, padx=20, pady=10)
        
        # Panel izquierdo - Informaci√≥n personal
        left_panel = tk.Frame(profile_main_frame, bg='white')
        left_panel.pack(side='left', fill='both', expand=True, padx=20, pady=20)
        
        # Avatar y datos b√°sicos
        avatar_frame = tk.Frame(left_panel, bg='#0B5394', width=100, height=100)
        avatar_frame.pack(pady=(0, 20))
        avatar_frame.pack_propagate(False)
        tk.Label(avatar_frame, text="üë®‚Äç‚öïÔ∏è", font=('Arial', 50), bg='#0B5394', fg='white').pack(expand=True)
        
        # Informaci√≥n personal
        info_fields = [
            ("Nombre:", f"{self.current_user.nombre} {self.current_user.apellido}"),
            ("Email:", self.current_user.email),
            ("Tel√©fono:", self.current_user.telefono),
            ("Especialidad:", getattr(self.current_user, 'especialidad', 'Medicina General')),
            ("C√©dula Profesional:", getattr(self.current_user, 'cedula_profesional', 'No especificada'))
        ]
        
        for label, value in info_fields:
            field_frame = tk.Frame(left_panel, bg='white')
            field_frame.pack(fill='x', pady=5)
            
            tk.Label(field_frame, text=label, font=('Arial', 11, 'bold'), 
                    bg='white', fg='#1E3A8A').pack(side='left')
            tk.Label(field_frame, text=value, font=('Arial', 11), 
                    bg='white', fg='#64748B').pack(side='left', padx=(10, 0))
        
        # Panel derecho - Configuraciones
        right_panel = tk.Frame(profile_main_frame, bg='#F8FAFC')
        right_panel.pack(side='right', fill='both', expand=True, padx=20, pady=20)
        
        # Configuraciones
        config_frame = tk.LabelFrame(right_panel, text="Configuraciones", 
                                   font=('Arial', 12, 'bold'), padx=15, pady=10)
        config_frame.pack(fill='x', pady=(0, 20))
        
        tk.Button(config_frame, text="üîß Editar Perfil", bg='#0B5394', fg='white',
                 font=('Arial', 10), command=self.edit_doctor_profile).pack(fill='x', pady=5)
        tk.Button(config_frame, text="üîë Cambiar Contrase√±a", bg='#0B5394', fg='white',
                 font=('Arial', 10), command=self.change_password).pack(fill='x', pady=5)
        tk.Button(config_frame, text="‚è∞ Configurar Horarios", bg='#0B5394', fg='white',
                 font=('Arial', 10), command=self.configure_schedule).pack(fill='x', pady=5)
        
        # Estad√≠sticas profesionales
        stats_frame = tk.LabelFrame(right_panel, text="Estad√≠sticas", 
                                  font=('Arial', 12, 'bold'), padx=15, pady=10)
        stats_frame.pack(fill='both', expand=True)
        
        try:
            doctor_stats = self.get_doctor_stats()
            
            stats_text = f"""
üìÖ Total de Consultas: {doctor_stats.get('total_consultations', 0)}
ü§í Pacientes Atendidos: {doctor_stats.get('total_patients', 0)}
üí∞ Ingresos Totales: RD$ {doctor_stats.get('total_income', 0):,.2f}
‚≠ê Promedio Mensual: {doctor_stats.get('avg_monthly', 0)} consultas
üìä Este Mes: {doctor_stats.get('consultations_month', 0)} consultas
            """
            
            tk.Label(stats_frame, text=stats_text, font=('Arial', 10), 
                    justify='left', bg='#F8FAFC').pack(pady=10)
                    
        except Exception as e:
            tk.Label(stats_frame, text=f"Error cargando estad√≠sticas: {str(e)}", 
                    fg='red', bg='#F8FAFC').pack(pady=10)
    
    # ==================== FUNCIONES PARA SECRETARIAS ====================
    
    def create_secretaria_dashboard(self, parent):
        """Dashboard espec√≠fico para secretarias"""
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # T√≠tulo personalizado
        title_label = tk.Label(main_frame, text=f"Panel de Control - {self.current_user.nombre}", 
                              font=('Arial', 18, 'bold'), bg='#F8FAFC', fg='#1E3A8A')
        title_label.pack(pady=(0, 20))
        
        # Estad√≠sticas del d√≠a
        stats_frame = tk.Frame(main_frame, bg='#F8FAFC')
        stats_frame.pack(fill='x', pady=20)
        
        try:
            daily_stats = self.get_secretaria_stats()
            
            self.create_stats_card(stats_frame, "üìÖ Citas Hoy", 
                                 str(daily_stats.get('appointments_today', 0)), "#0B5394", 0, 0)
            
            self.create_stats_card(stats_frame, "‚è≥ Citas Pendientes", 
                                 str(daily_stats.get('pending_appointments', 0)), "#C0392B", 0, 1)
            
            self.create_stats_card(stats_frame, "üí∞ Facturas Pendientes", 
                                 str(daily_stats.get('pending_invoices', 0)), "#E67E22", 0, 2)
            
            self.create_stats_card(stats_frame, "üë• Nuevos Pacientes", 
                                 str(daily_stats.get('new_patients_today', 0)), "#059669", 0, 3)
                                 
        except Exception as e:
            tk.Label(stats_frame, text=f"Error cargando estad√≠sticas: {str(e)}", 
                    fg='red', bg='#F8FAFC').pack()
        
        # Panel de acciones r√°pidas
        quick_actions_frame = tk.LabelFrame(main_frame, text="üöÄ Acciones R√°pidas", 
                                          font=('Arial', 14, 'bold'), padx=20, pady=15)
        quick_actions_frame.pack(fill='x', pady=20)
        
        # Botones de acciones r√°pidas
        actions_grid = tk.Frame(quick_actions_frame)
        actions_grid.pack()
        
        quick_buttons = [
            ("üìÖ Nueva Cita", self.new_appointment_quick, "#0B5394"),
            ("üë§ Nuevo Paciente", self.new_patient_quick, "#16A085"),
            ("üí∞ Procesar Pago", self.process_payment_quick, "#E67E22"),
            ("üìã Generar Factura", self.generate_invoice_quick, "#16A085"),
            ("üìû Lista de Espera", self.manage_waiting_list, "#E67E22"),
            ("üìä Reporte Diario", self.daily_report, "#1abc9c")
        ]
        
        for i, (text, command, color) in enumerate(quick_buttons):
            btn = tk.Button(actions_grid, text=text, command=command, 
                           bg=color, fg='white', font=('Arial', 10, 'bold'),
                           width=18, height=2)
            btn.grid(row=i//3, column=i%3, padx=10, pady=10)
        
        # Agenda del d√≠a
        agenda_frame = tk.LabelFrame(main_frame, text="üìã Agenda de Hoy", 
                                   font=('Arial', 14, 'bold'), padx=20, pady=15)
        agenda_frame.pack(fill='both', expand=True, pady=20)
        
        # Lista de citas del d√≠a
        agenda_list = tk.Frame(agenda_frame, bg='white')
        agenda_list.pack(fill='both', expand=True)
        
        try:
            today_appointments = self.get_today_appointments()
            
            if today_appointments:
                for i, apt in enumerate(today_appointments):
                    apt_frame = tk.Frame(agenda_list, bg='#FFFFFF' if i % 2 == 0 else '#ffffff', 
                                       relief='solid', bd=1)
                    apt_frame.pack(fill='x', pady=2, padx=5)
                    
                    # Hora
                    time_label = tk.Label(apt_frame, text=f"üïí {apt.get('hora', 'N/A')}", 
                                        font=('Arial', 11, 'bold'), 
                                        bg=apt_frame['bg'], fg='#1E3A8A')
                    time_label.pack(side='left', padx=10, pady=5)
                    
                    # Paciente y Doctor
                    info_text = f"{apt.get('paciente_nombre', 'N/A')} ‚Üí Dr. {apt.get('doctor_nombre', 'N/A')}"
                    info_label = tk.Label(apt_frame, text=info_text, font=('Arial', 10), 
                                        bg=apt_frame['bg'], fg='#64748B')
                    info_label.pack(side='left', padx=(20, 10), pady=5)
                    
                    # Estado
                    estado = apt.get('estado', 'programada')
                    estado_color = {'programada': '#0B5394', 'completada': '#16A085', 'cancelada': '#C0392B'}
                    estado_label = tk.Label(apt_frame, text=estado.upper(), 
                                          font=('Arial', 9, 'bold'), 
                                          bg=estado_color.get(estado, '#64748B'), fg='white')
                    estado_label.pack(side='right', padx=10, pady=5)
            else:
                tk.Label(agenda_list, text="No hay citas programadas para hoy", 
                        font=('Arial', 12), fg='#64748B').pack(pady=20)
                
        except Exception as e:
            tk.Label(agenda_list, text=f"Error cargando agenda: {str(e)}", 
                    fg='red').pack(pady=20)
    
    def create_secretaria_appointments(self, parent):
        """Gesti√≥n completa de citas para secretarias"""
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Header con botones y filtros
        header_frame = tk.Frame(main_frame, bg='#F8FAFC')
        header_frame.pack(fill='x', pady=(0, 20))
        
        tk.Label(header_frame, text="Gesti√≥n de Citas M√©dicas", 
                font=('Arial', 16, 'bold'), bg='#F8FAFC').pack(side='left')
        
        # Botones de acci√≥n
        buttons_frame = tk.Frame(header_frame, bg='#F8FAFC')
        buttons_frame.pack(side='right')
        
        tk.Button(buttons_frame, text="‚ûï Nueva Cita", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), command=self.create_new_appointment).pack(side='left', padx=5)
        tk.Button(buttons_frame, text="üìÖ Calendario", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), command=self.show_appointment_calendar).pack(side='left', padx=5)
        
        # Panel de filtros
        filters_frame = tk.LabelFrame(main_frame, text="Filtros", font=('Arial', 11, 'bold'), 
                                    padx=10, pady=10)
        filters_frame.pack(fill='x', pady=(0, 20))
        
        filters_row = tk.Frame(filters_frame)
        filters_row.pack()
        
        # Filtro por fecha
        tk.Label(filters_row, text="Fecha:", font=('Arial', 10)).grid(row=0, column=0, padx=5, sticky='w')
        self.appointment_date_filter = ttk.Combobox(filters_row, values=['Hoy', 'Ma√±ana', 'Esta Semana', 'Este Mes', 'Todas'], 
                                                  state='readonly', width=12)
        self.appointment_date_filter.set('Hoy')
        self.appointment_date_filter.grid(row=0, column=1, padx=5)
        
        # Filtro por doctor
        tk.Label(filters_row, text="Doctor:", font=('Arial', 10)).grid(row=0, column=2, padx=5, sticky='w')
        self.appointment_doctor_filter = ttk.Combobox(filters_row, state='readonly', width=15)
        self.appointment_doctor_filter.grid(row=0, column=3, padx=5)
        
        # Filtro por estado
        tk.Label(filters_row, text="Estado:", font=('Arial', 10)).grid(row=0, column=4, padx=5, sticky='w')
        self.appointment_status_filter = ttk.Combobox(filters_row, 
                                                    values=['Todas', 'Programada', 'Completada', 'Cancelada'], 
                                                    state='readonly', width=12)
        self.appointment_status_filter.set('Todas')
        self.appointment_status_filter.grid(row=0, column=5, padx=5)
        
        # Bot√≥n aplicar filtros
        tk.Button(filters_row, text="üîç Filtrar", bg='#0B5394', fg='white',
                 command=self.apply_appointment_filters).grid(row=0, column=6, padx=10)
        
        # Tabla de citas
        columns = ('ID', 'Fecha/Hora', 'Paciente', 'Doctor', 'Motivo', 'Estado', 'Tel√©fono')
        self.secretaria_appointments_tree = ttk.Treeview(main_frame, columns=columns, show='headings', height=12)
        
        # Configurar headers
        column_widths = {'ID': 50, 'Fecha/Hora': 130, 'Paciente': 150, 'Doctor': 120, 
                        'Motivo': 200, 'Estado': 100, 'Tel√©fono': 100}
        
        for col in columns:
            self.secretaria_appointments_tree.heading(col, text=col)
            self.secretaria_appointments_tree.column(col, width=column_widths.get(col, 100))
        
        # Scrollbar
        scrollbar_y = ttk.Scrollbar(main_frame, orient="vertical", command=self.secretaria_appointments_tree.yview)
        self.secretaria_appointments_tree.configure(yscrollcommand=scrollbar_y.set)
        
        # Pack
        self.secretaria_appointments_tree.pack(side='left', fill='both', expand=True)
        scrollbar_y.pack(side='right', fill='y')
        
        # Botones de acci√≥n para citas
        actions_frame = tk.Frame(main_frame, bg='#F8FAFC')
        actions_frame.pack(fill='x', pady=(10, 0))
        
        action_buttons = [
            ("‚úèÔ∏è Editar", self.edit_appointment, "#E67E22"),
            ("‚úÖ Confirmar", self.confirm_appointment, "#16A085"),
            ("‚ùå Cancelar", self.cancel_appointment, "#C0392B"),
            ("üìû Llamar Paciente", self.call_patient, "#0B5394"),
            ("üí∞ Generar Factura", self.generate_appointment_invoice, "#16A085"),
            ("üìã Ver Detalles", self.view_appointment_details, "#64748B")
        ]
        
        for text, command, color in action_buttons:
            btn = tk.Button(actions_frame, text=text, command=command, 
                           bg=color, fg='white', font=('Arial', 9, 'bold'))
            btn.pack(side='left', padx=5, pady=5)
        
        # Cargar datos y filtros
        self.load_appointment_doctors()
        self.load_secretaria_appointments()
    
    def create_secretaria_patients(self, parent):
        """Gesti√≥n de pacientes para secretarias"""
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Header
        header_frame = tk.Frame(main_frame, bg='#F8FAFC')
        header_frame.pack(fill='x', pady=(0, 20))
        
        tk.Label(header_frame, text="Gesti√≥n de Pacientes", 
                font=('Arial', 16, 'bold'), bg='#F8FAFC').pack(side='left')
        
        # Botones de acci√≥n
        buttons_frame = tk.Frame(header_frame, bg='#F8FAFC')
        buttons_frame.pack(side='right')
        
        tk.Button(buttons_frame, text="‚ûï Nuevo Paciente", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), command=self.register_new_patient).pack(side='left', padx=5)
        tk.Button(buttons_frame, text="üì§ Importar", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), command=self.import_patients).pack(side='left', padx=5)
        tk.Button(buttons_frame, text="üì• Exportar", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), command=self.export_patients).pack(side='left', padx=5)
        
        # Panel de b√∫squeda
        search_frame = tk.LabelFrame(main_frame, text="B√∫squeda de Pacientes", 
                                   font=('Arial', 11, 'bold'), padx=10, pady=10)
        search_frame.pack(fill='x', pady=(0, 20))
        
        search_row = tk.Frame(search_frame)
        search_row.pack()
        
        tk.Label(search_row, text="Buscar por:", font=('Arial', 10)).grid(row=0, column=0, padx=5)
        
        search_options = ['Nombre', 'Apellido', 'Email', 'Tel√©fono', 'Expediente']
        self.patient_search_type = ttk.Combobox(search_row, values=search_options, state='readonly', width=12)
        self.patient_search_type.set('Nombre')
        self.patient_search_type.grid(row=0, column=1, padx=5)
        
        self.patient_search_entry = tk.Entry(search_row, font=('Arial', 10), width=25)
        self.patient_search_entry.grid(row=0, column=2, padx=5)
        self.patient_search_entry.bind('<KeyRelease>', self.search_patients_secretaria)
        
        tk.Button(search_row, text="üîç Buscar", bg='#0B5394', fg='white',
                 command=self.search_patients_secretaria).grid(row=0, column=3, padx=10)
        
        tk.Button(search_row, text="üîÑ Limpiar", bg='#0B5394', fg='white',
                 command=self.clear_patient_search).grid(row=0, column=4, padx=5)
        
        # Tabla de pacientes
        columns = ('ID', 'Expediente', 'Nombre', 'Apellido', 'Email', 'Tel√©fono', 'Seguro', 'Estado')
        self.secretaria_patients_tree = ttk.Treeview(main_frame, columns=columns, show='headings', height=12)
        
        # Configurar headers
        column_widths = {'ID': 50, 'Expediente': 100, 'Nombre': 120, 'Apellido': 120, 
                        'Email': 180, 'Tel√©fono': 100, 'Seguro': 120, 'Estado': 80}
        
        for col in columns:
            self.secretaria_patients_tree.heading(col, text=col)
            self.secretaria_patients_tree.column(col, width=column_widths.get(col, 100))
        
        # Scrollbar
        scrollbar_y = ttk.Scrollbar(main_frame, orient="vertical", command=self.secretaria_patients_tree.yview)
        self.secretaria_patients_tree.configure(yscrollcommand=scrollbar_y.set)
        
        # Pack
        self.secretaria_patients_tree.pack(side='left', fill='both', expand=True)
        scrollbar_y.pack(side='right', fill='y')
        
        # Botones de acci√≥n para pacientes
        actions_frame = tk.Frame(main_frame, bg='#F8FAFC')
        actions_frame.pack(fill='x', pady=(10, 0))
        
        patient_actions = [
            ("üëÅÔ∏è Ver Perfil", self.view_patient_profile_secretaria, "#0B5394"),
            ("‚úèÔ∏è Editar Datos", self.edit_patient_data, "#E67E22"),
            ("üìÖ Nueva Cita", self.schedule_patient_appointment, "#16A085"),
            ("üìã Ver Historial", self.view_patient_history, "#16A085"),
            ("üí∞ Ver Facturas", self.view_patient_invoices, "#E67E22"),
            ("üìû Contactar", self.contact_patient, "#1abc9c")
        ]
        
        for text, command, color in patient_actions:
            btn = tk.Button(actions_frame, text=text, command=command, 
                           bg=color, fg='white', font=('Arial', 9, 'bold'))
            btn.pack(side='left', padx=5, pady=5)
        
        # Cargar datos
        self.load_secretaria_patients()
    
    def create_secretaria_billing(self, parent):
        """Sistema de facturaci√≥n avanzado para secretarias"""
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=15, pady=15)
        
        # Header moderno
        header_frame = tk.Frame(main_frame, bg='#1E3A8A', height=70)
        header_frame.pack(fill='x', pady=(0, 15))
        header_frame.pack_propagate(False)
        
        # Contenido del header
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=20, pady=10)
        
        # T√≠tulo
        title_frame = tk.Frame(header_content, bg='#1E3A8A')
        title_frame.pack(side='left', expand=True, fill='both')
        
        tk.Label(title_frame, text="üí∞", font=('Arial', 18), bg='#1E3A8A', fg='white').pack(side='left', pady=8)
        tk.Label(title_frame, text="FACTURACI√ìN SECRETAR√çA", 
                font=('Arial', 14, 'bold'), bg='#1E3A8A', fg='white').pack(side='left', padx=(10, 0), pady=8)
        tk.Label(title_frame, text="Gesti√≥n completa de facturas y pagos", 
                font=('Arial', 10), bg='#1E3A8A', fg='#CBD5E1').pack(side='left', padx=(15, 0), pady=8)
        
        # Botones principales en header
        buttons_frame = tk.Frame(header_content, bg='#1E3A8A')
        buttons_frame.pack(side='right', pady=8)
        
        # Bot√≥n Sistema Completo (m√°s prominente)
        complete_btn = tk.Button(
            buttons_frame,
            text="üí∞ FACTURACI√ìN AVANZADA",
            command=lambda: self.switch_tab("Facturaci√≥n Avanzada"),
            bg='#0B5394',
            fg='white',
            font=('Arial', 11, 'bold'),
            padx=20,
            pady=8,
            relief='raised',
            bd=3
        )
        complete_btn.pack(side='left', padx=10)
        
        # Botones secundarios
        tk.Button(buttons_frame, text="ÔøΩüìã Nueva Factura", bg='#0B5394', fg='white',
                 font=('Arial', 9, 'bold'), padx=12, pady=6,
                 command=self.create_new_invoice_secretaria).pack(side='left', padx=3)
        tk.Button(buttons_frame, text="üí≥ Procesar Pago", bg='#0B5394', fg='white',
                 font=('Arial', 9, 'bold'), padx=12, pady=6,
                 command=self.process_payment_secretaria).pack(side='left', padx=3)
        
        # Contenido principal dividido en 2 columnas
        content_frame = tk.Frame(main_frame, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True)
        
        # Columna izquierda: Resumen y estad√≠sticas
        left_column = tk.Frame(content_frame, bg='#F8FAFC', width=350)
        left_column.pack(side='left', fill='y', padx=(0, 15))
        left_column.pack_propagate(False)
        
        # Columna derecha: Lista de facturas
        right_column = tk.Frame(content_frame, bg='#F8FAFC')
        right_column.pack(side='right', fill='both', expand=True)
        
        # Panel de resumen financiero
        summary_frame = tk.LabelFrame(
            left_column, 
            text="üìä RESUMEN FINANCIERO HOY", 
            font=('Arial', 11, 'bold'),
            bg='#e8f5e8',
            fg='#2e7d32',
            padx=15, 
            pady=15
        )
        summary_frame.pack(fill='x', pady=(0, 15))
        
        try:
            billing_summary = self.get_billing_summary_secretaria()
            
            # Indicadores financieros
            indicators = [
                ("üí∞ Ingresos Hoy", f"RD${billing_summary.get('today_income', 0):,.2f}", "#16A085"),
                ("üìã Pendientes", str(billing_summary.get('pending_count', 0)), "#C0392B"),
                ("‚úÖ Pagadas Hoy", str(billing_summary.get('paid_today', 0)), "#0B5394"),
                ("üìä Meta Mensual", f"RD${billing_summary.get('month_income', 0):,.2f}", "#16A085")
            ]
            
            for title, value, color in indicators:
                indicator_frame = tk.Frame(summary_frame, bg='#e8f5e8')
                indicator_frame.pack(fill='x', pady=5)
                
                tk.Label(indicator_frame, text=title, font=('Arial', 10, 'bold'),
                        bg='#e8f5e8', fg='#2e7d32').pack(side='left')
                tk.Label(indicator_frame, text=value, font=('Arial', 11, 'bold'),
                        bg='#e8f5e8', fg=color).pack(side='right')
                
        except Exception as e:
            tk.Label(summary_frame, text=f"Error cargando resumen: {str(e)}", 
                    font=('Arial', 9), bg='#e8f5e8', fg='#C0392B').pack()
        
        # Panel de acciones r√°pidas
        actions_frame = tk.LabelFrame(
            left_column,
            text="‚ö° ACCIONES R√ÅPIDAS",
            font=('Arial', 11, 'bold'),
            bg='#fff3e0',
            fg='#e65100',
            padx=15,
            pady=15
        )
        actions_frame.pack(fill='x', pady=(0, 15))
        
        quick_actions = [
            ("üíµ Factura Express", self.express_invoice, '#16A085'),
            ("üîç Buscar Paciente", self.search_patient_billing, '#0B5394'),
            ("üìÑ Generar Reporte", self.generate_daily_report, '#16A085'),
            ("üîÑ Actualizar Datos", self.refresh_billing_secretaria, '#64748B')
        ]
        
        for text, command, color in quick_actions:
            btn = tk.Button(
                actions_frame,
                text=text,
                command=command,
                bg=color,
                fg='white',
                font=('Arial', 9, 'bold'),
                padx=10,
                pady=6,
                relief='raised'
            )
            btn.pack(fill='x', pady=3)
        
        # Panel de citas sin facturar
        pending_frame = tk.LabelFrame(
            left_column,
            text="üìã CITAS SIN FACTURAR",
            font=('Arial', 11, 'bold'),
            bg='#ffebee',
            fg='#c62828',
            padx=15,
            pady=15
        )
        pending_frame.pack(fill='both', expand=True)
        
        # Lista de citas pendientes
        self.secretaria_pending_list = tk.Listbox(
            pending_frame,
            height=8,
            font=('Arial', 9),
            bg='white',
            selectmode='single'
        )
        self.secretaria_pending_list.pack(fill='both', expand=True, pady=(10, 10))
        
        # Bot√≥n para facturar
        bill_btn = tk.Button(
            pending_frame,
            text="üí∞ Facturar Seleccionada",
            command=self.bill_appointment_secretaria,
            bg='#0B5394',
            fg='white',
            font=('Arial', 10, 'bold'),
            padx=15,
            pady=8
        )
        bill_btn.pack(fill='x')
        
        # Panel de facturas recientes (columna derecha)
        invoices_frame = tk.LabelFrame(
            right_column,
            text="üìÑ FACTURAS RECIENTES",
            font=('Arial', 12, 'bold'),
            bg='#e3f2fd',
            fg='#1565c0',
            padx=15,
            pady=15
        )
        invoices_frame.pack(fill='both', expand=True)
        
        # Controles de filtro
        filter_frame = tk.Frame(invoices_frame, bg='#e3f2fd')
        filter_frame.pack(fill='x', pady=(0, 15))
        
        tk.Label(filter_frame, text="üîç Filtrar:", font=('Arial', 10, 'bold'),
                bg='#e3f2fd', fg='#1565c0').pack(side='left')
        
        self.filter_var = tk.StringVar()
        filter_entry = tk.Entry(filter_frame, textvariable=self.filter_var, 
                               font=('Arial', 10), width=20)
        filter_entry.pack(side='left', padx=(10, 0))
        filter_entry.bind('<KeyRelease>', self.filter_invoices_secretaria)
        
        # Estado filter
        tk.Label(filter_frame, text="Estado:", font=('Arial', 10, 'bold'),
                bg='#e3f2fd', fg='#1565c0').pack(side='left', padx=(20, 5))
        
        self.status_filter = tk.StringVar(value="todos")
        status_combo = ttk.Combobox(filter_frame, textvariable=self.status_filter,
                                   values=["todos", "pendiente", "pagada", "pago_parcial"],
                                   state="readonly", width=12)
        status_combo.pack(side='left', padx=(0, 10))
        status_combo.bind('<<ComboboxSelected>>', self.filter_invoices_secretaria)
        
        # Tabla de facturas
        columns = ('N√∫mero', 'Fecha', 'Paciente', 'Monto', 'Estado', 'Acciones')
        self.secretaria_invoices_tree = ttk.Treeview(invoices_frame, columns=columns, 
                                                    show='headings', height=15)
        
        # Configurar columnas
        column_widths = {'N√∫mero': 100, 'Fecha': 90, 'Paciente': 120, 'Monto': 90, 'Estado': 80, 'Acciones': 80}
        for col in columns:
            self.secretaria_invoices_tree.heading(col, text=col)
            self.secretaria_invoices_tree.column(col, width=column_widths.get(col, 80), anchor='center')
        
        # Scrollbar
        invoices_scroll = ttk.Scrollbar(invoices_frame, orient="vertical", 
                                       command=self.secretaria_invoices_tree.yview)
        self.secretaria_invoices_tree.configure(yscrollcommand=invoices_scroll.set)
        
        # Pack tabla
        table_frame = tk.Frame(invoices_frame, bg='#e3f2fd')
        table_frame.pack(fill='both', expand=True)
        
        self.secretaria_invoices_tree.pack(side='left', fill='both', expand=True)
        invoices_scroll.pack(side='right', fill='y')
        
        # Eventos
        self.secretaria_invoices_tree.bind('<Double-1>', self.view_invoice_details)
        
        # Cargar datos iniciales
        self.load_secretaria_billing_data()
    
    def get_billing_summary_secretaria(self):
        """Obtener resumen de facturaci√≥n para secretarias"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            today = datetime.now().strftime('%Y-%m-%d')
            current_month = datetime.now().strftime('%Y-%m')
            
            # Ingresos de hoy
            cursor.execute('''
                SELECT COALESCE(SUM(monto), 0) 
                FROM facturas 
                WHERE DATE(fecha_creacion) = ? AND estado IN ('pagada', 'pago_parcial')
            ''', (today,))
            today_income = cursor.fetchone()[0]
            
            # Facturas pendientes
            cursor.execute('SELECT COUNT(*) FROM facturas WHERE estado = "pendiente"')
            pending_count = cursor.fetchone()[0]
            
            # Facturas pagadas hoy
            cursor.execute('''
                SELECT COUNT(*) 
                FROM facturas 
                WHERE DATE(fecha_creacion) = ? AND estado = 'pagado'
            ''', (today,))
            paid_today = cursor.fetchone()[0]
            
            # Ingresos del mes
            cursor.execute('''
                SELECT COALESCE(SUM(monto), 0) 
                FROM facturas 
                WHERE strftime('%Y-%m', fecha_creacion) = ? AND estado IN ('pagada', 'pago_parcial')
            ''', (current_month,))
            month_income = cursor.fetchone()[0]
            
            conn.close()
            
            return {
                'today_income': float(today_income),
                'pending_count': pending_count,
                'paid_today': paid_today,
                'month_income': float(month_income)
            }
            
        except Exception as e:
            print(f"Error obteniendo resumen: {e}")
            return {'today_income': 0, 'pending_count': 0, 'paid_today': 0, 'month_income': 0}
    
    def load_secretaria_billing_data(self):
        """Cargar datos de facturaci√≥n para secretarias"""
        try:
            # Limpiar listas
            self.secretaria_pending_list.delete(0, tk.END)
            for item in self.secretaria_invoices_tree.get_children():
                self.secretaria_invoices_tree.delete(item)
            
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Cargar citas sin facturar
            cursor.execute('''
                SELECT c.id, c.fecha_hora, 
                       (SELECT nombre || ' ' || apellido FROM usuarios WHERE id = c.paciente_id) as paciente_nombre,
                       c.motivo
                FROM citas c
                LEFT JOIN facturas f ON c.id = f.cita_id
                WHERE c.estado = 'completada' AND f.cita_id IS NULL
                ORDER BY c.fecha_hora DESC
                LIMIT 15
            ''')
            
            pending_appointments = cursor.fetchall()
            for apt in pending_appointments:
                fecha = apt[1]
                if fecha:
                    try:
                        dt = datetime.fromisoformat(fecha)
                        fecha = dt.strftime('%d/%m %H:%M')
                    except:
                        pass
                
                text = f"{fecha} - {apt[2]} - {apt[3][:25]}..."
                self.secretaria_pending_list.insert(tk.END, text)
            
            # Cargar facturas recientes
            cursor.execute('''
                SELECT numero_factura, fecha_creacion, 
                       (SELECT nombre || ' ' || apellido FROM usuarios WHERE id = f.paciente_id) as paciente_nombre,
                       monto, estado
                FROM facturas f
                ORDER BY fecha_creacion DESC
                LIMIT 50
            ''')
            
            invoices = cursor.fetchall()
            for invoice in invoices:
                fecha = invoice[1]
                if fecha:
                    try:
                        dt = datetime.fromisoformat(fecha)
                        fecha = dt.strftime('%d/%m/%Y')
                    except:
                        pass
                
                estado = invoice[4].title() if invoice[4] else 'Desconocido'
                
                self.secretaria_invoices_tree.insert('', 'end', values=(
                    invoice[0] or 'N/A',
                    fecha,
                    invoice[2] or 'N/A',
                    f"RD${float(invoice[3] or 0):,.2f}",
                    estado,
                    "Ver"
                ))
            
            conn.close()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error cargando datos: {str(e)}")
    
    def create_new_invoice_secretaria(self):
        """Crear nueva factura desde secretar√≠a"""
        messagebox.showinfo("Nueva Factura", 
                           "Use el 'Sistema Completo' para crear facturas con todas las funcionalidades avanzadas:\n\n" +
                           "‚Ä¢ PDFs autom√°ticos\n‚Ä¢ Control de pagos\n‚Ä¢ C√°lculo de cambio\n‚Ä¢ Selecci√≥n de servicios")
    
    def process_payment_secretaria(self):
        """Procesar pago desde secretar√≠a"""
        messagebox.showinfo("Procesar Pago", 
                           "Use el 'Sistema Completo' para procesar pagos con:\n\n" +
                           "‚Ä¢ M√∫ltiples m√©todos de pago\n‚Ä¢ C√°lculo autom√°tico de cambio\n‚Ä¢ Generaci√≥n de recibos PDF")
    
    def express_invoice(self):
        """Factura express"""
        messagebox.showinfo("Factura Express", "Funcionalidad disponible en Sistema Completo")
    
    def search_patient_billing(self):
        """Buscar paciente para facturaci√≥n"""
        search_term = simpledialog.askstring("Buscar Paciente", "Ingrese nombre del paciente:")
        if search_term:
            messagebox.showinfo("B√∫squeda", f"B√∫squeda avanzada disponible en Sistema Completo")
    
    def generate_daily_report(self):
        """Generar reporte diario"""
        messagebox.showinfo("Reporte Diario", "Generaci√≥n de reportes PDF disponible en Sistema Completo")
    
    def refresh_billing_secretaria(self):
        """Actualizar datos de facturaci√≥n"""
        self.load_secretaria_billing_data()
        messagebox.showinfo("Actualizado", "‚úÖ Datos actualizados correctamente")
    
    def bill_appointment_secretaria(self):
        """Facturar cita seleccionada desde secretar√≠a"""
        selection = self.secretaria_pending_list.curselection()
        if not selection:
            messagebox.showwarning("Selecci√≥n", "Seleccione una cita para facturar")
            return
        
        messagebox.showinfo("Facturar Cita", 
                           "Use el 'Sistema Completo' para facturar citas con:\n\n" +
                           "‚Ä¢ Selecci√≥n de servicios m√©dicos\n‚Ä¢ Aplicaci√≥n de seguros\n‚Ä¢ Generaci√≥n autom√°tica de PDFs")
    
    def filter_invoices_secretaria(self, event=None):
        """Filtrar facturas en la vista de secretar√≠a"""
        # Implementaci√≥n b√°sica de filtrado
        filter_text = self.filter_var.get().lower()
        status_filter = self.status_filter.get()
        
        # Recargar datos con filtros aplicados
        self.load_secretaria_billing_data()  # Por simplicidad, recargamos todo
    
    def view_invoice_details(self, event=None):
        """Ver detalles de factura seleccionada"""
        selection = self.secretaria_invoices_tree.selection()
        if not selection:
            return
        
        item = self.secretaria_invoices_tree.item(selection[0])
        invoice_number = item['values'][0]
        
        messagebox.showinfo("Detalles de Factura", 
                           f"Factura: {invoice_number}\n\n" +
                           "Vista detallada y edici√≥n disponible en Sistema Completo")
    
    def create_secretaria_reports(self, parent):
        """Reportes para secretarias"""
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # T√≠tulo
        tk.Label(main_frame, text="Reportes y Estad√≠sticas", 
                font=('Arial', 16, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(pady=(0, 20))
        
        # Panel de reportes financieros
        financial_frame = tk.LabelFrame(main_frame, text="üí∞ Reportes Financieros", 
                                      font=('Arial', 12, 'bold'), padx=20, pady=15)
        financial_frame.pack(fill='x', pady=10)
        
        financial_buttons = [
            ("üìä Ingresos Diarios", self.daily_income_report, "#0B5394"),
            ("üìà Ingresos Mensuales", self.monthly_income_report, "#16A085"),
            ("üìã Facturas Pendientes", self.pending_invoices_report, "#C0392B"),
            ("üí≥ M√©todos de Pago", self.payment_methods_report, "#16A085")
        ]
        
        financial_grid = tk.Frame(financial_frame)
        financial_grid.pack()
        
        for i, (text, command, color) in enumerate(financial_buttons):
            btn = tk.Button(financial_grid, text=text, command=command, 
                           bg=color, fg='white', font=('Arial', 10, 'bold'),
                           width=20, height=2)
            btn.grid(row=i//2, column=i%2, padx=10, pady=10)
        
        # Panel de reportes operativos
        operational_frame = tk.LabelFrame(main_frame, text="üìã Reportes Operativos", 
                                        font=('Arial', 12, 'bold'), padx=20, pady=15)
        operational_frame.pack(fill='x', pady=10)
        
        operational_buttons = [
            ("üìÖ Citas por Per√≠odo", self.appointments_period_report, "#64748B"),
            ("üë®‚Äç‚öïÔ∏è Productividad Doctores", self.doctors_productivity_report, "#059669"),
            ("ü§í Registro de Pacientes", self.patients_registry_report, "#E67E22"),
            ("üìû Lista de Contactos", self.contacts_list_report, "#8e44ad")
        ]
        
        operational_grid = tk.Frame(operational_frame)
        operational_grid.pack()
        
        for i, (text, command, color) in enumerate(operational_buttons):
            btn = tk.Button(operational_grid, text=text, command=command, 
                           bg=color, fg='white', font=('Arial', 10, 'bold'),
                           width=20, height=2)
            btn.grid(row=i//2, column=i%2, padx=10, pady=10)
        
        # Panel de estad√≠sticas r√°pidas
        stats_frame = tk.LabelFrame(main_frame, text="üìä Estad√≠sticas R√°pidas", 
                                  font=('Arial', 12, 'bold'), padx=20, pady=15)
        stats_frame.pack(fill='both', expand=True, pady=10)
        
        # Crear √°rea de estad√≠sticas
        stats_display = tk.Frame(stats_frame, bg='white', relief='sunken', bd=2)
        stats_display.pack(fill='both', expand=True, padx=10, pady=10)
        
        try:
            quick_stats = self.get_secretaria_quick_stats()
            
            stats_text = f"""
üìä RESUMEN GENERAL
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìÖ Citas Programadas Hoy: {quick_stats.get('appointments_today', 0)}
‚è≥ Citas Pendientes: {quick_stats.get('pending_appointments', 0)}
‚úÖ Citas Completadas Hoy: {quick_stats.get('completed_today', 0)}

üë• PACIENTES
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üë§ Total de Pacientes: {quick_stats.get('total_patients', 0)}
üÜï Nuevos este Mes: {quick_stats.get('new_patients_month', 0)}
üìû Contactos Pendientes: {quick_stats.get('pending_contacts', 0)}

üí∞ FACTURACI√ìN
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üíµ Ingresos Hoy: RD$ {quick_stats.get('today_income', 0):,.2f}
üìã Facturas Pendientes: {quick_stats.get('pending_invoices', 0)}
‚úÖ Facturas Pagadas Hoy: {quick_stats.get('paid_today', 0)}
üìä Total del Mes: RD$ {quick_stats.get('month_total', 0):,.2f}

üë®‚Äç‚öïÔ∏è DOCTORES
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üè• Doctores Activos: {quick_stats.get('active_doctors', 0)}
üìÖ Consultas Programadas: {quick_stats.get('scheduled_consultations', 0)}
            """
            
            stats_label = tk.Label(stats_display, text=stats_text, font=('Courier', 10), 
                                 justify='left', bg='white', fg='#1E3A8A')
            stats_label.pack(pady=10, padx=10)
            
        except Exception as e:
            tk.Label(stats_display, text=f"Error cargando estad√≠sticas: {str(e)}", 
                    fg='red', bg='white').pack(pady=20)
    
    # ==================== FUNCIONES PARA PACIENTES ====================
    
    def create_patient_dashboard(self, parent):
        """Dashboard espec√≠fico para pacientes con dise√±o moderno similar al admin"""
        # Frame principal con mejor dise√±o
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True)
        
        # Header principal con gradiente visual
        header_frame = tk.Frame(main_frame, bg='#1E3A8A', height=80)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Contenido del header
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=30, pady=15)
        
        # T√≠tulo principal
        title_frame = tk.Frame(header_content, bg='#1E3A8A')
        title_frame.pack(side='left', fill='y')
        
        tk.Label(title_frame, text="üè† Mi Dashboard Personal", 
                font=('Arial', 20, 'bold'), bg='#1E3A8A', fg='white').pack(anchor='w')
        tk.Label(title_frame, text=f"Bienvenido/a {self.current_user.nombre} - Resumen de tu salud", 
                font=('Arial', 11), bg='#1E3A8A', fg='#CBD5E1').pack(anchor='w')
        
        # Informaci√≥n del paciente actual
        user_info_frame = tk.Frame(header_content, bg='#1E3A8A')
        user_info_frame.pack(side='right', fill='y')
        
        tk.Label(user_info_frame, text=f"ü§í {self.current_user.nombre} {self.current_user.apellido}", 
                font=('Arial', 12, 'bold'), bg='#1E3A8A', fg='white').pack(anchor='e')
        tk.Label(user_info_frame, text="Paciente del Sistema", 
                font=('Arial', 10), bg='#1E3A8A', fg='#CBD5E1').pack(anchor='e')
        
        # Contenido principal directo sin scrollbar
        content_frame = tk.Frame(main_frame, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True, padx=15, pady=10)
        
        # Tarjetas de estad√≠sticas personales del paciente optimizadas
        stats_frame = tk.Frame(content_frame, bg='#F8FAFC')
        stats_frame.pack(fill='x', pady=(0, 20))
        
        try:
            patient_stats = self.get_patient_stats()
            
            # Crear frame para las 4 tarjetas con mejor distribuci√≥n
            stats_container = tk.Frame(stats_frame, bg='#F8FAFC')
            stats_container.pack(fill='x', expand=True)
            
            # Crear tarjetas de estad√≠sticas mejoradas
            stats_data = [
                ("üìÖ", "Pr√≥ximas Citas", patient_stats.get('upcoming_appointments', 0), "#16A085"),
                ("üìã", "Consultas Totales", patient_stats.get('total_consultations', 0), "#0B5394"), 
                ("üí∞", "Facturas Pendientes", patient_stats.get('pending_bills', 0), "#E67E22"),
                ("üë®‚Äç‚öïÔ∏è", "Doctores Visitados", patient_stats.get('doctors_visited', 0), "#059669")
            ]
            
            for i, (icon, title, value, color) in enumerate(stats_data):
                # Crear tarjeta individual con mejor dise√±o
                card_frame = tk.Frame(stats_container, bg='white', relief='solid', bd=1)
                card_frame.grid(row=0, column=i, padx=6, pady=6, sticky='ew')
                
                # Header colorido de la tarjeta
                header = tk.Frame(card_frame, bg=color, height=8)
                header.pack(fill='x')
                header.pack_propagate(False)
                
                # Contenido de la tarjeta con mejor espaciado
                content = tk.Frame(card_frame, bg='white')
                content.pack(fill='both', expand=True, padx=15, pady=15)
                
                # Icono y valor m√°s grandes
                tk.Label(content, text=icon, font=('Arial', 28), bg='white', fg=color).pack(pady=(0, 8))
                tk.Label(content, text=str(value), font=('Arial', 24, 'bold'), bg='white', fg=color).pack()
                tk.Label(content, text=title, font=('Arial', 10), bg='white', fg='#64748B', 
                        wraplength=120, justify='center').pack(pady=(5, 0))
                
                # Configurar expansi√≥n igual para todas las columnas
                stats_container.columnconfigure(i, weight=1)
                
        except Exception as e:
            error_label = tk.Label(stats_frame, text=f"Error cargando estad√≠sticas: {str(e)}", 
                                 font=('Arial', 10), fg='red', bg='#F8FAFC')
            error_label.pack(pady=20)
        
        # Frame horizontal para informaci√≥n personal y citas pr√≥ximas
        top_horizontal_frame = tk.Frame(content_frame, bg='#F8FAFC')
        top_horizontal_frame.pack(fill='x', pady=(0, 20))
        
        # Panel de informaci√≥n personal m√°s peque√±o (lado izquierdo)
        info_panel = tk.LabelFrame(top_horizontal_frame, text="üìã Mi Informaci√≥n Personal", 
                                  font=('Arial', 13, 'bold'), padx=15, pady=15, 
                                  bg='white', relief='solid', bd=1)
        info_panel.pack(side='left', fill='both', expand=True, padx=(0, 10))
        
        # Grid de informaci√≥n personal compacto
        info_grid = tk.Frame(info_panel, bg='white')
        info_grid.pack(fill='both', expand=True, padx=10, pady=10)
        
        try:
            patient_info = self.get_patient_info(self.current_user.id)
            
            info_items = [
                ("üë§ Nombre:", f"{patient_info.get('nombre', '')} {patient_info.get('apellido', '')}"),
                ("üìß Email:", patient_info.get('email', 'No especificado')),
                ("üìû Tel√©fono:", patient_info.get('telefono', 'No especificado')),
                ("üè• Expediente:", patient_info.get('numero_expediente', 'No asignado')),
                ("ü©∏ Tipo Sangre:", patient_info.get('tipo_sangre', 'No especificado')),
                ("üéÇ F. Nacimiento:", patient_info.get('fecha_nacimiento', 'No especificada'))
            ]
            
            # Distribuir en 2 columnas para mostrar todos los datos
            for i, (label, value) in enumerate(info_items):
                row = i // 2
                col = (i % 2) * 2
                
                tk.Label(info_grid, text=label, font=('Arial', 10, 'bold'), 
                        bg='white', fg='#1E3A8A').grid(row=row, column=col, sticky='w', padx=(0, 8), pady=8)
                tk.Label(info_grid, text=value, font=('Arial', 10), 
                        bg='white', fg='#64748B').grid(row=row, column=col+1, sticky='w', padx=(0, 15), pady=8)
            
            # Configurar grid weights para mejor distribuci√≥n
            info_grid.columnconfigure(1, weight=1)
            info_grid.columnconfigure(3, weight=1)
                        
        except Exception as e:
            tk.Label(info_panel, text=f"Error cargando informaci√≥n: {str(e)}", 
                    font=('Arial', 9), fg='red', bg='white').pack(pady=8)
        
        # Panel de pr√≥ximas citas (lado derecho)
        appointments_panel = tk.LabelFrame(top_horizontal_frame, text="üìÖ Mis Pr√≥ximas Citas", 
                                         font=('Arial', 13, 'bold'), padx=15, pady=12, 
                                         bg='white', relief='solid', bd=1)
        appointments_panel.pack(side='right', fill='both', expand=True, padx=(10, 0))
        
        try:
            upcoming_appointments = self.get_patient_upcoming_appointments()
            
            if upcoming_appointments:
                appointments_content = tk.Frame(appointments_panel, bg='white')
                appointments_content.pack(fill='both', expand=True, padx=8, pady=8)
                
                for i, appointment in enumerate(upcoming_appointments[:4]):  # Mostrar m√°ximo 4
                    appt_frame = tk.Frame(appointments_content, bg='#F0F9FF', relief='solid', bd=1)
                    appt_frame.pack(fill='x', pady=3, padx=3)
                    
                    appt_inner = tk.Frame(appt_frame, bg='#F0F9FF')
                    appt_inner.pack(fill='x', padx=10, pady=6)
                    
                    # Fecha y hora m√°s prominente
                    tk.Label(appt_inner, text=f"üìÖ {appointment.get('fecha', 'N/A')} - {appointment.get('hora', 'N/A')}", 
                            font=('Arial', 10, 'bold'), bg='#F0F9FF', fg='#0B5394').pack(anchor='w')
                    
                    # Doctor y motivo
                    tk.Label(appt_inner, text=f"üë®‚Äç‚öïÔ∏è Dr. {appointment.get('doctor', 'N/A')}", 
                            font=('Arial', 9), bg='#F0F9FF', fg='#64748B').pack(anchor='w', pady=(1, 0))
                    
                    tk.Label(appt_inner, text=f"ü©∫ {appointment.get('motivo', 'Consulta general')}", 
                            font=('Arial', 9), bg='#F0F9FF', fg='#64748B').pack(anchor='w')
            else:
                tk.Label(appointments_panel, text="üìÖ No tienes citas programadas pr√≥ximamente", 
                        font=('Arial', 10), bg='white', fg='#64748B').pack(pady=15)
                        
        except Exception as e:
            tk.Label(appointments_panel, text=f"Error cargando citas: {str(e)}", 
                    font=('Arial', 9), fg='red', bg='white').pack(pady=8)
        
        # Frame horizontal para recordatorios (ahora ocupa todo el ancho)
        bottom_frame = tk.Frame(content_frame, bg='#F8FAFC')
        bottom_frame.pack(fill='both', expand=True, pady=(0, 10))
        
        # Panel de recordatorios de salud optimizado (ahora usa todo el ancho)
        reminders_panel = tk.LabelFrame(bottom_frame, text="üîî Recordatorios de Salud", 
                                      font=('Arial', 14, 'bold'), padx=20, pady=15, 
                                      bg='white', relief='solid', bd=1)
        reminders_panel.pack(fill='both', expand=True)
        
        try:
            reminders = self.get_patient_reminders()
            
            if reminders:
                reminders_content = tk.Frame(reminders_panel, bg='white')
                reminders_content.pack(fill='both', expand=True, padx=10, pady=10)
                
                for reminder in reminders:
                    reminder_frame = tk.Frame(reminders_content, bg='#FEF3C7', relief='solid', bd=1)
                    reminder_frame.pack(fill='x', pady=4, padx=5)
                    
                    tk.Label(reminder_frame, text=f"‚ö†Ô∏è {reminder}", 
                            font=('Arial', 10), bg='#FEF3C7', fg='#92400E').pack(padx=15, pady=8)
            else:
                # Panel de estado positivo m√°s atractivo
                positive_frame = tk.Frame(reminders_panel, bg='#DCFCE7', relief='solid', bd=1)
                positive_frame.pack(fill='both', expand=True, padx=10, pady=10)
                
                tk.Label(positive_frame, text="‚úÖ ¬°Excelente! Tienes tu salud al d√≠a", 
                        font=('Arial', 12, 'bold'), bg='#DCFCE7', fg='#059669').pack(pady=15)
                tk.Label(positive_frame, text="No hay recordatorios pendientes en este momento", 
                        font=('Arial', 10), bg='#DCFCE7', fg='#16A34A').pack(pady=(0, 15))
                        
        except Exception as e:
            tk.Label(reminders_panel, text=f"Error cargando recordatorios: {str(e)}", 
                    font=('Arial', 10), fg='red', bg='white').pack(pady=10)
    
    def create_patient_appointments(self, parent):
        """Citas del paciente con dise√±o moderno similar al admin"""
        # Frame principal con mejor dise√±o
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True)

        # Header principal con gradiente visual
        header_frame = tk.Frame(main_frame, bg='#1E3A8A', height=80)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Contenido del header
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=30, pady=15)
        
        # T√≠tulo principal
        title_frame = tk.Frame(header_content, bg='#1E3A8A')
        title_frame.pack(side='left', fill='y')
        
        tk.Label(title_frame, text="üìÖ Gesti√≥n de Mis Citas", 
                font=('Arial', 20, 'bold'), bg='#1E3A8A', fg='white').pack(anchor='w')
        tk.Label(title_frame, text="Administra y agenda tus citas m√©dicas", 
                font=('Arial', 11), bg='#1E3A8A', fg='#CBD5E1').pack(anchor='w')
        
        # Botones de acci√≥n en el header
        actions_frame = tk.Frame(header_content, bg='#1E3A8A')
        actions_frame.pack(side='right', fill='y')
        
        tk.Button(actions_frame, text="‚ûï Agendar Nueva Cita", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), relief='flat', padx=15, pady=8,
                 command=self.open_patient_schedule_dialog).pack(side='right', padx=(10, 0))
        tk.Button(actions_frame, text="üîÑ Actualizar Lista", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), relief='flat', padx=15, pady=8,
                 command=self.update_patient_appointments_list).pack(side='right', padx=(10, 0))

        # Contenido principal
        content_frame = tk.Frame(main_frame, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True, padx=30, pady=30)

        # Panel dividido moderno: Calendario + Lista
        main_content = tk.Frame(content_frame, bg='#F8FAFC')
        main_content.pack(fill='both', expand=True)

        # Panel izquierdo - Calendario y filtros
        left_panel = tk.Frame(main_content, bg='white', relief='solid', bd=1, width=380)
        left_panel.pack(side='left', fill='y', padx=(0, 15))
        left_panel.pack_propagate(False)

        # Header del calendario
        cal_header = tk.Frame(left_panel, bg='#0B5394', height=45)
        cal_header.pack(fill='x')
        cal_header.pack_propagate(False)
        tk.Label(cal_header, text="üìÖ Calendario de Citas", font=('Arial', 12, 'bold'), 
                fg='white', bg='#0B5394').pack(pady=10)

        # Contenedor del calendario
        cal_container = tk.Frame(left_panel, bg='white')
        cal_container.pack(fill='both', expand=True, padx=15, pady=15)

        self.patient_cal_date = tk.StringVar()
        if CALENDAR_AVAILABLE:
            self.patient_calendar = Calendar(cal_container, selectmode='day', 
                                           date_pattern='dd/mm/yyyy',
                                           background='#0B5394',
                                           foreground='white',
                                           bordercolor='#1E3A8A',
                                           headersbackground='#1E3A8A',
                                           normalbackground='white',
                                           normalforeground='black',
                                           weekendbackground='#F8FAFC',
                                           weekendforeground='#64748B')
            self.patient_calendar.pack(fill='both', expand=True)
            
            def on_cal_select(event=None):
                self.patient_cal_date.set(self.patient_calendar.get_date())
                self.load_patient_appointments()
            self.patient_calendar.bind("<<CalendarSelected>>", on_cal_select)
        else:
            # Fallback sin calendario
            no_cal_frame = tk.Frame(cal_container, bg='#F8FAFC', relief='solid', bd=1)
            no_cal_frame.pack(fill='both', expand=True, padx=10, pady=10)
            
            tk.Label(no_cal_frame, text="üìÖ Filtro por Fecha", 
                    font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(pady=(10, 5))
            tk.Label(no_cal_frame, text="(Calendario no disponible)", 
                    font=('Arial', 9), bg='#F8FAFC', fg='#64748B').pack()
            
            date_entry = tk.Entry(no_cal_frame, textvariable=self.patient_cal_date, 
                                 font=('Arial', 10), justify='center')
            date_entry.pack(pady=10, padx=10, fill='x')
            
            tk.Button(no_cal_frame, text='üîç Filtrar por Fecha', 
                     command=self.load_patient_appointments,
                     bg='#0B5394', fg='white', font=('Arial', 9, 'bold'),
                     relief='flat', pady=5).pack(pady=(5, 10), padx=10, fill='x')

        # Filtros r√°pidos mejorados
        filters_frame = tk.LabelFrame(left_panel, text="üîç Filtros R√°pidos", 
                                    font=('Arial', 10, 'bold'), padx=15, pady=10, bg='white')
        filters_frame.pack(fill='x', padx=15, pady=(0, 15))
        
        tk.Label(filters_frame, text="Mostrar:", font=('Arial', 9, 'bold'), bg='white').pack(anchor='w')
        self.patient_appointment_filter = ttk.Combobox(filters_frame, 
                                                     values=['Todas', 'Pr√≥ximas', 'Pasadas', 'Este Mes'], 
                                                     state='readonly', width=15, font=('Arial', 9))
        self.patient_appointment_filter.set('Pr√≥ximas')
        self.patient_appointment_filter.pack(fill='x', pady=5)
        self.patient_appointment_filter.bind('<<ComboboxSelected>>', lambda e: self.load_patient_appointments())

        # Panel derecho - Lista de citas
        right_panel = tk.Frame(main_content, bg='white', relief='solid', bd=1)
        right_panel.pack(side='left', fill='both', expand=True)

        # Header de la lista
        list_header = tk.Frame(right_panel, bg='#0B5394', height=45)
        list_header.pack(fill='x')
        list_header.pack_propagate(False)
        
        # Frame interno para t√≠tulo y contador
        header_content = tk.Frame(list_header, bg='#0B5394')
        header_content.pack(fill='both', expand=True, padx=15, pady=10)
        
        tk.Label(header_content, text="üìã Lista de Mis Citas", font=('Arial', 12, 'bold'), 
                fg='white', bg='#0B5394').pack(side='left')
        
        # Contador de citas
        self.patient_appointments_count_label = tk.Label(header_content, text="üìã Total: 0 citas", 
                                                       font=('Arial', 10), fg='white', bg='#0B5394')
        self.patient_appointments_count_label.pack(side='right')

        # Tabla de citas con scrollbars mejorados
        table_container = tk.Frame(right_panel, bg='white')
        table_container.pack(fill='both', expand=True, padx=15, pady=15)

        columns = ('ID','Fecha','Hora','Doctor','Motivo','Estado')
        self.patient_appointments_tree = ttk.Treeview(table_container, columns=columns, show='headings', height=12)
        
        # Configurar columnas
        column_widths = {'ID': 50, 'Fecha': 100, 'Hora': 80, 'Doctor': 130, 'Motivo': 150, 'Estado': 100}
        for col in columns:
            self.patient_appointments_tree.heading(col, text=col, anchor='center')
            self.patient_appointments_tree.column(col, width=column_widths.get(col, 100), anchor='center')

        # Scrollbars con mejor dise√±o
        v_scrollbar = ttk.Scrollbar(table_container, orient='vertical', command=self.patient_appointments_tree.yview)
        h_scrollbar = ttk.Scrollbar(table_container, orient='horizontal', command=self.patient_appointments_tree.xview)
        self.patient_appointments_tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        
        # Layout con grid para mejor control
        self.patient_appointments_tree.grid(row=0, column=0, sticky='nsew')
        v_scrollbar.grid(row=0, column=1, sticky='ns')
        h_scrollbar.grid(row=1, column=0, sticky='ew')
        
        # Configurar expansi√≥n
        table_container.grid_rowconfigure(0, weight=1)
        table_container.grid_columnconfigure(0, weight=1)
        
        # Agregar eventos para mejor interacci√≥n
        self.patient_appointments_tree.bind('<Double-1>', lambda e: self.view_my_appointment_details())
        self.patient_appointments_tree.bind('<ButtonRelease-1>', self.on_patient_appointment_select)
        self.patient_appointments_tree.bind('<Button-3>', self.show_appointment_context_menu)  # Clic derecho
        
        # Agregar tooltip o informaci√≥n de ayuda
        help_frame = tk.Frame(table_container, bg='white')
        help_frame.grid(row=2, column=0, columnspan=2, sticky='ew', pady=(5, 0))
        
        tk.Label(help_frame, text="üí° Consejo: Haga doble clic en una cita para ver sus detalles", 
                font=('Arial', 9, 'italic'), bg='white', fg='#64748B').pack(side='left')
        
        # Panel de informaci√≥n de cita seleccionada - m√°s prominente
        self.selected_appointment_info = tk.Frame(right_panel, bg='#F0F9FF', relief='solid', bd=2, height=60)
        self.selected_appointment_info.pack(fill='x', padx=15, pady=(0, 15))
        self.selected_appointment_info.pack_propagate(False)
        
        # Inicialmente oculto
        self.selected_appointment_info.pack_forget()
        
        # Label para mostrar informaci√≥n de la cita seleccionada
        self.selected_info_label = tk.Label(self.selected_appointment_info, 
                                          text="Seleccione una cita para ver informaci√≥n r√°pida", 
                                          font=('Arial', 11, 'bold'), bg='#F0F9FF', fg='#1E40AF',
                                          wraplength=600, justify='center')
        self.selected_info_label.pack(expand=True, pady=10, padx=15)
        
        # Agregar icono de estado
        self.status_icon_label = tk.Label(self.selected_appointment_info,
                                        text="‚ÑπÔ∏è", font=('Arial', 16), bg='#F0F9FF')
        self.status_icon_label.pack(side='left', padx=(15, 5))

        # Panel de acciones mejorado - m√°s visible y organizado
        actions_panel = tk.Frame(main_frame, bg='#F8FAFC')
        actions_panel.pack(fill='x', padx=30, pady=(0, 30))
        
        # Frame interno con mejor visibilidad
        actions_inner = tk.Frame(actions_panel, bg='white', relief='solid', bd=2)
        actions_inner.pack(fill='x', pady=10)
        
        # Header del panel de acciones
        actions_header = tk.Frame(actions_inner, bg='#0B5394', height=40)
        actions_header.pack(fill='x')
        actions_header.pack_propagate(False)
        
        tk.Label(actions_header, text="‚ö° ACCIONES DISPONIBLES", 
                font=('Arial', 12, 'bold'), bg='#0B5394', fg='white').pack(expand=True)
        
        # Contenido de botones
        actions_content = tk.Frame(actions_inner, bg='white')
        actions_content.pack(fill='x', padx=20, pady=20)
        
        # Primera fila de botones (principales)
        first_row = tk.Frame(actions_content, bg='white')
        first_row.pack(fill='x', pady=(0, 10))
        
        # Segunda fila de botones (secundarios)
        second_row = tk.Frame(actions_content, bg='white')
        second_row.pack(fill='x')
        
        # Botones principales (primera fila)
        main_buttons = [
            ("üëÅÔ∏è Ver Detalles", self.view_my_appointment_details, "#0B5394"),
            ("‚úèÔ∏è Editar Cita", self.edit_my_appointment, "#F39C12")
        ]
        
        # Botones secundarios (segunda fila)
        secondary_buttons = [
            ("‚ùå Cancelar Cita", self.cancel_my_appointment, "#DC2626"),
            ("üìß Contactar Doctor", lambda: messagebox.showinfo("Contactar", "Funci√≥n en desarrollo"), "#16A085")
        ]
        
        # Crear botones principales (m√°s grandes)
        for text, command, color in main_buttons:
            btn = tk.Button(first_row, text=text, command=command,
                           bg=color, fg='white', font=('Arial', 12, 'bold'),
                           relief='flat', bd=0, padx=25, pady=12, cursor='hand2')
            btn.pack(side='left', padx=10, expand=True, fill='x')
            
            # Agregar efectos hover
            def on_enter(e, button=btn, original_color=color):
                button.config(bg=self.darken_color(original_color))
            
            def on_leave(e, button=btn, original_color=color):
                button.config(bg=original_color)
            
            btn.bind("<Enter>", on_enter)
            btn.bind("<Leave>", on_leave)
        
        # Crear botones secundarios
        for text, command, color in secondary_buttons:
            btn = tk.Button(second_row, text=text, command=command,
                           bg=color, fg='white', font=('Arial', 11, 'bold'),
                           relief='flat', bd=0, padx=20, pady=10, cursor='hand2')
            btn.pack(side='left', padx=10, expand=True, fill='x')
            
            # Agregar efectos hover
            def on_enter(e, button=btn, original_color=color):
                button.config(bg=self.darken_color(original_color))
            
            def on_leave(e, button=btn, original_color=color):
                button.config(bg=original_color)
            
            btn.bind("<Enter>", on_enter)
            btn.bind("<Leave>", on_leave)

        # Agregar informaci√≥n de ayuda
        help_info = tk.Frame(actions_inner, bg='#F0F9FF')
        help_info.pack(fill='x', padx=20, pady=(0, 15))
        
        tk.Label(help_info, text="üí° Consejo: Seleccione una cita de la lista para activar las acciones", 
                font=('Arial', 9, 'italic'), bg='#F0F9FF', fg='#1E40AF').pack()
        
        # Cargar datos iniciales
        self.load_patient_appointments()
    
    def create_tooltip(self, widget, text):
        """Crear tooltip para un widget"""
        def show_tooltip(event):
            tooltip = tk.Toplevel()
            tooltip.wm_overrideredirect(True)
            tooltip.wm_geometry(f"+{event.x_root+10}+{event.y_root+10}")
            
            label = tk.Label(tooltip, text=text, background='#FFFFCC', 
                           relief='solid', borderwidth=1, font=('Arial', 9))
            label.pack()
            
            def hide_tooltip():
                tooltip.destroy()
            
            widget.tooltip = tooltip
            tooltip.after(3000, hide_tooltip)  # Auto-hide after 3 seconds
        
        def hide_tooltip(event):
            if hasattr(widget, 'tooltip'):
                widget.tooltip.destroy()
        
        widget.bind('<Enter>', show_tooltip)
        widget.bind('<Leave>', hide_tooltip)

    def on_patient_appointment_select(self, event):
        """Maneja la selecci√≥n de una cita para mostrar informaci√≥n r√°pida"""
        try:
            sel = self.patient_appointments_tree.selection()
            if not sel:
                self.selected_appointment_info.pack_forget()
                return
            
            vals = self.patient_appointments_tree.item(sel[0])['values']
            if not vals:
                return
            
            # Extraer informaci√≥n
            appt_id = vals[0]
            fecha = vals[1]
            hora = vals[2]
            doctor = vals[3]
            motivo = vals[4]
            estado = vals[5]
            
            # Construir texto informativo m√°s detallado
            info_text = f"ÔøΩÔ∏è {fecha} a las {hora} con {doctor}\nüí≠ {motivo}\nüìä Estado: {estado}"
            
            # Mostrar informaci√≥n
            self.selected_info_label.config(text=info_text)
            self.selected_appointment_info.pack(fill='x', padx=15, pady=(0, 15))
            
            # Cambiar color e icono seg√∫n el estado
            status_colors = {
                'PENDIENTE': {'bg': '#FEF3C7', 'icon': '‚è≥'},
                'CONFIRMADA': {'bg': '#D1FAE5', 'icon': '‚úÖ'}, 
                'COMPLETADA': {'bg': '#E0E7FF', 'icon': '‚úîÔ∏è'},
                'CANCELADA': {'bg': '#FEE2E2', 'icon': '‚ùå'}
            }
            
            estado_upper = estado.upper()
            if estado_upper in status_colors:
                color_info = status_colors[estado_upper]
                self.selected_appointment_info.config(bg=color_info['bg'])
                self.selected_info_label.config(bg=color_info['bg'])
                if hasattr(self, 'status_icon_label'):
                    self.status_icon_label.config(text=color_info['icon'], bg=color_info['bg'])
            else:
                # Color por defecto
                self.selected_appointment_info.config(bg='#F0F9FF')
                self.selected_info_label.config(bg='#F0F9FF')
                if hasattr(self, 'status_icon_label'):
                    self.status_icon_label.config(text='‚ÑπÔ∏è', bg='#F0F9FF')
            
        except Exception as e:
            print(f"Error en selecci√≥n de cita: {e}")
            self.selected_appointment_info.pack_forget()
    
    def show_appointment_context_menu(self, event):
        """Muestra men√∫ contextual para acciones r√°pidas en citas"""
        try:
            # Seleccionar el item bajo el cursor
            item = self.patient_appointments_tree.identify_row(event.y)
            if item:
                self.patient_appointments_tree.selection_set(item)
                
                # Obtener datos de la cita
                vals = self.patient_appointments_tree.item(item)['values']
                if not vals:
                    return
                
                estado = vals[5] if len(vals) > 5 else ""
                
                # Crear men√∫ contextual
                context_menu = tk.Menu(self.root, tearoff=0)
                
                # Opciones siempre disponibles
                context_menu.add_command(label="üëÅÔ∏è Ver Detalles", 
                                       command=self.view_my_appointment_details)
                
                context_menu.add_separator()
                
                # Opciones condicionales seg√∫n el estado
                if estado.lower() not in ['completada', 'cancelada']:
                    context_menu.add_command(label="‚úèÔ∏è Editar Cita", 
                                           command=self.edit_my_appointment)
                    context_menu.add_command(label="‚ùå Cancelar Cita", 
                                           command=self.cancel_my_appointment)
                else:
                    context_menu.add_command(label="‚úèÔ∏è Editar Cita", 
                                           command=self.edit_my_appointment,
                                           state='disabled')
                    context_menu.add_command(label="‚ùå Cancelar Cita", 
                                           command=self.cancel_my_appointment,
                                           state='disabled')
                
                context_menu.add_separator()
                context_menu.add_command(label="üìß Contactar Doctor", 
                                       command=lambda: messagebox.showinfo("Contactar", "Funci√≥n en desarrollo"))
                
                # Mostrar men√∫
                context_menu.post(event.x_root, event.y_root)
                
        except Exception as e:
            print(f"Error mostrando men√∫ contextual: {e}")
    
    def create_patient_medical_history(self, parent):
        """Mi historial m√©dico para pacientes - Vista simplificada con tabla"""
        # Frame principal
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True)
        
        # Header simple
        header_frame = tk.Frame(main_frame, bg='#1E3A8A', height=70)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Contenido del header
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=30, pady=15)
        
        tk.Label(header_content, text="üìã Mi Historial M√©dico", 
                font=('Arial', 18, 'bold'), bg='#1E3A8A', fg='white').pack(side='left')
        
        user_info = f"Paciente: {self.current_user.nombre} {self.current_user.apellido}"
        tk.Label(header_content, text=user_info, 
                font=('Arial', 11), bg='#1E3A8A', fg='#CBD5E1').pack(side='right')
        
        # Contenido principal
        content_frame = tk.Frame(main_frame, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True, padx=30, pady=20)
        
        # Panel de filtros simple
        filters_frame = tk.LabelFrame(content_frame, text="üîç Filtros", 
                                    font=('Arial', 12, 'bold'), bg='white', padx=15, pady=10)
        filters_frame.pack(fill='x', pady=(0, 20))
        
        filters_row = tk.Frame(filters_frame, bg='white')
        filters_row.pack(fill='x')
        
        # B√∫squeda
        tk.Label(filters_row, text="Buscar:", font=('Arial', 10, 'bold'), 
                bg='white', fg='#374151').grid(row=0, column=0, sticky='w', padx=(0, 10))
        
        self.history_search_var = tk.StringVar()
        search_entry = tk.Entry(filters_row, textvariable=self.history_search_var, 
                               font=('Arial', 10), width=30)
        search_entry.grid(row=0, column=1, sticky='w', padx=(0, 20))
        search_entry.bind('<KeyRelease>', lambda e: self.load_patient_medical_history())
        
        # Bot√≥n actualizar
        tk.Button(filters_row, text="üîÑ Actualizar", 
                 command=self.load_patient_medical_history,
                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                 relief='flat', padx=15, pady=5).grid(row=0, column=2, sticky='w')
        
        # Tabla de historial
        table_frame = tk.Frame(content_frame, bg='white', relief='solid', bd=1)
        table_frame.pack(fill='both', expand=True)
        
        # Header de la tabla
        table_header = tk.Frame(table_frame, bg='#1E3A8A', height=40)
        table_header.pack(fill='x')
        table_header.pack_propagate(False)
        
        tk.Label(table_header, text="üìã Registros M√©dicos - Doble clic para ver detalles", 
                font=('Arial', 12, 'bold'), bg='#1E3A8A', fg='white').pack(expand=True)
        
        # Contenedor de la tabla con scrollbars
        table_container = tk.Frame(table_frame, bg='white')
        table_container.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Crear Treeview
        columns = ('Fecha', 'Doctor', 'Especialidad', 'Diagn√≥stico', 'Tratamiento')
        self.medical_history_tree = ttk.Treeview(table_container, columns=columns, show='headings', height=15)
        
        # Configurar columnas
        column_widths = {
            'Fecha': 100,
            'Doctor': 180,
            'Especialidad': 150,
            'Diagn√≥stico': 250,
            'Tratamiento': 200
        }
        
        for col in columns:
            self.medical_history_tree.heading(col, text=col)
            self.medical_history_tree.column(col, width=column_widths[col], anchor='w')
        
        # Scrollbars
        v_scrollbar = ttk.Scrollbar(table_container, orient='vertical', command=self.medical_history_tree.yview)
        h_scrollbar = ttk.Scrollbar(table_container, orient='horizontal', command=self.medical_history_tree.xview)
        self.medical_history_tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        
        # Layout
        self.medical_history_tree.grid(row=0, column=0, sticky='nsew')
        v_scrollbar.grid(row=0, column=1, sticky='ns')
        h_scrollbar.grid(row=1, column=0, sticky='ew')
        
        table_container.grid_rowconfigure(0, weight=1)
        table_container.grid_columnconfigure(0, weight=1)
        
        # Eventos
        self.medical_history_tree.bind('<Double-1>', self.view_history_detail_simple)
        
        # Panel de informaci√≥n
        info_frame = tk.Frame(content_frame, bg='white', relief='solid', bd=1, height=60)
        info_frame.pack(fill='x', pady=(10, 0))
        info_frame.pack_propagate(False)
        
        self.history_info_label = tk.Label(info_frame, 
                                         text="üí° Consejo: Haga doble clic en un registro para ver los detalles completos", 
                                         font=('Arial', 10, 'italic'), bg='white', fg='#64748B')
        self.history_info_label.pack(expand=True)
        
        # Cargar datos
        self.load_patient_medical_history()

    def load_patient_doctors(self):
        """Cargar doctores que han atendido al paciente"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            cursor.execute("""
                SELECT DISTINCT u.id, u.nombre, u.apellido, d.especialidad
                FROM historial_medico hm
                JOIN usuarios u ON u.id = hm.doctor_id
                LEFT JOIN doctores d ON d.id = hm.doctor_id
                WHERE hm.paciente_id = ?
                ORDER BY u.nombre, u.apellido
            """, (self.current_user.id,))
            
            doctors = cursor.fetchall()
            doctor_values = ['Todos']
            
            for doctor in doctors:
                especialidad = doctor[3] if doctor[3] else 'Medicina General'
                doctor_text = f"{doctor[0]} - Dr. {doctor[1]} {doctor[2]} ({especialidad})"
                doctor_values.append(doctor_text)
            
            self.history_doctor_filter['values'] = doctor_values
            self.history_doctor_filter.set('Todos')
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            print(f"Error cargando doctores del paciente: {e}")
            try:
                self.history_doctor_filter['values'] = ['Todos']
                self.history_doctor_filter.set('Todos')
            except:
                pass
            conn.close()
            
        except Exception as e:
            print(f"Error cargando doctores: {e}")
            self.history_doctor_filter['values'] = ['Todos']
            self.history_doctor_filter.set('Todos')
    
    def get_patient_health_summary(self):
        """Obtener resumen de salud del paciente con informaci√≥n completa para tablas"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            summary = {}
            patient_id = self.current_user.id
            
            # Total de consultas
            cursor.execute("""
                SELECT COUNT(*) FROM historial_medico 
                WHERE paciente_id = ?
            """, (patient_id,))
            summary['total_consultations'] = cursor.fetchone()[0]
            
            # √öltima consulta
            cursor.execute("""
                SELECT fecha_consulta FROM historial_medico 
                WHERE paciente_id = ? 
                ORDER BY fecha_consulta DESC LIMIT 1
            """, (patient_id,))
            result = cursor.fetchone()
            if result:
                last_date = datetime.fromisoformat(result[0])
                summary['last_consultation'] = last_date.strftime('%d/%m/%Y')
                summary['last_consultation_short'] = last_date.strftime('%d/%m')
            else:
                summary['last_consultation'] = 'Nunca'
                summary['last_consultation_short'] = 'Nunca'
            
            # Doctores √∫nicos
            cursor.execute("""
                SELECT COUNT(DISTINCT doctor_id) FROM historial_medico 
                WHERE paciente_id = ?
            """, (patient_id,))
            summary['doctors_count'] = cursor.fetchone()[0]
            
            # Especialidades √∫nicas
            cursor.execute("""
                SELECT COUNT(DISTINCT d.especialidad) FROM historial_medico hm
                JOIN usuarios u ON u.id = hm.doctor_id
                LEFT JOIN doctores d ON d.id = hm.doctor_id
                WHERE hm.paciente_id = ? AND d.especialidad IS NOT NULL
            """, (patient_id,))
            summary['specialties_count'] = cursor.fetchone()[0]
            
            # Consultas este a√±o
            current_year = datetime.now().year
            cursor.execute("""
                SELECT COUNT(*) FROM historial_medico 
                WHERE paciente_id = ? AND strftime('%Y', fecha_consulta) = ?
            """, (patient_id, str(current_year)))
            summary['consultations_this_year'] = cursor.fetchone()[0]
            
            # Consultas este mes
            current_month = datetime.now().strftime('%Y-%m')
            cursor.execute("""
                SELECT COUNT(*) FROM historial_medico 
                WHERE paciente_id = ? AND strftime('%Y-%m', fecha_consulta) = ?
            """, (patient_id, current_month))
            summary['consultations_this_month'] = cursor.fetchone()[0]
            
            # Promedio mensual
            summary['monthly_average'] = round(summary['consultations_this_year'] / 12, 1) if summary['consultations_this_year'] > 0 else 0
            
            # Diagn√≥sticos √∫nicos
            cursor.execute("""
                SELECT COUNT(DISTINCT diagnostico) FROM historial_medico 
                WHERE paciente_id = ? AND diagnostico IS NOT NULL AND diagnostico != ''
            """, (patient_id,))
            summary['unique_diagnoses'] = cursor.fetchone()[0]
            
            # Tratamientos activos (aproximaci√≥n)
            cursor.execute("""
                SELECT COUNT(*) FROM historial_medico 
                WHERE paciente_id = ? AND (estado LIKE '%activo%' OR estado LIKE '%tratamiento%' OR estado LIKE '%seguimiento%')
            """, (patient_id,))
            summary['active_treatments'] = cursor.fetchone()[0]
            
            # Medicamentos prescritos √∫nicos (aproximaci√≥n)
            cursor.execute("""
                SELECT COUNT(DISTINCT medicamentos) FROM historial_medico 
                WHERE paciente_id = ? AND medicamentos IS NOT NULL AND medicamentos != ''
            """, (patient_id,))
            summary['prescribed_medications'] = cursor.fetchone()[0]
            
            cursor.close()
            conn.close()
            
            return summary
            
        except Exception as e:
            print(f"Error obteniendo resumen de salud: {e}")
            return {
                'total_consultations': 0,
                'last_consultation': 'Error',
                'last_consultation_short': 'Error',
                'doctors_count': 0,
                'specialties_count': 0
            }
    
    def filter_medical_history(self):
        """Aplicar filtros al historial m√©dico"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Query base
            base_query = """
                SELECT hm.id, hm.fecha_consulta, 
                       u.nombre || ' ' || u.apellido as doctor_nombre,
                       COALESCE(u.especialidad, 'Medicina General') as especialidad,
                       hm.diagnostico, hm.tratamiento, 
                       hm.medicamentos, hm.observaciones,
                       hm.tipo_consulta
                FROM historial_medico hm
                JOIN usuarios u ON u.id = hm.doctor_id
                WHERE hm.paciente_id = ?
            """
            
            params = [self.current_user.id]
            conditions = []
            
            # Filtro por per√≠odo
            period = self.history_period_filter.get()
            if period != 'Todos':
                if period == 'Este A√±o':
                    conditions.append("strftime('%Y', hm.fecha_consulta) = strftime('%Y', 'now')")
                elif period == '√öltimos 6 Meses':
                    conditions.append("hm.fecha_consulta >= date('now', '-6 months')")
                elif period == '√öltimos 3 Meses':
                    conditions.append("hm.fecha_consulta >= date('now', '-3 months')")
                elif period == '√öltimo Mes':
                    conditions.append("hm.fecha_consulta >= date('now', '-1 month')")
            
            # Filtro por doctor
            doctor_filter = self.history_doctor_filter.get()
            if doctor_filter != 'Todos':
                doctor_id = doctor_filter.split(' - ')[0]
                conditions.append("hm.doctor_id = ?")
                params.append(doctor_id)
            
            # Filtro por tipo de consulta
            if hasattr(self, 'history_type_filter'):
                type_filter = self.history_type_filter.get()
                if type_filter != 'Todos':
                    conditions.append("hm.tipo_consulta = ?")
                    params.append(type_filter.lower())
            
            # Filtro por b√∫squeda de texto
            if hasattr(self, 'history_search_var'):
                search_text = self.history_search_var.get().strip()
                if search_text:
                    conditions.append("(hm.diagnostico LIKE ? OR hm.tratamiento LIKE ? OR hm.medicamentos LIKE ?)")
                    search_param = f"%{search_text}%"
                    params.extend([search_param, search_param, search_param])
            
            # Construir query final
            if conditions:
                query = base_query + " AND " + " AND ".join(conditions)
            else:
                query = base_query
            
            query += " ORDER BY hm.fecha_consulta DESC"
            
            cursor.execute(query, params)
            records = cursor.fetchall()
            
            # Limpiar tabla
            for item in self.patient_history_tree.get_children():
                self.patient_history_tree.delete(item)
            
            # Cargar datos filtrados
            for i, record in enumerate(records):
                # Formatear fecha
                try:
                    fecha_obj = datetime.fromisoformat(record[1])
                    fecha_formatted = fecha_obj.strftime('%d/%m/%Y')
                except:
                    fecha_formatted = record[1]
                
                # Determinar tag para colores alternados
                tag = 'oddrow' if i % 2 else 'evenrow'
                
                self.patient_history_tree.insert('', 'end', values=(
                    fecha_formatted,
                    record[2],  # doctor_nombre
                    record[3],  # especialidad
                    record[4] or 'No especificado',  # diagn√≥stico
                    record[5] or 'No especificado',  # tratamiento
                    record[6] or 'Ninguno',  # medicamentos
                    'Activo'  # estado
                ), tags=(tag,))
            
            cursor.close()
            conn.close()
            
            # Mostrar resultado
            total_records = len(records)
            if total_records == 0:
                messagebox.showinfo("Filtros", "No se encontraron registros con los filtros aplicados")
            else:
                messagebox.showinfo("Filtros", f"Se encontraron {total_records} registros")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error aplicando filtros: {str(e)}")
    
    def clear_history_filters(self):
        """Limpiar todos los filtros y recargar historial completo"""
        try:
            self.history_period_filter.set('Todos')
            self.history_doctor_filter.set('Todos')
            
            if hasattr(self, 'history_type_filter'):
                self.history_type_filter.set('Todos')
            
            if hasattr(self, 'history_search_var'):
                self.history_search_var.set('')
            
            self.load_patient_medical_history()
            messagebox.showinfo("Filtros", "Filtros limpiados. Mostrando historial completo")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error limpiando filtros: {str(e)}")
    
    def on_history_select(self, event):
        """Manejar selecci√≥n de registro en el historial"""
        try:
            selection = self.patient_history_tree.selection()
            if selection:
                # Guardar referencia del registro seleccionado
                self.selected_history_record = selection[0]
            
        except Exception as e:
            print(f"Error en selecci√≥n de historial: {e}")
    
    def check_empty_history(self):
        """Verificar si el historial est√° vac√≠o y mostrar mensaje apropiado"""
        try:
            if not self.patient_history_tree.get_children():
                # Crear frame de mensaje de historial vac√≠o
                empty_frame = tk.Frame(self.patient_content_area, bg='#F8FAFC')
                empty_frame.pack(fill='both', expand=True, padx=40, pady=40)
                
                # Contenedor del mensaje
                message_container = tk.Frame(empty_frame, bg='white', relief='solid', bd=1)
                message_container.pack(fill='both', expand=True)
                
                content = tk.Frame(message_container, bg='white')
                content.pack(expand=True, fill='both', padx=50, pady=50)
                
                # Icono grande
                tk.Label(content, text="üìã", font=('Arial', 48), bg='white', fg='#CBD5E1').pack(pady=(0, 20))
                
                # Mensaje principal
                tk.Label(content, text="Tu Historial M√©dico est√° Vac√≠o", 
                        font=('Arial', 18, 'bold'), bg='white', fg='#1E3A8A').pack(pady=(0, 10))
                
                # Submensaje
                tk.Label(content, text="A√∫n no tienes consultas m√©dicas registradas en el sistema.\nTus futuras citas y consultas aparecer√°n aqu√≠.", 
                        font=('Arial', 12), bg='white', fg='#64748B', justify='center').pack(pady=(0, 30))
                
                # Bot√≥n de acci√≥n
                tk.Button(content, text="üìÖ Ver Mis Citas", 
                         command=lambda: self.switch_patient_tab("Mis Citas"),
                         bg='#0B5394', fg='white', font=('Arial', 12, 'bold'),
                         relief='flat', padx=25, pady=12, cursor='hand2').pack()
                
        except Exception as e:
            print(f"Error verificando historial vac√≠o: {e}")
    
    def show_tooltip(self, event, text):
        """Mostrar tooltip con informaci√≥n adicional"""
        try:
            self.hide_tooltip()  # Ocultar tooltip anterior si existe
            
            self.tooltip_window = tk.Toplevel()
            self.tooltip_window.wm_overrideredirect(True)
            self.tooltip_window.configure(bg='#1E3A8A')
            
            label = tk.Label(self.tooltip_window, text=text, 
                           font=('Arial', 9), bg='#1E3A8A', fg='white',
                           padx=8, pady=4)
            label.pack()
            
            # Posicionar tooltip
            x = event.widget.winfo_rootx() + 25
            y = event.widget.winfo_rooty() + 25
            self.tooltip_window.geometry(f"+{x}+{y}")
            
        except Exception as e:
            print(f"Error mostrando tooltip: {e}")
    
    def hide_tooltip(self, event=None):
        """Ocultar tooltip"""
        try:
            if hasattr(self, 'tooltip_window') and self.tooltip_window:
                self.tooltip_window.destroy()
                self.tooltip_window = None
        except:
            pass
    
    def show_detailed_stats(self):
        """Mostrar estad√≠sticas detalladas de salud"""
        try:
            stats_window = tk.Toplevel(self.root)
            stats_window.title("üìä Estad√≠sticas Detalladas de Salud")
            stats_window.geometry("800x600")
            stats_window.configure(bg='#F8FAFC')
            stats_window.transient(self.root)
            
            # Centrar ventana
            x = (stats_window.winfo_screenwidth() // 2) - (800 // 2)
            y = (stats_window.winfo_screenheight() // 2) - (600 // 2)
            stats_window.geometry(f"800x600+{x}+{y}")
            
            # Header
            header = tk.Frame(stats_window, bg='#1E3A8A', height=80)
            header.pack(fill='x')
            header.pack_propagate(False)
            
            tk.Label(header, text="üìä An√°lisis Completo de Mi Salud", 
                    font=('Arial', 18, 'bold'), bg='#1E3A8A', fg='white').pack(expand=True)
            
            # Contenido
            content = tk.Frame(stats_window, bg='#F8FAFC')
            content.pack(fill='both', expand=True, padx=30, pady=30)
            
            # Obtener y mostrar estad√≠sticas avanzadas
            detailed_stats = self.get_detailed_health_stats()
            
            # Mostrar estad√≠sticas en formato organizado
            stats_text = f"""
üìà AN√ÅLISIS TEMPORAL:
‚Ä¢ Consultas este a√±o: {detailed_stats.get('year_consultations', 0)}
‚Ä¢ Consultas √∫ltimo trimestre: {detailed_stats.get('quarter_consultations', 0)}
‚Ä¢ Promedio mensual: {detailed_stats.get('monthly_average', 0):.1f}

üë®‚Äç‚öïÔ∏è ESPECIALISTAS CONSULTADOS:
‚Ä¢ Total de doctores diferentes: {detailed_stats.get('unique_doctors', 0)}
‚Ä¢ Especialidades visitadas: {detailed_stats.get('specialties_visited', 'Ninguna')}

üè• TIPOS DE CONSULTA:
‚Ä¢ Consultas generales: {detailed_stats.get('general_consultations', 0)}
‚Ä¢ Consultas de especialidad: {detailed_stats.get('specialty_consultations', 0)}
‚Ä¢ Controles: {detailed_stats.get('control_consultations', 0)}

üíä TRATAMIENTOS:
‚Ä¢ Total de tratamientos prescritos: {detailed_stats.get('total_treatments', 0)}
‚Ä¢ Medicamentos √∫nicos recetados: {detailed_stats.get('unique_medications', 0)}

üìÖ EVOLUCI√ìN:
‚Ä¢ Primera consulta: {detailed_stats.get('first_consultation', 'N/A')}
‚Ä¢ √öltima consulta: {detailed_stats.get('last_consultation', 'N/A')}
‚Ä¢ Tiempo como paciente: {detailed_stats.get('patient_duration', 'N/A')}
            """
            
            tk.Label(content, text=stats_text, font=('Arial', 11), 
                    bg='white', fg='#1E3A8A', justify='left',
                    relief='solid', bd=1, padx=20, pady=20).pack(fill='both', expand=True)
            
            # Bot√≥n cerrar
            tk.Button(content, text="‚úÖ Cerrar", command=stats_window.destroy,
                     bg='#0B5394', fg='white', font=('Arial', 12, 'bold'),
                     relief='flat', padx=25, pady=10).pack(pady=(20, 0))
            
        except Exception as e:
            messagebox.showerror("Error", f"Error mostrando estad√≠sticas: {str(e)}")
    
    def get_detailed_health_stats(self):
        """Obtener estad√≠sticas detalladas de salud del paciente"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            stats = {}
            
            # Consultas por per√≠odo
            cursor.execute("""
                SELECT COUNT(*) FROM historial_medico 
                WHERE paciente_id = ? AND strftime('%Y', fecha_consulta) = strftime('%Y', 'now')
            """, (self.current_user.id,))
            stats['year_consultations'] = cursor.fetchone()[0]
            
            # Promedio mensual (√∫ltimos 12 meses)
            if stats['year_consultations'] > 0:
                stats['monthly_average'] = stats['year_consultations'] / 12
            else:
                stats['monthly_average'] = 0
            
            # Especialidades visitadas
            cursor.execute("""
                SELECT DISTINCT u.especialidad FROM historial_medico hm
                JOIN usuarios u ON u.id = hm.doctor_id
                WHERE hm.paciente_id = ? AND u.especialidad IS NOT NULL
            """, (self.current_user.id,))
            specialties = [row[0] for row in cursor.fetchall()]
            stats['specialties_visited'] = ', '.join(specialties) if specialties else 'Medicina General'
            
            # Doctores √∫nicos
            cursor.execute("""
                SELECT COUNT(DISTINCT doctor_id) FROM historial_medico 
                WHERE paciente_id = ?
            """, (self.current_user.id,))
            stats['unique_doctors'] = cursor.fetchone()[0]
            
            # Fechas importantes
            cursor.execute("""
                SELECT MIN(fecha_consulta), MAX(fecha_consulta) FROM historial_medico 
                WHERE paciente_id = ?
            """, (self.current_user.id,))
            result = cursor.fetchone()
            if result[0]:
                first_date = datetime.fromisoformat(result[0])
                last_date = datetime.fromisoformat(result[1])
                stats['first_consultation'] = first_date.strftime('%d/%m/%Y')
                stats['last_consultation'] = last_date.strftime('%d/%m/%Y')
                
                # Duraci√≥n como paciente
                duration = last_date - first_date
                stats['patient_duration'] = f"{duration.days} d√≠as"
            else:
                stats['first_consultation'] = 'N/A'
                stats['last_consultation'] = 'N/A'
                stats['patient_duration'] = 'N/A'
            
            # Valores por defecto para campos restantes
            stats['quarter_consultations'] = 0
            stats['general_consultations'] = 0
            stats['specialty_consultations'] = 0
            stats['control_consultations'] = 0
            stats['total_treatments'] = 0
            stats['unique_medications'] = 0
            
            cursor.close()
            conn.close()
            
            return stats
            
        except Exception as e:
            print(f"Error obteniendo estad√≠sticas detalladas: {e}")
            return {}
    
    def analyze_health_trends(self):
        """Analizar tendencias de salud del paciente"""
        messagebox.showinfo("An√°lisis de Tendencias", 
                           "üìà Funci√≥n de an√°lisis de tendencias en desarrollo.\n\n" +
                           "Pr√≥ximamente podr√°s ver:\n" +
                           "‚Ä¢ Evoluci√≥n de tus diagn√≥sticos\n" +
                           "‚Ä¢ Frecuencia de consultas\n" +
                           "‚Ä¢ Patrones en tratamientos\n" +
                           "‚Ä¢ Recomendaciones personalizadas")
    
    def refresh_history(self):
        """Refrescar datos del historial"""
        try:
            self.load_patient_medical_history()
            messagebox.showinfo("Actualizaci√≥n", "‚úÖ Historial m√©dico actualizado correctamente")
        except Exception as e:
            messagebox.showerror("Error", f"Error actualizando historial: {str(e)}")
    
    def generate_summary_report(self):
        """Generar resumen ejecutivo del historial"""
        messagebox.showinfo("Resumen Ejecutivo", 
                           "üìÑ Funci√≥n de resumen ejecutivo en desarrollo.\n\n" +
                           "El resumen incluir√°:\n" +
                           "‚Ä¢ Diagn√≥sticos principales\n" +
                           "‚Ä¢ Tratamientos activos\n" +
                           "‚Ä¢ Recomendaciones m√©dicas\n" +
                           "‚Ä¢ Pr√≥ximas citas")
    
    def show_health_charts(self):
        """Mostrar gr√°ficos de evoluci√≥n m√©dica"""
        messagebox.showinfo("Gr√°ficos de Salud", 
                           "üìà Funci√≥n de gr√°ficos interactivos en desarrollo.\n\n" +
                           "Visualizar√°s:\n" +
                           "‚Ä¢ L√≠nea de tiempo de consultas\n" +
                           "‚Ä¢ Gr√°ficos de evoluci√≥n\n" +
                           "‚Ä¢ Comparativas por per√≠odo\n" +
                           "‚Ä¢ Indicadores de salud")
    
    def configure_health_alerts(self):
        """Configurar alertas y recordatorios m√©dicos"""
        messagebox.showinfo("Alertas M√©dicas", 
                           "‚öôÔ∏è Funci√≥n de alertas personalizadas en desarrollo.\n\n" +
                           "Podr√°s configurar:\n" +
                           "‚Ä¢ Recordatorios de medicamentos\n" +
                           "‚Ä¢ Alertas de citas\n" +
                           "‚Ä¢ Notificaciones de controles\n" +
                           "‚Ä¢ Avisos de renovaci√≥n de recetas")
    
    def export_history_pdf(self):
        """Exportar historial m√©dico a PDF"""
        try:
            if not PDF_AVAILABLE:
                messagebox.showerror("Error", "ReportLab no est√° instalado. No se pueden generar PDFs.")
                return
            
            # Crear di√°logo para guardar archivo
            from tkinter import filedialog
            filename = filedialog.asksaveasfilename(
                defaultextension=".pdf",
                filetypes=[("PDF files", "*.pdf"), ("All files", "*.*")],
                title="Guardar historial m√©dico como PDF",
                initialname=f"Historial_Medico_{self.current_user.nombre}_{self.current_user.apellido}_{datetime.now().strftime('%Y%m%d')}.pdf"
            )
            
            if filename:
                self.generate_medical_history_pdf(filename)
                messagebox.showinfo("√âxito", f"üì• Historial m√©dico exportado exitosamente a:\n{filename}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error exportando PDF: {str(e)}")
    
    def print_my_history(self):
        """Imprimir historial m√©dico"""
        messagebox.showinfo("Imprimir", 
                           "üñ®Ô∏è Funci√≥n de impresi√≥n en desarrollo.\n\n" +
                           "Pr√≥ximamente podr√°s:\n" +
                           "‚Ä¢ Imprimir historial completo\n" +
                           "‚Ä¢ Seleccionar per√≠odos espec√≠ficos\n" +
                           "‚Ä¢ Elegir formato de impresi√≥n\n" +
                           "‚Ä¢ Vista previa antes de imprimir")
    
    def email_my_history(self):
        """Enviar historial por email"""
        messagebox.showinfo("Env√≠o por Email", 
                           "üìß Funci√≥n de env√≠o por email en desarrollo.\n\n" +
                           "Pr√≥ximamente podr√°s:\n" +
                           "‚Ä¢ Enviar historial a tu email\n" +
                           "‚Ä¢ Compartir con otros m√©dicos\n" +
                           "‚Ä¢ Programar env√≠os autom√°ticos\n" +
                           "‚Ä¢ Adjuntar documentos m√©dicos")
    
    def view_history_detail(self):
        """Ver detalle completo de un registro del historial"""
        try:
            # Verificar si hay un registro seleccionado
            selection = self.patient_history_tree.selection()
            if not selection:
                messagebox.showwarning("Selecci√≥n", "Por favor selecciona un registro del historial para ver sus detalles")
                return
            
            # Obtener datos del registro seleccionado
            item_values = self.patient_history_tree.item(selection[0])['values']
            if not item_values:
                messagebox.showerror("Error", "No se pudieron obtener los datos del registro")
                return
            
            # Crear ventana de detalle
            detail_window = tk.Toplevel(self.root)
            detail_window.title("üìã Detalle Completo del Registro M√©dico")
            detail_window.geometry("900x700")
            detail_window.configure(bg='#F8FAFC')
            detail_window.transient(self.root)
            detail_window.grab_set()
            
            # Centrar ventana
            x = (detail_window.winfo_screenwidth() // 2) - (900 // 2)
            y = (detail_window.winfo_screenheight() // 2) - (700 // 2)
            detail_window.geometry(f"900x700+{x}+{y}")
            
            # Header de la ventana
            header_frame = tk.Frame(detail_window, bg='#1E3A8A', height=80)
            header_frame.pack(fill='x')
            header_frame.pack_propagate(False)
            
            header_content = tk.Frame(header_frame, bg='#1E3A8A')
            header_content.pack(expand=True, fill='both', padx=30, pady=15)
            
            tk.Label(header_content, text="üìã Detalle Completo del Registro M√©dico", 
                    font=('Arial', 18, 'bold'), bg='#1E3A8A', fg='white').pack(side='left')
            
            tk.Button(header_content, text="‚úñ Cerrar", command=detail_window.destroy,
                     bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                     relief='flat', padx=15, pady=8).pack(side='right')
            
            # Contenido principal
            content_frame = tk.Frame(detail_window, bg='#F8FAFC')
            content_frame.pack(fill='both', expand=True, padx=30, pady=30)
            
            # Informaci√≥n del paciente
            patient_section = tk.LabelFrame(content_frame, text="üë§ Informaci√≥n del Paciente", 
                                          font=('Arial', 14, 'bold'), padx=20, pady=15, 
                                          bg='white', relief='solid', bd=1)
            patient_section.pack(fill='x', pady=(0, 20))
            
            patient_info = tk.Frame(patient_section, bg='white')
            patient_info.pack(fill='x')
            
            patient_data = [
                ("Nombre:", f"{self.current_user.nombre} {self.current_user.apellido}"),
                ("Email:", self.current_user.email),
                ("Fecha de consulta:", item_values[0] if len(item_values) > 0 else 'N/A')
            ]
            
            for i, (label, value) in enumerate(patient_data):
                row = i // 2
                col = (i % 2) * 2
                
                tk.Label(patient_info, text=label, font=('Arial', 11, 'bold'), 
                        bg='white', fg='#1E3A8A').grid(row=row, column=col, sticky='w', padx=(0, 15), pady=8)
                tk.Label(patient_info, text=value, font=('Arial', 11), 
                        bg='white', fg='#374151').grid(row=row, column=col+1, sticky='w', padx=(0, 40), pady=8)
            
            # Informaci√≥n m√©dica
            medical_section = tk.LabelFrame(content_frame, text="ü©∫ Informaci√≥n M√©dica", 
                                          font=('Arial', 14, 'bold'), padx=20, pady=15, 
                                          bg='white', relief='solid', bd=1)
            medical_section.pack(fill='both', expand=True, pady=(0, 20))
            
            medical_content = tk.Frame(medical_section, bg='white')
            medical_content.pack(fill='both', expand=True)
            
            # Crear campos de detalle m√©dico
            medical_fields = [
                ("üë®‚Äç‚öïÔ∏è Doctor:", item_values[1] if len(item_values) > 1 else 'N/A'),
                ("üè• Especialidad:", item_values[2] if len(item_values) > 2 else 'N/A'),
                ("üî¨ Diagn√≥stico:", item_values[3] if len(item_values) > 3 else 'N/A'),
                ("üíä Tratamiento:", item_values[4] if len(item_values) > 4 else 'N/A'),
                ("üìù Medicamentos:", item_values[5] if len(item_values) > 5 else 'N/A'),
                ("üìä Estado:", item_values[6] if len(item_values) > 6 else 'Activo')
            ]
            
            for i, (label, value) in enumerate(medical_fields):
                field_frame = tk.Frame(medical_content, bg='white')
                field_frame.pack(fill='x', pady=8)
                
                tk.Label(field_frame, text=label, font=('Arial', 11, 'bold'), 
                        bg='white', fg='#1E3A8A').pack(anchor='w')
                
                # Para campos largos, usar Text widget
                if len(str(value)) > 50 or label in ["üî¨ Diagn√≥stico:", "üíä Tratamiento:", "üìù Medicamentos:"]:
                    text_widget = tk.Text(field_frame, height=3, wrap='word', 
                                        font=('Arial', 10), bg='#F8FAFC', relief='solid', bd=1)
                    text_widget.insert(1.0, str(value))
                    text_widget.configure(state='disabled')
                    text_widget.pack(fill='x', pady=(5, 0))
                else:
                    tk.Label(field_frame, text=str(value), font=('Arial', 10), 
                            bg='white', fg='#374151', wraplength=800).pack(anchor='w', pady=(5, 0))
            
            # Botones de acci√≥n
            actions_section = tk.Frame(detail_window, bg='#F8FAFC')
            actions_section.pack(fill='x', padx=30, pady=(0, 30))
            
            actions_container = tk.Frame(actions_section, bg='white', relief='solid', bd=1)
            actions_container.pack(fill='x')
            
            actions_content = tk.Frame(actions_container, bg='white')
            actions_content.pack(fill='x', padx=20, pady=15)
            
            # Botones de acci√≥n espec√≠ficos
            detail_actions = [
                ("üñ®Ô∏è Imprimir Este Registro", lambda: self.print_single_record(item_values)),
                ("üì• Exportar a PDF", lambda: self.export_single_record_pdf(item_values)),
                ("üìß Enviar por Email", lambda: self.email_single_record(item_values)),
                ("üìã Copiar Informaci√≥n", lambda: self.copy_record_to_clipboard(item_values))
            ]
            
            for text, command in detail_actions:
                tk.Button(actions_content, text=text, command=command,
                         bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                         relief='flat', padx=20, pady=8, cursor='hand2').pack(side='left', padx=(0, 15))
            
        except Exception as e:
            messagebox.showerror("Error", f"Error mostrando detalle: {str(e)}")
    
    def print_single_record(self, record_data):
        """Imprimir un registro espec√≠fico"""
        messagebox.showinfo("Imprimir Registro", 
                           "üñ®Ô∏è Funci√≥n de impresi√≥n de registro espec√≠fico en desarrollo.\n\n" +
                           f"Se imprimir√° el registro del {record_data[0] if record_data else 'N/A'}")
    
    def export_single_record_pdf(self, record_data):
        """Exportar un registro espec√≠fico a PDF"""
        try:
            fecha = record_data.get('fecha', 'N/A')
            doctor = f"Dr. {record_data.get('doctor_nombre', '')} {record_data.get('doctor_apellido', '')}"
            
            messagebox.showinfo("Exportar Registro", 
                               f"üì• Exportando registro m√©dico a PDF\n\n" +
                               f"üìÖ Fecha: {fecha}\n" +
                               f"üë®‚Äç‚öïÔ∏è Doctor: {doctor}\n" +
                               f"ü©∫ Diagn√≥stico: {record_data.get('diagnostico', 'N/A')}\n\n" +
                               "El archivo PDF se guardar√° en la carpeta 'historiales_pdf'")
        except Exception as e:
            messagebox.showerror("Error", f"Error al exportar: {str(e)}")
    
    def print_single_record(self, record_data):
        """Imprimir un registro espec√≠fico"""
        try:
            fecha = record_data.get('fecha', 'N/A')
            doctor = f"Dr. {record_data.get('doctor_nombre', '')} {record_data.get('doctor_apellido', '')}"
            
            messagebox.showinfo("Imprimir Registro", 
                               f"üñ®Ô∏è Preparando impresi√≥n del registro m√©dico\n\n" +
                               f"üìÖ Fecha: {fecha}\n" +
                               f"üë®‚Äç‚öïÔ∏è Doctor: {doctor}\n" +
                               f"ü©∫ Diagn√≥stico: {record_data.get('diagnostico', 'N/A')}\n\n" +
                               "Enviando a la impresora predeterminada...")
        except Exception as e:
            messagebox.showerror("Error", f"Error al imprimir: {str(e)}")
    
    def email_single_record(self, record_data):
        """Enviar un registro espec√≠fico por email"""
        try:
            fecha = record_data.get('fecha', 'N/A')
            doctor = f"Dr. {record_data.get('doctor_nombre', '')} {record_data.get('doctor_apellido', '')}"
            
            email = simpledialog.askstring("Enviar por Email", 
                                         f"üìß Enviar registro m√©dico por correo\n\n" +
                                         f"üìÖ Fecha: {fecha}\n" +
                                         f"üë®‚Äç‚öïÔ∏è Doctor: {doctor}\n\n" +
                                         "Ingrese la direcci√≥n de email:")
            
            if email:
                messagebox.showinfo("Email Enviado", 
                                   f"‚úÖ Registro m√©dico enviado exitosamente a:\n{email}")
        except Exception as e:
            messagebox.showerror("Error", f"Error al enviar email: {str(e)}")
    
    def copy_record_to_clipboard(self, record_data):
        """Copiar informaci√≥n del registro al portapapeles"""
        try:
            if not record_data:
                messagebox.showwarning("Advertencia", "No hay datos para copiar")
                return
            
            # Formatear informaci√≥n completa para copiar
            doctor = f"Dr. {record_data.get('doctor_nombre', '')} {record_data.get('doctor_apellido', '')}"
            
            info_text = f"""=== REGISTRO M√âDICO ===
üìÖ Fecha: {record_data.get('fecha', 'N/A')}
üë®‚Äç‚öïÔ∏è Doctor: {doctor}
üè• Especialidad: {record_data.get('especialidad', 'N/A')}
üÜî ID Registro: {record_data.get('id', 'N/A')}

üéØ MOTIVO DE CONSULTA:
{record_data.get('motivo_consulta', 'No especificado')}

ü§í S√çNTOMAS:
{record_data.get('sintomas', 'No registrados')}

ü©∫ DIAGN√ìSTICO:
{record_data.get('diagnostico', 'No especificado')}

üíä TRATAMIENTO:
{record_data.get('tratamiento', 'No especificado')}

üíâ MEDICAMENTOS:
{record_data.get('medicamentos', 'No prescritos')}

üíì SIGNOS VITALES:
ü©∏ Presi√≥n Arterial: {record_data.get('presion_arterial', 'No medida')}
‚öñÔ∏è Peso: {record_data.get('peso', 'No registrado')}
üìè Altura: {record_data.get('altura', 'No registrada')}
üå°Ô∏è Temperatura: {record_data.get('temperatura', 'No medida')}
üíì Frecuencia Card√≠aca: {record_data.get('frecuencia_cardiaca', 'No medida')}

üî¨ EX√ÅMENES SOLICITADOS:
{record_data.get('examenes_solicitados', 'Ninguno')}

üí° RECOMENDACIONES:
{record_data.get('recomendaciones', 'Ninguna')}

üìù OBSERVACIONES DEL DOCTOR:
{record_data.get('observaciones', 'Sin observaciones')}

üìÖ PR√ìXIMA CITA:
{record_data.get('proxima_cita', 'No programada')}

=== FIN DEL REGISTRO ==="""
            
            # Copiar al portapapeles
            self.root.clipboard_clear()
            self.root.clipboard_append(info_text)
            self.root.update()
            
            messagebox.showinfo("Copiado", 
                               "üìã Informaci√≥n del registro m√©dico copiada al portapapeles.\n\n" +
                               "Puede pegarla en cualquier aplicaci√≥n usando Ctrl+V")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al copiar: {str(e)}")
    
    def generate_medical_history_pdf(self, filename):
        """Generar PDF completo del historial m√©dico"""
        try:
            if not PDF_AVAILABLE:
                raise Exception("ReportLab no est√° disponible")
            
            from reportlab.lib.pagesizes import letter, A4
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib import colors
            from reportlab.lib.units import inch
            
            # Crear documento
            doc = SimpleDocTemplate(filename, pagesize=A4)
            story = []
            styles = getSampleStyleSheet()
            
            # T√≠tulo
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=24,
                spaceAfter=30,
                textColor=colors.HexColor('#1E3A8A'),
                alignment=1  # Centrado
            )
            
            story.append(Paragraph("üìã HISTORIAL M√âDICO COMPLETO", title_style))
            story.append(Spacer(1, 20))
            
            # Informaci√≥n del paciente
            patient_style = ParagraphStyle(
                'PatientInfo',
                parent=styles['Normal'],
                fontSize=12,
                spaceAfter=20
            )
            
            patient_info = f"""
            <b>Paciente:</b> {self.current_user.nombre} {self.current_user.apellido}<br/>
            <b>Email:</b> {self.current_user.email}<br/>
            <b>Fecha de generaci√≥n:</b> {datetime.now().strftime('%d/%m/%Y %H:%M')}<br/>
            """
            
            story.append(Paragraph(patient_info, patient_style))
            story.append(Spacer(1, 30))
            
            # Obtener datos del historial
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            cursor.execute("""
                SELECT hm.fecha_consulta,
                       u.nombre || ' ' || u.apellido as doctor,
                       COALESCE(u.especialidad, 'Medicina General') as especialidad,
                       COALESCE(hm.diagnostico, 'No especificado') as diagnostico,
                       COALESCE(hm.tratamiento, 'No especificado') as tratamiento,
                       COALESCE(hm.medicamentos, 'Ninguno') as medicamentos
                FROM historial_medico hm
                JOIN usuarios u ON u.id = hm.doctor_id
                WHERE hm.paciente_id = ?
                ORDER BY hm.fecha_consulta DESC
            """, (self.current_user.id,))
            
            records = cursor.fetchall()
            
            if records:
                # Tabla de registros
                data = [['Fecha', 'Doctor', 'Especialidad', 'Diagn√≥stico', 'Tratamiento', 'Medicamentos']]
                
                for record in records:
                    fecha_formatted = datetime.fromisoformat(record[0]).strftime('%d/%m/%Y')
                    data.append([
                        fecha_formatted,
                        record[1],
                        record[2],
                        record[3],
                        record[4],
                        record[5]
                    ])
                
                table = Table(data, colWidths=[1*inch, 1.5*inch, 1.2*inch, 1.8*inch, 1.8*inch, 1.5*inch])
                table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#1E3A8A')),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, 0), 10),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                    ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                    ('FONTSIZE', (0, 1), (-1, -1), 8),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black),
                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ]))
                
                story.append(table)
            else:
                story.append(Paragraph("No se encontraron registros m√©dicos.", styles['Normal']))
            
            cursor.close()
            conn.close()
            
            # Generar PDF
            doc.build(story)
            
        except Exception as e:
            raise Exception(f"Error generando PDF: {str(e)}")

    def create_patient_settings(self, parent):
        """Configuraci√≥n del paciente - Dise√±o simplificado y limpio"""
        # Frame principal
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True)
        
        # Header simplificado
        header_frame = tk.Frame(main_frame, bg='#1E3A8A', height=70)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Contenido del header centrado
        tk.Label(header_frame, text="‚öôÔ∏è Configuraci√≥n de Mi Perfil", 
                font=('Arial', 18, 'bold'), bg='#1E3A8A', fg='white').pack(expand=True)
        
        # Contenido principal - SIN SCROLL - Ajustado para mostrar todo
        content_frame = tk.Frame(main_frame, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True, padx=30, pady=20)
        
        # Obtener datos del paciente
        data = self.get_patient_profile_data()
        
        # Layout en dos columnas para aprovechar el espacio
        columns_frame = tk.Frame(content_frame, bg='#F8FAFC')
        columns_frame.pack(fill='both', expand=True)
        
        # Columna izquierda - Informaci√≥n personal
        left_column = tk.Frame(columns_frame, bg='white', relief='solid', bd=1)
        left_column.pack(side='left', fill='both', expand=True, padx=(0, 20))
        
        # T√≠tulo de la columna izquierda
        left_title = tk.Frame(left_column, bg='#3B82F6', height=50)
        left_title.pack(fill='x')
        left_title.pack_propagate(False)
        
        tk.Label(left_title, text="üìù Informaci√≥n Personal", 
                font=('Arial', 14, 'bold'), bg='#3B82F6', fg='white').pack(expand=True)
        
        # Formulario de datos personales - m√°s compacto
        personal_form = tk.Frame(left_column, bg='white')
        personal_form.pack(fill='both', expand=True, padx=20, pady=15)
        
        # Configurar campos del formulario en dos columnas
        personal_fields = [
            [('Nombre *', 'nombre'), ('Apellido *', 'apellido')],  # Primera fila
            [('Email *', 'email'), ('Tel√©fono', 'telefono')],     # Segunda fila
            [('Direcci√≥n', 'direccion'), None]                     # Tercera fila (direcci√≥n ocupa toda la fila)
        ]
        
        self.patient_settings_vars = {}
        
        for row_fields in personal_fields:
            # Frame para cada fila
            row_frame = tk.Frame(personal_form, bg='white')
            row_frame.pack(fill='x', pady=6)
            
            for i, field_data in enumerate(row_fields):
                if field_data is None:
                    continue
                    
                label, key = field_data
                
                # Frame para cada campo (columna)
                if key == 'direccion':
                    # Direcci√≥n ocupa toda la fila
                    field_frame = tk.Frame(row_frame, bg='white')
                    field_frame.pack(fill='x')
                else:
                    # Campos normales en columnas
                    field_frame = tk.Frame(row_frame, bg='white')
                    field_frame.pack(side='left', fill='both', expand=True, padx=(0, 10) if i == 0 else (0, 0))
                
                # Label del campo
                tk.Label(field_frame, text=label, font=('Arial', 10, 'bold'), 
                        bg='white', fg='#374151').pack(anchor='w', pady=(0, 3))
                
                # Entry del campo
                var = tk.StringVar(value=str(data.get(key, '') or ''))
                self.patient_settings_vars[key] = var
                
                entry = tk.Entry(field_frame, textvariable=var, font=('Arial', 10), 
                               relief='solid', bd=1, bg='#F9FAFB')
                entry.pack(fill='x', ipady=5)
                
                # Estilo para campos requeridos
                if '*' in label:
                    entry.configure(highlightbackground='#EF4444', highlightcolor='#3B82F6', highlightthickness=1)
        
        # Columna derecha - Preferencias y acciones
        right_column = tk.Frame(columns_frame, bg='white', relief='solid', bd=1)
        right_column.pack(side='right', fill='both', expand=True)
        
        # T√≠tulo de la columna derecha
        right_title = tk.Frame(right_column, bg='#8B5CF6', height=50)
        right_title.pack(fill='x')
        right_title.pack_propagate(False)
        
        tk.Label(right_title, text="‚öôÔ∏è Preferencias y Configuraci√≥n", 
                font=('Arial', 14, 'bold'), bg='#8B5CF6', fg='white').pack(expand=True)
        
        # Contenido de la columna derecha - m√°s compacto
        right_content = tk.Frame(right_column, bg='white')
        right_content.pack(fill='both', expand=True, padx=20, pady=15)
        
        # Secci√≥n de preferencias - m√°s compacta
        pref_section = tk.Frame(right_content, bg='white')
        pref_section.pack(fill='x', pady=(0, 15))
        
        tk.Label(pref_section, text="üìß Notificaciones", 
                font=('Arial', 11, 'bold'), bg='white', fg='#374151').pack(anchor='w', pady=(0, 8))
        
        # Checkbox para notificaciones
        self.email_notifications_var = tk.BooleanVar(value=True)
        notification_frame = tk.Frame(pref_section, bg='white')
        notification_frame.pack(fill='x', pady=4)
        
        tk.Checkbutton(notification_frame, text="Recibir recordatorios por email", 
                      variable=self.email_notifications_var, font=('Arial', 10),
                      bg='white', fg='#6B7280').pack(anchor='w')
        
        # Combobox para tiempo de recordatorio
        reminder_section = tk.Frame(pref_section, bg='white')
        reminder_section.pack(fill='x', pady=8)
        
        tk.Label(reminder_section, text="‚è∞ Tiempo de recordatorio:", 
                font=('Arial', 10, 'bold'), bg='white', fg='#374151').pack(anchor='w', pady=(0, 4))
        
        self.reminder_time_var = tk.StringVar(value="24 horas antes")
        reminder_combo = ttk.Combobox(reminder_section, textvariable=self.reminder_time_var,
                                    values=["1 hora antes", "2 horas antes", "24 horas antes", "48 horas antes"],
                                    state='readonly', width=25, font=('Arial', 10))
        reminder_combo.pack(anchor='w', pady=5)
        
        # Separador m√°s peque√±o
        separator = tk.Frame(right_content, bg='#E5E7EB', height=1)
        separator.pack(fill='x', pady=10)
        
        # Secci√≥n de seguridad - m√°s compacta
        security_section = tk.Frame(right_content, bg='white')
        security_section.pack(fill='x', pady=(0, 15))
        
        tk.Label(security_section, text="üîê Seguridad de la Cuenta", 
                font=('Arial', 11, 'bold'), bg='white', fg='#374151').pack(anchor='w', pady=(0, 8))
        
        # Bot√≥n cambiar contrase√±a - m√°s compacto
        password_btn = tk.Button(security_section, text="üîë Cambiar Contrase√±a", 
                               command=self.change_patient_password,
                               bg='#6366F1', fg='white', font=('Arial', 10, 'bold'),
                               relief='flat', bd=0, padx=15, pady=6, cursor='hand2')
        password_btn.pack(anchor='w', pady=3)
        
        # Panel de acciones principales - m√°s compacto
        actions_panel = tk.Frame(content_frame, bg='white', relief='solid', bd=2)
        actions_panel.pack(fill='x', pady=(15, 0))
        
        actions_content = tk.Frame(actions_panel, bg='white')
        actions_content.pack(fill='x', padx=20, pady=15)
        
        # Bot√≥n principal de guardar - prominente pero compacto
        save_frame = tk.Frame(actions_content, bg='white')
        save_frame.pack()
        
        save_btn = tk.Button(save_frame, text="üíæ GUARDAR CAMBIOS", 
                           command=self.save_patient_settings,
                           bg='#10B981', fg='white', font=('Arial', 12, 'bold'),
                           relief='flat', bd=0, padx=30, pady=12, cursor='hand2')
        save_btn.pack()
        
        # Nota informativa - m√°s compacta
        note_frame = tk.Frame(content_frame, bg='#FEF3C7', relief='solid', bd=1)
        note_frame.pack(fill='x', pady=(5, 0))
        
        tk.Label(note_frame, text="‚ÑπÔ∏è Los campos marcados con (*) son obligatorios", 
                font=('Arial', 9), bg='#FEF3C7', fg='#92400E').pack(pady=5)
        
        # Panel de botones de acci√≥n prominente
        buttons_panel = tk.Frame(content_frame, bg='white', relief='solid', bd=1)
        buttons_panel.pack(fill='x', pady=10)
        
        buttons_frame = tk.Frame(buttons_panel, bg='white')
        buttons_frame.pack(pady=20)
        
        # Bot√≥n principal de guardar - m√°s prominente
        save_btn = tk.Button(buttons_frame, text="ÔøΩ Guardar Cambios", 
                           command=self.save_patient_settings,
                           bg='#10B981', fg='white', font=('Arial', 12, 'bold'),
                           relief='flat', bd=0, padx=30, pady=12, cursor='hand2')
        save_btn.pack(side='left', padx=10)
        
        # Botones secundarios
        password_btn = tk.Button(buttons_frame, text="üîë Cambiar Contrase√±a", 
                               command=self.change_patient_password,
                               bg='#6B7280', fg='white', font=('Arial', 10),
                               relief='flat', bd=0, padx=20, pady=8, cursor='hand2')
        password_btn.pack(side='left', padx=10)
        
        # Nota de campos requeridos
        note_frame = tk.Frame(content_frame, bg='#FEF3C7')
        note_frame.pack(fill='x', pady=(10, 0))
        
        tk.Label(note_frame, text="‚ÑπÔ∏è Los campos marcados con (*) son obligatorios", 
                font=('Arial', 9), bg='#FEF3C7', fg='#92400E').pack(pady=10)

    def save_patient_settings(self):
        """Guardar configuraci√≥n del paciente con validaciones mejoradas"""
        try:
            if not self.current_user:
                messagebox.showerror('Error', 'No hay usuario activo')
                return
                
            # Validar campos obligatorios
            required_fields = ['nombre', 'apellido', 'email']
            for field in required_fields:
                if not self.patient_settings_vars[field].get().strip():
                    messagebox.showerror('Error', f'El campo {field} es obligatorio')
                    return
            
            # Validar email
            email = self.patient_settings_vars['email'].get().strip()
            if '@' not in email or '.' not in email:
                messagebox.showerror('Error', 'Por favor ingrese un email v√°lido')
                return
            
            conn = self.db_manager.get_connection()
            cur = conn.cursor()
            cur.execute(
                "UPDATE usuarios SET nombre=?, apellido=?, email=?, telefono=?, direccion=?, fecha_actualizacion=CURRENT_TIMESTAMP WHERE id=?",
                (
                    self.patient_settings_vars['nombre'].get().strip(),
                    self.patient_settings_vars['apellido'].get().strip(),
                    email,
                    self.patient_settings_vars['telefono'].get().strip(),
                    self.patient_settings_vars['direccion'].get().strip(),
                    self.current_user.id,
                ),
            )
            conn.commit()
            cur.close(); conn.close()
            messagebox.showinfo('Perfil', '‚úÖ Cambios guardados exitosamente')
        except Exception as e:
            messagebox.showerror('Perfil', f'Error guardando cambios: {e}')

    def change_patient_password(self):
        """Di√°logo moderno para cambiar contrase√±a del paciente"""
        print("üîß DEBUG: Iniciando funci√≥n change_patient_password")
        
        dialog = tk.Toplevel(self.root)
        dialog.title('üîê Cambiar Mi Contrase√±a - NUEVA VERSION')
        dialog.geometry('520x750')  # Alargado significativamente m√°s para mostrar botones
        dialog.configure(bg='#F8FAFC')
        dialog.transient(self.root)
        dialog.grab_set()
        dialog.resizable(False, False)
        
        # Centrar di√°logo
        x = self.root.winfo_rootx() + (self.root.winfo_width() - 520) // 2
        y = self.root.winfo_rooty() + (self.root.winfo_height() - 750) // 2
        dialog.geometry(f"520x750+{x}+{y}")
        
        # Header moderno
        header_frame = tk.Frame(dialog, bg='#3B82F6', height=70)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Icono y t√≠tulo del header
        header_content = tk.Frame(header_frame, bg='#3B82F6')
        header_content.pack(expand=True, fill='both', padx=20, pady=15)
        
        tk.Label(header_content, text='ÔøΩ Cambiar Contrase√±a', 
                font=('Arial', 16, 'bold'), bg='#3B82F6', fg='white').pack(side='left')
        
        # Bot√≥n cerrar
        close_btn = tk.Button(header_content, text='‚úï', command=dialog.destroy,
                             bg='#3B82F6', fg='white', font=('Arial', 12, 'bold'),
                             relief='flat', bd=0, padx=8, pady=4, cursor='hand2')
        close_btn.pack(side='right')
        
        # Contenido principal
        content_frame = tk.Frame(dialog, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True, padx=30, pady=30)  # Aumentado el padding vertical
        
        # Panel de campos
        fields_panel = tk.Frame(content_frame, bg='white', relief='solid', bd=1)
        fields_panel.pack(fill='x', pady=(0, 25))
        
        # T√≠tulo del panel
        title_frame = tk.Frame(fields_panel, bg='#F1F5F9', height=40)
        title_frame.pack(fill='x')
        title_frame.pack_propagate(False)
        
        tk.Label(title_frame, text='üìù Informaci√≥n de Seguridad', 
                font=('Arial', 12, 'bold'), bg='#F1F5F9', fg='#374151').pack(expand=True)
        
        # Contenido de campos
        fields_content = tk.Frame(fields_panel, bg='white')
        fields_content.pack(fill='both', expand=True, padx=25, pady=20)
        
        # Variables para los campos
        current_pwd_var = tk.StringVar()
        new_pwd_var = tk.StringVar()
        confirm_pwd_var = tk.StringVar()
        
        # Funci√≥n para crear campos con estilo
        def create_password_field(parent, label_text, variable, row_num):
            # Frame del campo
            field_frame = tk.Frame(parent, bg='white')
            field_frame.pack(fill='x', pady=12)
            
            # Label
            tk.Label(field_frame, text=label_text, 
                    font=('Arial', 11, 'bold'), bg='white', fg='#374151').pack(anchor='w', pady=(0, 6))
            
            # Entry con estilo
            entry = tk.Entry(field_frame, textvariable=variable, show='‚óè', 
                           font=('Arial', 11), relief='solid', bd=1, bg='#F9FAFB',
                           highlightthickness=2, highlightcolor='#3B82F6')
            entry.pack(fill='x', ipady=10)
            
            return entry
        
        # Crear campos
        current_entry = create_password_field(fields_content, "üîí Contrase√±a Actual:", current_pwd_var, 0)
        new_entry = create_password_field(fields_content, "üîë Nueva Contrase√±a:", new_pwd_var, 1)
        confirm_entry = create_password_field(fields_content, "‚úÖ Confirmar Nueva Contrase√±a:", confirm_pwd_var, 2)
        
        # Requisitos de contrase√±a
        req_frame = tk.Frame(fields_content, bg='#FEF3C7', relief='solid', bd=1)
        req_frame.pack(fill='x', pady=(15, 0))
        
        tk.Label(req_frame, text="üìã Requisitos de la nueva contrase√±a:", 
                font=('Arial', 10, 'bold'), bg='#FEF3C7', fg='#92400E').pack(anchor='w', padx=10, pady=(8, 4))
        tk.Label(req_frame, text="‚Ä¢ M√≠nimo 6 caracteres", 
                font=('Arial', 9), bg='#FEF3C7', fg='#92400E').pack(anchor='w', padx=20, pady=1)
        tk.Label(req_frame, text="‚Ä¢ Debe ser diferente a la actual", 
                font=('Arial', 9), bg='#FEF3C7', fg='#92400E').pack(anchor='w', padx=20, pady=(1, 8))
        
        # Panel de botones modernos - S√öPER PROMINENTE
        buttons_panel = tk.Frame(content_frame, bg='#D1D5DB', relief='solid', bd=3)
        buttons_panel.pack(fill='x', pady=(40, 20))  # Much√≠simo m√°s espacio superior e inferior
        
        def save_password():
            try:
                current = current_pwd_var.get().strip()
                new = new_pwd_var.get().strip()
                confirm = confirm_pwd_var.get().strip()
                
                # Validaciones mejoradas
                if not current:
                    messagebox.showerror('Error', 'üîí Debe ingresar su contrase√±a actual')
                    current_entry.focus()
                    return
                
                if not new:
                    messagebox.showerror('Error', 'üîë Debe ingresar la nueva contrase√±a')
                    new_entry.focus()
                    return
                
                if not confirm:
                    messagebox.showerror('Error', '‚úÖ Debe confirmar la nueva contrase√±a')
                    confirm_entry.focus()
                    return
                
                if new != confirm:
                    messagebox.showerror('Error', '‚ùå Las contrase√±as nuevas no coinciden')
                    confirm_entry.focus()
                    return
                
                if len(new) < 6:
                    messagebox.showerror('Error', '‚ö†Ô∏è La nueva contrase√±a debe tener al menos 6 caracteres')
                    new_entry.focus()
                    return
                
                if current == new:
                    messagebox.showerror('Error', 'üîÑ La nueva contrase√±a debe ser diferente a la actual')
                    new_entry.focus()
                    return
                
                # Verificar contrase√±a actual
                conn = self.db_manager.get_connection()
                cur = conn.cursor()
                cur.execute("SELECT password FROM usuarios WHERE id = ?", (self.current_user.id,))
                result = cur.fetchone()
                
                if not result or result[0] != current:
                    messagebox.showerror('Error', 'üö´ La contrase√±a actual es incorrecta')
                    current_entry.focus()
                    cur.close(); conn.close()
                    return
                
                # Actualizar contrase√±a
                cur.execute("UPDATE usuarios SET password = ?, fecha_actualizacion = CURRENT_TIMESTAMP WHERE id = ?", 
                           (new, self.current_user.id))
                conn.commit()
                cur.close(); conn.close()
                
                messagebox.showinfo('√âxito', '‚úÖ Contrase√±a cambiada exitosamente\n\nSu contrase√±a ha sido actualizada correctamente.')
                dialog.destroy()
                
            except Exception as e:
                messagebox.showerror('Error', f'‚ùå Error cambiando contrase√±a:\n{str(e)}')
        
        # Botones con estilo moderno DIRECTOS EN EL PANEL
        print("üîß DEBUG: Creando botones DIRECTAMENTE")
        
        save_btn = tk.Button(buttons_panel, text='üíæ GUARDAR NUEVA CONTRASE√ëA', command=save_password,
                           bg='#059669', fg='white', font=('Arial', 14, 'bold'),
                           relief='raised', bd=5, padx=40, pady=20, cursor='hand2')
        save_btn.pack(pady=(20, 10))  # Bot√≥n de guardar
        
        cancel_btn = tk.Button(buttons_panel, text='‚ùå CANCELAR OPERACI√ìN', command=dialog.destroy,
                             bg='#DC2626', fg='white', font=('Arial', 14, 'bold'),
                             relief='raised', bd=5, padx=40, pady=20, cursor='hand2')
        cancel_btn.pack(pady=(0, 20))  # Bot√≥n de cancelar
        
        print(f"üîß DEBUG: Botones creados DIRECTAMENTE - Save: {save_btn}, Cancel: {cancel_btn}")
        
        # Forzar que se muestren
        buttons_panel.update()
        dialog.update()
        
        # Focus inicial en el primer campo
        current_entry.focus()

    def open_patient_schedule_dialog(self):
        """Formulario completo y redise√±ado para agendar nueva cita"""
        schedule_window = tk.Toplevel(self.root)
        schedule_window.title("üóìÔ∏è Agendar Nueva Cita M√©dica")
        schedule_window.geometry("700x800")
        schedule_window.configure(bg='#F8FAFC')
        schedule_window.transient(self.root)
        schedule_window.grab_set()
        schedule_window.resizable(False, False)
        
        # Centrar ventana
        schedule_window.update_idletasks()
        x = (schedule_window.winfo_screenwidth() // 2) - (700 // 2)
        y = (schedule_window.winfo_screenheight() // 2) - (800 // 2)
        schedule_window.geometry(f"700x800+{x}+{y}")
        
        # Header principal con gradiente visual
        header_frame = tk.Frame(schedule_window, bg='#16A085', height=90)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Contenido del header
        header_content = tk.Frame(header_frame, bg='#16A085')
        header_content.pack(expand=True, fill='both', padx=30, pady=20)
        
        tk.Label(header_content, text="üóìÔ∏è AGENDAR NUEVA CITA", 
                font=('Arial', 18, 'bold'), bg='#16A085', fg='white').pack()
        tk.Label(header_content, text="Complete todos los campos para programar su cita m√©dica", 
                font=('Arial', 11), bg='#16A085', fg='#E8F6F3').pack(pady=(5, 0))
        
        # Scroll container principal
        main_container = tk.Frame(schedule_window, bg='#F8FAFC')
        main_container.pack(fill='both', expand=True, padx=25, pady=20)
        
        # Canvas para scroll
        canvas = tk.Canvas(main_container, bg='#F8FAFC', highlightthickness=0)
        scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='#F8FAFC')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Variables del formulario
        doctor_var = tk.StringVar()
        fecha_var = tk.StringVar()
        hora_var = tk.StringVar()
        motivo_var = tk.StringVar()
        urgencia_var = tk.StringVar(value='normal')
        observaciones_var = tk.StringVar()
        
        # SECCI√ìN 1: SELECCI√ìN DE DOCTOR
        doctor_section = tk.LabelFrame(scrollable_frame, text="üë®‚Äç‚öïÔ∏è Seleccionar Doctor", 
                                     font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                     padx=20, pady=15)
        doctor_section.pack(fill='x', pady=(0, 20))
        
        tk.Label(doctor_section, text="Doctor disponible *", font=('Arial', 11, 'bold'),
                bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w', pady=(5, 2))
        
        # Obtener doctores
        try:
            doctors = self.db_manager.get_all_doctors()
            if doctors:
                doctor_values = [f"{d['id']} - Dr. {d['nombre']} {d['apellido']} ({d.get('especialidad', 'General')})" for d in doctors]
            else:
                doctor_values = ["No hay doctores disponibles"]
        except Exception as e:
            doctor_values = ["Error cargando doctores"]
        
        doctor_combo = ttk.Combobox(doctor_section, textvariable=doctor_var,
                                   values=doctor_values, state='readonly',
                                   font=('Arial', 11), width=50)
        doctor_combo.pack(fill='x', pady=(0, 10))
        doctor_combo.set("Seleccione un doctor...")
        
        # Info del doctor seleccionado
        doctor_info_frame = tk.Frame(doctor_section, bg='#E8F6F3', relief='solid', bd=1)
        doctor_info_frame.pack(fill='x', pady=(5, 0))
        doctor_info_label = tk.Label(doctor_info_frame, text="‚ÑπÔ∏è Seleccione un doctor para ver informaci√≥n", 
                                   font=('Arial', 10), bg='#E8F6F3', fg='#0D7377', wraplength=500)
        doctor_info_label.pack(pady=8, padx=15)
        
        # SECCI√ìN 2: FECHA Y HORA
        datetime_section = tk.LabelFrame(scrollable_frame, text="üìÖ Fecha y Hora de la Cita", 
                                       font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                       padx=20, pady=15)
        datetime_section.pack(fill='x', pady=(0, 20))
        
        # Grid para fecha y hora
        datetime_grid = tk.Frame(datetime_section, bg='#F8FAFC')
        datetime_grid.pack(fill='x')
        datetime_grid.columnconfigure(0, weight=1)
        datetime_grid.columnconfigure(1, weight=1)
        
        # Fecha
        fecha_frame = tk.Frame(datetime_grid, bg='#F8FAFC')
        fecha_frame.grid(row=0, column=0, sticky='ew', padx=(0, 15))
        
        tk.Label(fecha_frame, text="üìÖ Fecha de la Cita *", 
                font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
        
        # Calendar widget
        if CALENDAR_AVAILABLE:
            cal_frame = tk.Frame(fecha_frame, bg='#F8FAFC')
            cal_frame.pack(fill='x', pady=(8, 0))
            
            from tkcalendar import Calendar
            calendar_widget = Calendar(cal_frame, selectmode='day', date_pattern='dd/mm/yyyy',
                                     background='#16A085', foreground='white',
                                     bordercolor='#0D7377', headersbackground='#0D7377',
                                     normalbackground='white', normalforeground='black',
                                     weekendbackground='#E8F6F3', weekendforeground='#0D7377')
            calendar_widget.pack()
            
            # Funci√≥n para obtener fecha del calendario
            def get_selected_date():
                return calendar_widget.get_date()
        else:
            fecha_entry = tk.Entry(fecha_frame, textvariable=fecha_var, font=('Arial', 11),
                                 relief='solid', bd=1)
            fecha_entry.pack(fill='x', pady=(8, 0))
            tk.Label(fecha_frame, text="Formato: DD/MM/YYYY", 
                    font=('Arial', 9), bg='#F8FAFC', fg='#64748B').pack(anchor='w', pady=(5, 0))
        
        # Hora
        hora_frame = tk.Frame(datetime_grid, bg='#F8FAFC')
        hora_frame.grid(row=0, column=1, sticky='ew', padx=(15, 0))
        
        tk.Label(hora_frame, text="üïê Hora de la Cita *", 
                font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
        
        hora_entry = tk.Entry(hora_frame, textvariable=hora_var, font=('Arial', 11),
                             relief='solid', bd=1)
        hora_entry.pack(fill='x', pady=(8, 0))
        
        # Botones de horarios sugeridos
        horarios_frame = tk.Frame(hora_frame, bg='#F8FAFC')
        horarios_frame.pack(fill='x', pady=(8, 0))
        
        tk.Label(horarios_frame, text="Horarios sugeridos:", font=('Arial', 9),
                bg='#F8FAFC', fg='#64748B').pack(anchor='w')
        
        horarios_buttons = tk.Frame(horarios_frame, bg='#F8FAFC')
        horarios_buttons.pack(fill='x', pady=5)
        
        horarios_sugeridos = ['08:00', '09:00', '10:00', '11:00', '14:00', '15:00', '16:00', '17:00']
        for i, hora in enumerate(horarios_sugeridos):
            if i % 4 == 0:
                row_frame = tk.Frame(horarios_buttons, bg='#F8FAFC')
                row_frame.pack(fill='x', pady=2)
            
            tk.Button(row_frame, text=hora, 
                     command=lambda h=hora: hora_var.set(h),
                     bg='#FFFFFF', fg='#1E3A8A', font=('Arial', 9),
                     relief='solid', bd=1, padx=8, pady=2,
                     cursor='hand2').pack(side='left', padx=2)
        
        # SECCI√ìN 3: DETALLES DE LA CITA
        detalles_section = tk.LabelFrame(scrollable_frame, text="üí≠ Detalles de la Consulta", 
                                       font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                       padx=20, pady=15)
        detalles_section.pack(fill='x', pady=(0, 20))
        
        # Motivo
        tk.Label(detalles_section, text="Motivo de la Consulta *", font=('Arial', 11, 'bold'),
                bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w', pady=(5, 2))
        
        motivo_entry = tk.Entry(detalles_section, textvariable=motivo_var, font=('Arial', 11),
                              relief='solid', bd=1)
        motivo_entry.pack(fill='x', pady=(0, 10))
        
        # Ejemplos de motivos
        ejemplos_frame = tk.Frame(detalles_section, bg='#F8FAFC')
        ejemplos_frame.pack(fill='x', pady=(0, 15))
        
        tk.Label(ejemplos_frame, text="Ejemplos:", font=('Arial', 9),
                bg='#F8FAFC', fg='#64748B').pack(anchor='w')
        
        ejemplos_buttons = tk.Frame(ejemplos_frame, bg='#F8FAFC')
        ejemplos_buttons.pack(fill='x', pady=5)
        
        ejemplos_motivos = ['Consulta general', 'Control m√©dico', 'Revisi√≥n', 'Chequeo preventivo']
        for ejemplo in ejemplos_motivos:
            tk.Button(ejemplos_buttons, text=ejemplo, 
                     command=lambda e=ejemplo: motivo_var.set(e),
                     bg='#E8F6F3', fg='#0D7377', font=('Arial', 9),
                     relief='flat', padx=8, pady=2,
                     cursor='hand2').pack(side='left', padx=3)
        
        # Urgencia
        tk.Label(detalles_section, text="Nivel de Urgencia", font=('Arial', 11, 'bold'),
                bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w', pady=(10, 2))
        
        urgencia_frame = tk.Frame(detalles_section, bg='#F8FAFC')
        urgencia_frame.pack(fill='x', pady=(0, 10))
        
        urgencias = [('Normal', 'normal'), ('Urgente', 'urgente'), ('Muy Urgente', 'muy_urgente')]
        for texto, valor in urgencias:
            tk.Radiobutton(urgencia_frame, text=texto, variable=urgencia_var, value=valor,
                          bg='#F8FAFC', font=('Arial', 10)).pack(side='left', padx=10)
        
        # Observaciones
        tk.Label(detalles_section, text="Observaciones Adicionales", font=('Arial', 11, 'bold'),
                bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w', pady=(10, 2))
        
        obs_entry = tk.Entry(detalles_section, textvariable=observaciones_var, font=('Arial', 11),
                           relief='solid', bd=1)
        obs_entry.pack(fill='x', pady=(0, 5))
        
        tk.Label(detalles_section, text="Informaci√≥n adicional que desee compartir con el doctor", 
                font=('Arial', 9), bg='#F8FAFC', fg='#64748B').pack(anchor='w')
        
        # Funci√≥n para actualizar info del doctor
        def on_doctor_change(event=None):
            selected = doctor_combo.get()
            if selected and " - " in selected:
                try:
                    doctor_id = selected.split(" - ")[0]
                    # Buscar info del doctor
                    for doctor in doctors:
                        if str(doctor['id']) == doctor_id:
                            info_text = f"üë®‚Äç‚öïÔ∏è Dr. {doctor['nombre']} {doctor['apellido']}\n"
                            info_text += f"üè• Especialidad: {doctor.get('especialidad', 'Medicina General')}\n"
                            info_text += f"üìû Disponible para consultas"
                            doctor_info_label.config(text=info_text)
                            break
                except:
                    doctor_info_label.config(text="‚ÑπÔ∏è Informaci√≥n del doctor no disponible")
            else:
                doctor_info_label.config(text="‚ÑπÔ∏è Seleccione un doctor para ver informaci√≥n")
        
        doctor_combo.bind('<<ComboboxSelected>>', on_doctor_change)
        
        # Funci√≥n para guardar la cita
        def save_appointment():
            try:
                # Validaciones
                if not doctor_combo.get() or doctor_combo.get() == "Seleccione un doctor...":
                    messagebox.showerror("Error", "Debe seleccionar un doctor")
                    return
                
                if CALENDAR_AVAILABLE:
                    fecha = get_selected_date()
                else:
                    fecha = fecha_var.get().strip()
                
                if not fecha:
                    messagebox.showerror("Error", "Debe seleccionar una fecha")
                    return
                
                if not hora_var.get().strip():
                    messagebox.showerror("Error", "Debe ingresar una hora")
                    return
                
                if not motivo_var.get().strip():
                    messagebox.showerror("Error", "Debe ingresar el motivo de la consulta")
                    return
                
                # Extraer ID del doctor
                doctor_selected = doctor_combo.get()
                doctor_id = int(doctor_selected.split(" - ")[0])
                
                # Verificar conflictos de horario
                if hasattr(self, 'check_appointment_conflict'):
                    if self.check_appointment_conflict(fecha, hora_var.get().strip(), doctor_id):
                        if not messagebox.askyesno("Conflicto de Horario", 
                                                 "Ya existe una cita en ese horario. ¬øDesea continuar de todas formas?"):
                            return
                
                # Preparar datos
                appointment_data = {
                    'paciente_id': self.current_user.id,
                    'doctor_id': doctor_id,
                    'motivo': motivo_var.get().strip(),
                    'estado': 'pendiente',
                    'fecha_cita': fecha,
                    'hora_cita': hora_var.get().strip(),
                    'observaciones': observaciones_var.get().strip(),
                    'urgencia': urgencia_var.get()
                }
                
                # Guardar en la base de datos
                result = self.db_manager.create_appointment(appointment_data)
                
                if result:
                    messagebox.showinfo("√âxito", "‚úÖ Cita agendada correctamente")
                    schedule_window.destroy()
                    self.load_patient_appointments()  # Recargar lista
                else:
                    messagebox.showerror("Error", "No se pudo agendar la cita")
                    
            except Exception as e:
                messagebox.showerror("Error", f"Error al agendar la cita: {str(e)}")
        
        # Panel de botones
        buttons_frame = tk.Frame(schedule_window, bg='#F8FAFC')
        buttons_frame.pack(fill='x', padx=25, pady=(0, 25))
        
        # Botones con mejor dise√±o
        tk.Button(buttons_frame, text="‚ùå Cancelar", 
                 command=schedule_window.destroy,
                 bg='#95A5A6', fg='white', font=('Arial', 12, 'bold'),
                 relief='flat', padx=25, pady=10, cursor='hand2').pack(side='right', padx=(10, 0))
        
        tk.Button(buttons_frame, text="üíæ Agendar Cita", 
                 command=save_appointment,
                 bg='#16A085', fg='white', font=('Arial', 12, 'bold'),
                 relief='flat', padx=25, pady=10, cursor='hand2').pack(side='right')
        
        # Pack del canvas y scrollbar
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

    def update_patient_appointments_list(self):
        """Funci√≥n para el bot√≥n 'Actualizar Lista' - Recarga todas las citas del paciente"""
        try:
            self.load_patient_appointments()
            # Mostrar mensaje de confirmaci√≥n
            total_citas = len(self.patient_appointments_tree.get_children()) if hasattr(self, 'patient_appointments_tree') else 0
            messagebox.showinfo("Lista Actualizada", 
                               f"‚úÖ La lista de citas se ha actualizado correctamente.\n\n"
                               f"üìã Total de citas: {total_citas}")
        except Exception as e:
            messagebox.showerror("Error", f"Error al actualizar la lista de citas: {str(e)}")
            print(f"Error en update_patient_appointments_list: {e}")

    def refresh_patient_appointments(self):
        """Funci√≥n auxiliar para refrescar la lista sin mostrar mensaje"""
        try:
            self.load_patient_appointments()
        except Exception as e:
            print(f"Error refrescando citas: {e}")

    def get_appointment_status_info(self, status):
        """Obtiene informaci√≥n visual del estado de la cita"""
        status_info = {
            'pendiente': {
                'color': '#F59E0B',
                'icon': '‚è≥',
                'description': 'Pendiente de confirmaci√≥n'
            },
            'confirmada': {
                'color': '#10B981',
                'icon': '‚úÖ',
                'description': 'Confirmada'
            },
            'cancelada': {
                'color': '#EF4444',
                'icon': '‚ùå',
                'description': 'Cancelada'
            },
            'completada': {
                'color': '#6366F1',
                'icon': '‚úîÔ∏è',
                'description': 'Completada'
            },
            'en_proceso': {
                'color': '#8B5CF6',
                'icon': 'üîÑ',
                'description': 'En proceso'
            }
        }
        return status_info.get(status.lower(), {
            'color': '#6B7280',
            'icon': '‚ùì',
            'description': 'Estado desconocido'
        })

    def format_appointment_time(self, fecha_str, hora_str):
        """Formatea la fecha y hora de la cita para mostrar informaci√≥n adicional"""
        try:
            if not fecha_str or not hora_str:
                return "Sin programar", ""
            
            # Convertir a datetime
            fecha_obj = datetime.strptime(fecha_str, '%Y-%m-%d')
            hora_obj = datetime.strptime(hora_str, '%H:%M:%S')
            
            # Combinar fecha y hora
            cita_datetime = datetime.combine(fecha_obj.date(), hora_obj.time())
            now = datetime.now()
            
            # Calcular diferencia de tiempo
            diff = cita_datetime - now
            
            # Formatear fecha para mostrar
            fecha_display = fecha_obj.strftime('%d/%m/%Y')
            hora_display = hora_obj.strftime('%H:%M')
            
            # Informaci√≥n adicional sobre el tiempo
            if cita_datetime < now:
                tiempo_info = "Pasada"
            elif diff.days > 0:
                tiempo_info = f"En {diff.days} d√≠a{'s' if diff.days > 1 else ''}"
            elif diff.seconds > 3600:
                horas = diff.seconds // 3600
                tiempo_info = f"En {horas} hora{'s' if horas > 1 else ''}"
            else:
                minutos = diff.seconds // 60
                tiempo_info = f"En {minutos} minutos" if minutos > 0 else "Ahora"
            
            return fecha_display, hora_display, tiempo_info
            
        except Exception as e:
            print(f"Error formateando tiempo: {e}")
            return fecha_str, hora_str, ""

    def get_patient_appointment_summary(self):
        """Obtiene un resumen de las citas del paciente"""
        try:
            if not self.current_user or not hasattr(self.current_user, 'id'):
                return None
            
            conn = self.db_manager.get_connection()
            cur = conn.cursor()
            
            # Obtener estad√≠sticas de citas
            cur.execute("""
                SELECT 
                    COUNT(*) as total,
                    SUM(CASE WHEN estado = 'pendiente' THEN 1 ELSE 0 END) as pendientes,
                    SUM(CASE WHEN estado = 'confirmada' THEN 1 ELSE 0 END) as confirmadas,
                    SUM(CASE WHEN estado = 'cancelada' THEN 1 ELSE 0 END) as canceladas,
                    SUM(CASE WHEN estado = 'completada' THEN 1 ELSE 0 END) as completadas,
                    SUM(CASE WHEN DATE(fecha_hora) >= DATE('now') AND estado IN ('pendiente', 'confirmada') THEN 1 ELSE 0 END) as proximas
                FROM citas 
                WHERE paciente_id = ?
            """, (self.current_user.id,))
            
            stats = cur.fetchone()
            
            # Obtener pr√≥xima cita
            cur.execute("""
                SELECT fecha_hora, u.nombre || ' ' || u.apellido as doctor, motivo
                FROM citas c
                LEFT JOIN usuarios u ON u.id = c.doctor_id
                WHERE c.paciente_id = ? AND DATE(c.fecha_hora) >= DATE('now') AND c.estado IN ('pendiente', 'confirmada')
                ORDER BY c.fecha_hora ASC
                LIMIT 1
            """, (self.current_user.id,))
            
            proxima_cita = cur.fetchone()
            
            cur.close()
            conn.close()
            
            return {
                'total': stats[0] if stats else 0,
                'pendientes': stats[1] if stats else 0,
                'confirmadas': stats[2] if stats else 0,
                'canceladas': stats[3] if stats else 0,
                'completadas': stats[4] if stats else 0,
                'proximas': stats[5] if stats else 0,
                'proxima_cita': {
                    'fecha_hora': proxima_cita[0] if proxima_cita else None,
                    'doctor': proxima_cita[1] if proxima_cita else None,
                    'motivo': proxima_cita[2] if proxima_cita else None
                } if proxima_cita else None
            }
            
        except Exception as e:
            print(f"Error obteniendo resumen de citas: {e}")
            return None

    def load_patient_appointments(self):
        """Carga las citas del paciente aplicando filtros simples y fecha seleccionada del calendario"""
        try:
            if not hasattr(self, 'patient_appointments_tree'):
                return
            # Limpiar tabla
            for i in self.patient_appointments_tree.get_children():
                self.patient_appointments_tree.delete(i)

            # Verificar que el usuario est√° logueado
            if not self.current_user or not hasattr(self.current_user, 'id'):
                messagebox.showerror("Error", "No hay usuario logueado")
                return

            conn = self.db_manager.get_connection()
            cur = conn.cursor()
            where = "WHERE c.paciente_id = ?"
            params = [self.current_user.id]

            # Filtro por fecha del calendario
            sel_date = getattr(self, 'patient_cal_date', tk.StringVar()).get()
            if sel_date:
                try:
                    d, m, y = sel_date.split('/')
                    iso = f"{y}-{m.zfill(2)}-{d.zfill(2)}"
                    where += " AND DATE(c.fecha_hora) = ?"
                    params.append(iso)
                except:
                    pass

            # Ejecutar consulta con JOIN para obtener nombre del doctor
            cur.execute(f"""
                SELECT c.id, 
                       DATE(c.fecha_hora) as fecha, 
                       TIME(c.fecha_hora) as hora, 
                       COALESCE(u.nombre || ' ' || u.apellido, 'Sin asignar') as doctor_nombre,
                       COALESCE(c.motivo, 'Sin motivo') as motivo, 
                       COALESCE(c.estado, 'pendiente') as estado
                FROM citas c
                LEFT JOIN usuarios u ON u.id = c.doctor_id
                {where}
                ORDER BY c.fecha_hora DESC
            """, params)

            rows = cur.fetchall()
            
            # Aplicar filtros adicionales
            mode = getattr(self, 'patient_appointment_filter', None)
            now = datetime.now()
            
            for row in rows:
                # Convertir row a valores legibles (no objetos)
                appt_id = str(row[0]) if row[0] else ""
                fecha_str = str(row[1]) if row[1] else ""
                hora_str = str(row[2]) if row[2] else ""
                doctor_str = str(row[3]) if row[3] else "Sin asignar"
                motivo_str = str(row[4]) if row[4] else "Sin motivo"
                estado_str = str(row[5]) if row[5] else "pendiente"
                
                # Formatear fecha para mostrar
                if fecha_str:
                    try:
                        fecha_obj = datetime.strptime(fecha_str, '%Y-%m-%d')
                        fecha_display = fecha_obj.strftime('%d/%m/%Y')
                    except:
                        fecha_display = fecha_str
                else:
                    fecha_display = ""
                
                # Formatear hora
                if hora_str:
                    try:
                        hora_obj = datetime.strptime(hora_str, '%H:%M:%S')
                        hora_display = hora_obj.strftime('%H:%M')
                    except:
                        hora_display = hora_str
                else:
                    hora_display = ""
                
                # Aplicar filtros de tiempo
                keep = True
                if mode:
                    val = mode.get()
                    dt_iso = f"{fecha_str} {hora_str}".strip()
                    try:
                        appt_datetime = datetime.fromisoformat(dt_iso)
                        if val == 'Pr√≥ximas' and appt_datetime < now:
                            keep = False
                        elif val == 'Pasadas' and appt_datetime >= now:
                            keep = False
                        elif val == 'Este Mes':
                            month = now.strftime('%Y-%m')
                            keep = fecha_str.startswith(month)
                    except:
                        pass
                
                if keep:
                    # Obtener informaci√≥n del estado
                    status_info = self.get_appointment_status_info(estado_str)
                    
                    # Formatear tiempo con informaci√≥n adicional
                    fecha_display, hora_display, tiempo_info = self.format_appointment_time(fecha_str, hora_str)
                    
                    # Truncar motivo si es muy largo
                    motivo_truncado = motivo_str[:25] + "..." if len(motivo_str) > 25 else motivo_str
                    
                    # Agregar icono al estado
                    estado_con_icono = f"{status_info['icon']} {estado_str.upper()}"
                    
                    # Insertar valores como strings legibles
                    self.patient_appointments_tree.insert('', 'end', values=(
                        appt_id,
                        fecha_display,
                        hora_display,
                        doctor_str,
                        motivo_truncado,
                        estado_con_icono
                    ), tags=(estado_str.lower(),))

            # Configurar colores para los diferentes estados
            if hasattr(self, 'patient_appointments_tree'):
                self.patient_appointments_tree.tag_configure('pendiente', background='#FEF3C7')
                self.patient_appointments_tree.tag_configure('confirmada', background='#D1FAE5')
                self.patient_appointments_tree.tag_configure('cancelada', background='#FEE2E2')
                self.patient_appointments_tree.tag_configure('completada', background='#E0E7FF')
                self.patient_appointments_tree.tag_configure('en_proceso', background='#F3E8FF')

            cur.close()
            conn.close()
            
            # Actualizar contador con informaci√≥n adicional
            total_citas = len(self.patient_appointments_tree.get_children())
            if hasattr(self, 'patient_appointments_count_label'):
                # Obtener resumen de citas
                summary = self.get_patient_appointment_summary()
                if summary:
                    count_text = f"üìã Total: {total_citas} | ‚è≥ Pendientes: {summary['pendientes']} | ‚úÖ Confirmadas: {summary['confirmadas']}"
                else:
                    count_text = f"üìã Total: {total_citas} citas"
                self.patient_appointments_count_label.config(text=count_text)
                
        except Exception as e:
            messagebox.showerror('Error', f'Error cargando citas: {str(e)}')
            print(f"Error en load_patient_appointments: {e}")
            import traceback
            traceback.print_exc()
    
    def get_appointment_status_info(self, estado):
        """Obtiene informaci√≥n visual del estado de la cita"""
        status_map = {
            'pendiente': {'icon': '‚è≥', 'color': '#F39C12', 'description': 'Esperando confirmaci√≥n'},
            'confirmada': {'icon': '‚úÖ', 'color': '#27AE60', 'description': 'Confirmada por el doctor'},
            'cancelada': {'icon': '‚ùå', 'color': '#E74C3C', 'description': 'Cita cancelada'},
            'completada': {'icon': '‚úîÔ∏è', 'color': '#2980B9', 'description': 'Consulta realizada'},
            'en_proceso': {'icon': 'üîÑ', 'color': '#9B59B6', 'description': 'En curso'}
        }
        
        return status_map.get(estado.lower(), {
            'icon': '‚ùì', 
            'color': '#95A5A6', 
            'description': 'Estado desconocido'
        })
    
    def format_appointment_time(self, fecha_str, hora_str):
        """Formatea la fecha y hora con informaci√≥n adicional"""
        try:
            if not fecha_str or not hora_str:
                return "Sin fecha", "Sin hora", ""
            
            # Convertir a datetime
            dt_str = f"{fecha_str} {hora_str}"
            dt = datetime.fromisoformat(dt_str)
            now = datetime.now()
            
            # Formatear fecha
            fecha_display = dt.strftime('%d/%m/%Y')
            
            # Formatear hora
            hora_display = dt.strftime('%H:%M')
            
            # Calcular tiempo relativo
            diff = dt - now
            
            if diff.total_seconds() > 0:
                # Cita futura
                if diff.days > 0:
                    tiempo_info = f"En {diff.days} d√≠as"
                elif diff.seconds > 3600:
                    horas = diff.seconds // 3600
                    tiempo_info = f"En {horas}h"
                else:
                    minutos = diff.seconds // 60
                    tiempo_info = f"En {minutos}min"
            else:
                # Cita pasada
                diff_abs = abs(diff)
                if diff_abs.days > 0:
                    tiempo_info = f"Hace {diff_abs.days} d√≠as"
                elif diff_abs.seconds > 3600:
                    horas = diff_abs.seconds // 3600
                    tiempo_info = f"Hace {horas}h"
                else:
                    minutos = diff_abs.seconds // 60
                    tiempo_info = f"Hace {minutos}min"
            
            return fecha_display, hora_display, tiempo_info
            
        except Exception as e:
            print(f"Error formateando tiempo: {e}")
            return str(fecha_str), str(hora_str), ""
    
    def get_patient_appointment_summary(self):
        """Obtiene un resumen de las citas del paciente"""
        try:
            if not hasattr(self, 'patient_appointments_tree'):
                return None
            
            summary = {
                'total': 0,
                'pendientes': 0,
                'confirmadas': 0,
                'canceladas': 0,
                'completadas': 0
            }
            
            for item in self.patient_appointments_tree.get_children():
                summary['total'] += 1
                values = self.patient_appointments_tree.item(item)['values']
                if len(values) > 5:
                    estado = values[5].lower()
                    if 'pendiente' in estado:
                        summary['pendientes'] += 1
                    elif 'confirmada' in estado:
                        summary['confirmadas'] += 1
                    elif 'cancelada' in estado:
                        summary['canceladas'] += 1
                    elif 'completada' in estado:
                        summary['completadas'] += 1
            
            return summary
        except Exception as e:
            print(f"Error obteniendo resumen: {e}")
            return None

    def view_my_appointment_details(self):
        """Muestra los detalles completos de la cita seleccionada"""
        try:
            sel = self.patient_appointments_tree.selection()
            if not sel:
                messagebox.showwarning("Selecci√≥n", "Por favor seleccione una cita para ver los detalles")
                return
            
            # Obtener datos de la fila seleccionada
            vals = self.patient_appointments_tree.item(sel[0])['values']
            if not vals:
                messagebox.showerror("Error", "No se pudieron obtener los datos de la cita")
                return
            
            appt_id = vals[0]
            
            # Obtener detalles completos de la base de datos
            try:
                conn = self.db_manager.get_connection()
                cur = conn.cursor()
                
                cur.execute("""
                    SELECT c.id, c.fecha_hora, c.motivo, c.estado, c.notas,
                           u.nombre || ' ' || u.apellido as doctor_nombre,
                           d.especialidad, u.telefono as doctor_telefono,
                           p.nombre || ' ' || p.apellido as paciente_nombre
                    FROM citas c
                    LEFT JOIN usuarios u ON u.id = c.doctor_id
                    LEFT JOIN doctores d ON d.id = c.doctor_id  
                    LEFT JOIN usuarios p ON p.id = c.paciente_id
                    WHERE c.id = ?
                """, (appt_id,))
                
                row = cur.fetchone()
                cur.close()
                conn.close()
                
                if not row:
                    messagebox.showerror("Error", "No se encontraron detalles para esta cita")
                    return
                
                # Crear ventana de detalles
                details_window = tk.Toplevel(self.root)
                details_window.title("üè• Detalles de la Cita")
                details_window.geometry("500x600")
                details_window.configure(bg='#F8FAFC')
                details_window.transient(self.root)
                details_window.grab_set()
                
                # Centrar ventana
                details_window.update_idletasks()
                x = (details_window.winfo_screenwidth() // 2) - (500 // 2)
                y = (details_window.winfo_screenheight() // 2) - (600 // 2)
                details_window.geometry(f"500x600+{x}+{y}")
                
                # Header
                header_frame = tk.Frame(details_window, bg='#1E3A8A', height=80)
                header_frame.pack(fill='x')
                header_frame.pack_propagate(False)
                
                tk.Label(header_frame, text="üìã DETALLES DE LA CITA", 
                        font=('Arial', 16, 'bold'), bg='#1E3A8A', fg='white').pack(expand=True)
                
                # Contenido principal
                main_frame = tk.Frame(details_window, bg='#F8FAFC')
                main_frame.pack(fill='both', expand=True, padx=20, pady=20)
                
                # Procesar datos
                fecha_hora_str = str(row[1]) if row[1] else "No definida"
                motivo_str = str(row[2]) if row[2] else "Sin motivo especificado"
                estado_str = str(row[3]) if row[3] else "pendiente"
                notas_str = str(row[4]) if row[4] else "Sin observaciones"
                doctor_str = str(row[5]) if row[5] else "Sin asignar"
                especialidad_str = str(row[6]) if row[6] else "General"
                doctor_tel_str = str(row[7]) if row[7] else "No disponible"
                
                # Formatear fecha y hora
                try:
                    if fecha_hora_str != "No definida":
                        dt = datetime.fromisoformat(fecha_hora_str)
                        fecha_formateada = dt.strftime('%A, %d de %B de %Y')
                        hora_formateada = dt.strftime('%H:%M')
                    else:
                        fecha_formateada = "No definida"
                        hora_formateada = ""
                except:
                    fecha_formateada = fecha_hora_str
                    hora_formateada = ""
                
                # Informaci√≥n de la cita
                info_sections = [
                    ("üìÖ INFORMACI√ìN GENERAL", [
                        ("ID de la Cita:", appt_id),
                        ("Fecha:", fecha_formateada),
                        ("Hora:", hora_formateada),
                        ("Estado:", estado_str.upper())
                    ]),
                    ("üë®‚Äç‚öïÔ∏è INFORMACI√ìN DEL DOCTOR", [
                        ("Doctor:", doctor_str),
                        ("Especialidad:", especialidad_str),
                        ("Tel√©fono:", doctor_tel_str)
                    ]),
                    ("üí≠ DETALLES DE LA CONSULTA", [
                        ("Motivo:", motivo_str),
                        ("Observaciones:", notas_str)
                    ])
                ]
                
                for section_title, section_data in info_sections:
                    # T√≠tulo de secci√≥n
                    section_frame = tk.LabelFrame(main_frame, text=section_title,
                                                 font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                                 padx=15, pady=10)
                    section_frame.pack(fill='x', pady=(0, 15))
                    
                    # Datos de la secci√≥n
                    for label, value in section_data:
                        row_frame = tk.Frame(section_frame, bg='#F8FAFC')
                        row_frame.pack(fill='x', pady=3)
                        
                        tk.Label(row_frame, text=label, font=('Arial', 10, 'bold'),
                                bg='#F8FAFC', fg='#1E3A8A', anchor='w').pack(side='left')
                        
                        # Para textos largos, usar Text widget
                        if len(str(value)) > 50:
                            text_widget = tk.Text(row_frame, height=3, wrap='word',
                                                 font=('Arial', 10), bg='#FFFFFF',
                                                 relief='flat', bd=1)
                            text_widget.insert(1.0, str(value))
                            text_widget.configure(state='disabled')
                            text_widget.pack(fill='x', pady=(2, 0))
                        else:
                            tk.Label(row_frame, text=str(value), font=('Arial', 10),
                                    bg='#F8FAFC', fg='#64748B', anchor='w',
                                    wraplength=300).pack(fill='x', padx=(10, 0))
                
                # Botones de acci√≥n
                buttons_frame = tk.Frame(details_window, bg='#F8FAFC')
                buttons_frame.pack(fill='x', padx=20, pady=(0, 20))
                
                # Bot√≥n cerrar
                tk.Button(buttons_frame, text="‚úÖ Cerrar", 
                         command=details_window.destroy,
                         bg='#16A085', fg='white', font=('Arial', 11, 'bold'),
                         relief='flat', padx=20, pady=8, cursor='hand2').pack(side='right')
                
                # Bot√≥n para cancelar cita (solo si est√° pendiente)
                if estado_str.lower() in ['pendiente', 'confirmada']:
                    tk.Button(buttons_frame, text="‚ùå Cancelar Cita", 
                             command=lambda: self.cancel_appointment_from_details(appt_id, details_window),
                             bg='#DC2626', fg='white', font=('Arial', 11, 'bold'),
                             relief='flat', padx=20, pady=8, cursor='hand2').pack(side='left')
                
            except Exception as db_error:
                messagebox.showerror("Error de Base de Datos", f"Error al obtener detalles: {str(db_error)}")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error mostrando detalles: {str(e)}")
            print(f"Error en view_my_appointment_details: {e}")
            import traceback
            traceback.print_exc()
    
    def cancel_appointment_from_details(self, appt_id, details_window):
        """Cancela una cita desde la ventana de detalles"""
        try:
            if messagebox.askyesno('Confirmar Cancelaci√≥n', 
                                  '¬øEst√° seguro que desea cancelar esta cita?\n\n'
                                  'Esta acci√≥n no se puede deshacer.'):
                if self.db_manager.update_appointment_status(appt_id, 'cancelada'):
                    messagebox.showinfo('Cita Cancelada', 'La cita ha sido cancelada exitosamente.')
                    details_window.destroy()
                    self.load_patient_appointments()  # Recargar lista
                else:
                    messagebox.showerror('Error', 'No se pudo cancelar la cita.')
        except Exception as e:
            messagebox.showerror('Error', f'Error cancelando cita: {str(e)}')

    def edit_my_appointment(self):
        """Permite al paciente editar su cita (solo fecha, hora y motivo)"""
        try:
            sel = self.patient_appointments_tree.selection()
            if not sel:
                messagebox.showwarning("Selecci√≥n", "Por favor seleccione una cita para editar")
                return
            
            # Obtener datos de la fila seleccionada
            vals = self.patient_appointments_tree.item(sel[0])['values']
            if not vals:
                messagebox.showerror("Error", "No se pudieron obtener los datos de la cita")
                return
            
            appt_id = vals[0]
            current_estado = vals[5] if len(vals) > 5 else ""
            
            # Verificar que la cita se puede editar
            if current_estado.lower() in ['completada', 'cancelada']:
                messagebox.showwarning("Cita No Editable", 
                                     f"No se puede editar una cita con estado: {current_estado}")
                return
            
            # Obtener detalles actuales de la cita
            try:
                conn = self.db_manager.get_connection()
                cur = conn.cursor()
                
                cur.execute("""
                    SELECT c.id, c.fecha_hora, c.motivo, c.notas, c.doctor_id,
                           u.nombre || ' ' || u.apellido as doctor_nombre
                    FROM citas c
                    LEFT JOIN usuarios u ON u.id = c.doctor_id
                    WHERE c.id = ?
                """, (appt_id,))
                
                row = cur.fetchone()
                cur.close()
                conn.close()
                
                if not row:
                    messagebox.showerror("Error", "No se encontraron datos para esta cita")
                    return
                
                # Extraer datos actuales
                fecha_hora_actual = row[1] if row[1] else ""
                motivo_actual = row[2] if row[2] else ""
                notas_actual = row[4] if row[4] else ""  # Cambi√© observaciones por notas
                doctor_id = row[5] if len(row) > 5 else None
                doctor_nombre = row[6] if len(row) > 6 else ""
                
                # Separar fecha y hora
                fecha_actual = ""
                hora_actual = ""
                if fecha_hora_actual:
                    try:
                        dt = datetime.fromisoformat(fecha_hora_actual)
                        fecha_actual = dt.strftime('%d/%m/%Y')
                        hora_actual = dt.strftime('%H:%M')
                    except:
                        fecha_actual = fecha_hora_actual.split(' ')[0] if ' ' in fecha_hora_actual else fecha_hora_actual
                        hora_actual = fecha_hora_actual.split(' ')[1] if ' ' in fecha_hora_actual else ""
                
                # Crear ventana de edici√≥n redise√±ada
                edit_window = tk.Toplevel(self.root)
                edit_window.title("‚úèÔ∏è Editar Mi Cita M√©dica")
                edit_window.geometry("650x750")
                edit_window.configure(bg='#F8FAFC')
                edit_window.transient(self.root)
                edit_window.grab_set()
                edit_window.resizable(False, False)
                
                # Centrar ventana
                edit_window.update_idletasks()
                x = (edit_window.winfo_screenwidth() // 2) - (650 // 2)
                y = (edit_window.winfo_screenheight() // 2) - (750 // 2)
                edit_window.geometry(f"650x750+{x}+{y}")
                
                # Header redise√±ado con gradiente visual
                header_frame = tk.Frame(edit_window, bg='#E67E22', height=90)
                header_frame.pack(fill='x')
                header_frame.pack_propagate(False)
                
                # Contenido del header
                header_content = tk.Frame(header_frame, bg='#E67E22')
                header_content.pack(expand=True, fill='both', padx=30, pady=20)
                
                tk.Label(header_content, text="‚úèÔ∏è EDITAR CITA M√âDICA", 
                        font=('Arial', 18, 'bold'), bg='#E67E22', fg='white').pack()
                tk.Label(header_content, text="Modifique los detalles de su cita m√©dica seg√∫n sus necesidades", 
                        font=('Arial', 11), bg='#E67E22', fg='#FDF2E9').pack(pady=(5, 0))
                
                # Container principal con scroll
                main_container = tk.Frame(edit_window, bg='#F8FAFC')
                main_container.pack(fill='both', expand=True, padx=25, pady=20)
                
                # Canvas para scroll
                canvas = tk.Canvas(main_container, bg='#F8FAFC', highlightthickness=0)
                scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=canvas.yview)
                scrollable_frame = tk.Frame(canvas, bg='#F8FAFC')
                
                scrollable_frame.bind(
                    "<Configure>",
                    lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
                )
                
                canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
                canvas.configure(yscrollcommand=scrollbar.set)
                
                # Variables para el formulario
                fecha_var = tk.StringVar(value=fecha_actual)
                hora_var = tk.StringVar(value=hora_actual)
                motivo_var = tk.StringVar(value=motivo_actual)
                observaciones_var = tk.StringVar(value=notas_actual)
                
                # SECCI√ìN: Informaci√≥n actual de la cita
                current_section = tk.LabelFrame(scrollable_frame, text="ÔøΩ Informaci√≥n Actual de la Cita", 
                                              font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                              padx=20, pady=15)
                current_section.pack(fill='x', pady=(0, 20))
                
                # Grid para informaci√≥n actual
                current_grid = tk.Frame(current_section, bg='#F8FAFC')
                current_grid.pack(fill='x')
                current_grid.columnconfigure(0, weight=1)
                current_grid.columnconfigure(1, weight=1)
                
                # Informaci√≥n del doctor
                doctor_info_frame = tk.Frame(current_grid, bg='#E8F6F3', relief='solid', bd=1)
                doctor_info_frame.grid(row=0, column=0, columnspan=2, sticky='ew', pady=(0, 10))
                
                tk.Label(doctor_info_frame, text="üë®‚Äç‚öïÔ∏è Doctor Asignado (No se puede cambiar)", 
                        font=('Arial', 10, 'bold'), bg='#E8F6F3', fg='#0D7377').pack(anchor='w', padx=15, pady=(8, 2))
                tk.Label(doctor_info_frame, text=doctor_nombre, 
                        font=('Arial', 12, 'bold'), bg='#E8F6F3', fg='#16A085').pack(anchor='w', padx=15, pady=(0, 8))
                
                # Fecha actual
                current_fecha_frame = tk.Frame(current_grid, bg='#F8FAFC')
                current_fecha_frame.grid(row=1, column=0, sticky='ew', padx=(0, 10))
                
                tk.Label(current_fecha_frame, text="üìÖ Fecha Actual:", 
                        font=('Arial', 10, 'bold'), bg='#F8FAFC', fg='#64748B').pack(anchor='w')
                tk.Label(current_fecha_frame, text=fecha_actual, 
                        font=('Arial', 11), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
                
                # Hora actual
                current_hora_frame = tk.Frame(current_grid, bg='#F8FAFC')
                current_hora_frame.grid(row=1, column=1, sticky='ew', padx=(10, 0))
                
                tk.Label(current_hora_frame, text="üïê Hora Actual:", 
                        font=('Arial', 10, 'bold'), bg='#F8FAFC', fg='#64748B').pack(anchor='w')
                tk.Label(current_hora_frame, text=hora_actual, 
                        font=('Arial', 11), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
                
                # SECCI√ìN: Nueva fecha y hora
                datetime_section = tk.LabelFrame(scrollable_frame, text="üìÖ Modificar Fecha y Hora", 
                                               font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                               padx=20, pady=15)
                datetime_section.pack(fill='x', pady=(0, 20))
                
                # Grid para fecha y hora
                datetime_grid = tk.Frame(datetime_section, bg='#F8FAFC')
                datetime_grid.pack(fill='x')
                datetime_grid.columnconfigure(0, weight=1)
                datetime_grid.columnconfigure(1, weight=1)
                
                # Nueva fecha
                fecha_frame = tk.Frame(datetime_grid, bg='#F8FAFC')
                fecha_frame.grid(row=0, column=0, sticky='ew', padx=(0, 15))
                
                tk.Label(fecha_frame, text="üìÖ Nueva Fecha *", 
                        font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
                
                fecha_entry = tk.Entry(fecha_frame, textvariable=fecha_var, font=('Arial', 12),
                                     relief='solid', bd=2, bg='white')
                fecha_entry.pack(fill='x', pady=(8, 5))
                
                tk.Label(fecha_frame, text="Formato: DD/MM/YYYY", 
                        font=('Arial', 9), bg='#F8FAFC', fg='#64748B').pack(anchor='w')
                
                # Nueva hora
                hora_frame = tk.Frame(datetime_grid, bg='#F8FAFC')
                hora_frame.grid(row=0, column=1, sticky='ew', padx=(15, 0))
                
                tk.Label(hora_frame, text="üïê Nueva Hora *", 
                        font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
                
                hora_entry = tk.Entry(hora_frame, textvariable=hora_var, font=('Arial', 12),
                                    relief='solid', bd=2, bg='white')
                hora_entry.pack(fill='x', pady=(8, 5))
                
                tk.Label(hora_frame, text="Formato: HH:MM", 
                        font=('Arial', 9), bg='#F8FAFC', fg='#64748B').pack(anchor='w')
                
                # Horarios sugeridos mejorados
                horarios_section = tk.Frame(datetime_section, bg='#F8FAFC')
                horarios_section.pack(fill='x', pady=(15, 0))
                
                tk.Label(horarios_section, text="‚è∞ Horarios Disponibles:", 
                        font=('Arial', 10, 'bold'), bg='#F8FAFC', fg='#64748B').pack(anchor='w')
                
                horarios_container = tk.Frame(horarios_section, bg='#F8FAFC')
                horarios_container.pack(fill='x', pady=8)
                
                # Horarios matutinos
                morning_frame = tk.Frame(horarios_container, bg='#F8FAFC')
                morning_frame.pack(fill='x', pady=2)
                
                tk.Label(morning_frame, text="üåÖ Ma√±ana:", font=('Arial', 9, 'bold'),
                        bg='#F8FAFC', fg='#64748B').pack(side='left', padx=(0, 10))
                
                morning_times = ['08:00', '09:00', '10:00', '11:00', '12:00']
                for time in morning_times:
                    tk.Button(morning_frame, text=time, 
                             command=lambda t=time: hora_var.set(t),
                             bg='#E8F6F3', fg='#0D7377', font=('Arial', 9, 'bold'),
                             relief='solid', bd=1, padx=12, pady=4,
                             cursor='hand2').pack(side='left', padx=2)
                
                # Horarios vespertinos
                afternoon_frame = tk.Frame(horarios_container, bg='#F8FAFC')
                afternoon_frame.pack(fill='x', pady=2)
                
                tk.Label(afternoon_frame, text="üåá Tarde:", font=('Arial', 9, 'bold'),
                        bg='#F8FAFC', fg='#64748B').pack(side='left', padx=(0, 10))
                
                afternoon_times = ['14:00', '15:00', '16:00', '17:00', '18:00']
                for time in afternoon_times:
                    tk.Button(afternoon_frame, text=time, 
                             command=lambda t=time: hora_var.set(t),
                             bg='#FDF2E9', fg='#E67E22', font=('Arial', 9, 'bold'),
                             relief='solid', bd=1, padx=12, pady=4,
                             cursor='hand2').pack(side='left', padx=2)
                
                # SECCI√ìN: Motivo y observaciones
                details_section = tk.LabelFrame(scrollable_frame, text="üí≠ Detalles de la Consulta", 
                                              font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                              padx=20, pady=15)
                details_section.pack(fill='x', pady=(0, 20))
                
                # Motivo
                tk.Label(details_section, text="Motivo de la Consulta *", 
                        font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w', pady=(5, 2))
                
                motivo_entry = tk.Entry(details_section, textvariable=motivo_var, font=('Arial', 12),
                                      relief='solid', bd=2, bg='white')
                motivo_entry.pack(fill='x', pady=(0, 10))
                
                # Observaciones
                tk.Label(details_section, text="Observaciones Adicionales", 
                        font=('Arial', 11, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w', pady=(10, 2))
                
                obs_text = tk.Text(details_section, height=3, font=('Arial', 11),
                                 relief='solid', bd=2, bg='white', wrap='word')
                obs_text.pack(fill='x', pady=(0, 5))
                obs_text.insert('1.0', observaciones_var.get())
                
                tk.Label(details_section, text="Informaci√≥n adicional que desee compartir con el doctor", 
                        font=('Arial', 9), bg='#F8FAFC', fg='#64748B').pack(anchor='w')
                
                # SECCI√ìN: Advertencias y consejos
                warning_section = tk.Frame(scrollable_frame, bg='#FEF3C7', relief='solid', bd=1)
                warning_section.pack(fill='x', pady=(0, 20))
                
                warning_content = tk.Frame(warning_section, bg='#FEF3C7')
                warning_content.pack(fill='x', padx=15, pady=12)
                
                tk.Label(warning_content, text="‚ö†Ô∏è IMPORTANTE:", 
                        font=('Arial', 10, 'bold'), bg='#FEF3C7', fg='#92400E').pack(anchor='w')
                
                warning_text = ("‚Ä¢ Los cambios deben realizarse con al menos 24 horas de anticipaci√≥n\n"
                              "‚Ä¢ Solo puede cambiar fecha, hora, motivo y observaciones\n"
                              "‚Ä¢ El doctor asignado no se puede modificar\n"
                              "‚Ä¢ Si requiere cambiar doctor, debe cancelar y crear una nueva cita")
                
                tk.Label(warning_content, text=warning_text, 
                        font=('Arial', 9), bg='#FEF3C7', fg='#92400E',
                        justify='left').pack(anchor='w', pady=(5, 0))
                
                # Funci√≥n para guardar cambios (mejorada)
                def save_changes():
                    try:
                        # Validar campos
                        if not fecha_var.get().strip():
                            messagebox.showerror("Error", "La fecha es obligatoria")
                            fecha_entry.focus()
                            return
                        
                        if not hora_var.get().strip():
                            messagebox.showerror("Error", "La hora es obligatoria")
                            hora_entry.focus()
                            return
                        
                        if not motivo_var.get().strip():
                            messagebox.showerror("Error", "El motivo es obligatorio")
                            motivo_entry.focus()
                            return
                        
                        # Obtener observaciones del Text widget
                        observaciones_text = obs_text.get('1.0', 'end-1c')
                        
                        # Construir fecha_hora
                        try:
                            # Convertir fecha de DD/MM/YYYY a YYYY-MM-DD
                            fecha_parts = fecha_var.get().strip().split('/')
                            if len(fecha_parts) != 3:
                                raise ValueError("Use el formato DD/MM/YYYY para la fecha")
                            
                            dia, mes, a√±o = fecha_parts
                            
                            # Validar que sean n√∫meros
                            dia = int(dia)
                            mes = int(mes)
                            a√±o = int(a√±o)
                            
                            if dia < 1 or dia > 31:
                                raise ValueError("El d√≠a debe estar entre 1 y 31")
                            if mes < 1 or mes > 12:
                                raise ValueError("El mes debe estar entre 1 y 12")
                            if a√±o < 2024:
                                raise ValueError("El a√±o debe ser 2024 o posterior")
                            
                            fecha_iso = f"{a√±o}-{mes:02d}-{dia:02d}"
                            
                            # Validar hora
                            hora = hora_var.get().strip()
                            if ':' not in hora:
                                raise ValueError("Use el formato HH:MM para la hora")
                            
                            hora_parts = hora.split(':')
                            if len(hora_parts) != 2:
                                raise ValueError("Use el formato HH:MM para la hora")
                            
                            horas = int(hora_parts[0])
                            minutos = int(hora_parts[1])
                            
                            if horas < 0 or horas > 23:
                                raise ValueError("Las horas deben estar entre 00 y 23")
                            if minutos < 0 or minutos > 59:
                                raise ValueError("Los minutos deben estar entre 00 y 59")
                            
                            fecha_hora = f"{fecha_iso} {horas:02d}:{minutos:02d}:00"
                            
                            # Validar que sea una fecha v√°lida
                            dt = datetime.fromisoformat(fecha_hora)
                            
                            # Verificar que no sea en el pasado
                            if dt < datetime.now():
                                if not messagebox.askyesno("Fecha Pasada", 
                                                         "La fecha/hora seleccionada ya pas√≥. ¬øDesea continuar de todas formas?"):
                                    return
                            
                        except ValueError as ve:
                            messagebox.showerror("Error de Formato", str(ve))
                            return
                        
                        # Confirmar cambios
                        if messagebox.askyesno("Confirmar Cambios", 
                                             "¬øEst√° seguro que desea guardar los cambios en la cita?"):
                            
                            # Actualizar en la base de datos
                            conn = self.db_manager.get_connection()
                            cur = conn.cursor()
                            
                            cur.execute("""
                                UPDATE citas 
                                SET fecha_hora = ?, motivo = ?, notas = ?
                                WHERE id = ?
                            """, (fecha_hora, motivo_var.get().strip(), 
                                 observaciones_text, appt_id))
                            
                            conn.commit()
                            cur.close()
                            conn.close()
                            
                            messagebox.showinfo("√âxito", "‚úÖ La cita ha sido actualizada correctamente")
                            edit_window.destroy()
                            self.load_patient_appointments()  # Recargar lista
                        
                    except Exception as e:
                        messagebox.showerror("Error", f"Error guardando cambios: {str(e)}")
                
                # Pack del canvas y scrollbar
                canvas.pack(side="left", fill="both", expand=True)
                scrollbar.pack(side="right", fill="y")
                
                # Panel de botones redise√±ado
                buttons_frame = tk.Frame(edit_window, bg='#F8FAFC')
                buttons_frame.pack(fill='x', padx=25, pady=(0, 25))
                
                # Botones con mejor dise√±o
                tk.Button(buttons_frame, text="‚ùå Cancelar", 
                         command=edit_window.destroy,
                         bg='#95A5A6', fg='white', font=('Arial', 12, 'bold'),
                         relief='flat', padx=25, pady=12, cursor='hand2').pack(side='right', padx=(10, 0))
                
                tk.Button(buttons_frame, text="üíæ Guardar Cambios", 
                         command=save_changes,
                         bg='#E67E22', fg='white', font=('Arial', 12, 'bold'),
                         relief='flat', padx=25, pady=12, cursor='hand2').pack(side='right')
                
            except Exception as db_error:
                messagebox.showerror("Error de Base de Datos", f"Error al obtener datos: {str(db_error)}")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error editando cita: {str(e)}")
            print(f"Error en edit_my_appointment: {e}")
            import traceback
            traceback.print_exc()

    def cancel_my_appointment(self):
        """Formulario completo y redise√±ado para cancelar cita m√©dica"""
        try:
            sel = self.patient_appointments_tree.selection()
            if not sel:
                messagebox.showwarning("Selecci√≥n", "Por favor seleccione una cita para cancelar")
                return
            
            # Obtener ID de la cita
            vals = self.patient_appointments_tree.item(sel[0])['values']
            if not vals:
                messagebox.showerror("Error", "No se pudieron obtener los datos de la cita")
                return
            
            appt_id = vals[0]
            fecha = vals[1] if len(vals) > 1 else "N/A"
            hora = vals[2] if len(vals) > 2 else "N/A"
            doctor = vals[3] if len(vals) > 3 else "N/A"
            motivo = vals[4] if len(vals) > 4 else "N/A"
            estado = vals[5] if len(vals) > 5 else "pendiente"
            
            # Verificar si la cita se puede cancelar
            if estado.lower() in ['cancelada', 'completada']:
                messagebox.showwarning("Cancelaci√≥n No Permitida", 
                                      f"No se puede cancelar una cita que ya est√° {estado.lower()}.")
                return
            
            # Ventana de cancelaci√≥n redise√±ada
            cancel_window = tk.Toplevel(self.root)
            cancel_window.title("‚ùå Cancelar Cita M√©dica")
            cancel_window.geometry("600x650")
            cancel_window.configure(bg='#F8FAFC')
            cancel_window.transient(self.root)
            cancel_window.grab_set()
            cancel_window.resizable(False, False)
            
            # Centrar ventana
            cancel_window.update_idletasks()
            x = (cancel_window.winfo_screenwidth() // 2) - (600 // 2)
            y = (cancel_window.winfo_screenheight() // 2) - (650 // 2)
            cancel_window.geometry(f"600x650+{x}+{y}")
            
            # Header redise√±ado
            header_frame = tk.Frame(cancel_window, bg='#E74C3C', height=90)
            header_frame.pack(fill='x')
            header_frame.pack_propagate(False)
            
            # Contenido del header
            header_content = tk.Frame(header_frame, bg='#E74C3C')
            header_content.pack(expand=True, fill='both', padx=30, pady=20)
            
            tk.Label(header_content, text="‚ùå CANCELAR CITA M√âDICA", 
                    font=('Arial', 18, 'bold'), bg='#E74C3C', fg='white').pack()
            tk.Label(header_content, text="Por favor confirme la cancelaci√≥n y proporcione un motivo", 
                    font=('Arial', 11), bg='#E74C3C', fg='#FADBD8').pack(pady=(5, 0))
            
            # Container principal con scroll
            main_container = tk.Frame(cancel_window, bg='#F8FAFC')
            main_container.pack(fill='both', expand=True, padx=25, pady=20)
            
            # Canvas para scroll
            canvas = tk.Canvas(main_container, bg='#F8FAFC', highlightthickness=0)
            scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=canvas.yview)
            scrollable_frame = tk.Frame(canvas, bg='#F8FAFC')
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # SECCI√ìN: Informaci√≥n de la cita a cancelar
            info_section = tk.LabelFrame(scrollable_frame, text="üìã Detalles de la Cita a Cancelar", 
                                       font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                       padx=20, pady=15)
            info_section.pack(fill='x', pady=(0, 20))
            
            # Grid para informaci√≥n
            info_grid = tk.Frame(info_section, bg='#F8FAFC')
            info_grid.pack(fill='x')
            info_grid.columnconfigure(0, weight=1)
            info_grid.columnconfigure(1, weight=1)
            
            # Fecha y hora
            fecha_frame = tk.Frame(info_grid, bg='#FEF3C7', relief='solid', bd=1)
            fecha_frame.grid(row=0, column=0, sticky='ew', padx=(0, 10), pady=5)
            
            tk.Label(fecha_frame, text="üìÖ Fecha:", font=('Arial', 10, 'bold'),
                    bg='#FEF3C7', fg='#92400E').pack(anchor='w', padx=10, pady=(8, 2))
            tk.Label(fecha_frame, text=fecha, font=('Arial', 12, 'bold'),
                    bg='#FEF3C7', fg='#1E3A8A').pack(anchor='w', padx=10, pady=(0, 8))
            
            hora_frame = tk.Frame(info_grid, bg='#FEF3C7', relief='solid', bd=1)
            hora_frame.grid(row=0, column=1, sticky='ew', padx=(10, 0), pady=5)
            
            tk.Label(hora_frame, text="üïê Hora:", font=('Arial', 10, 'bold'),
                    bg='#FEF3C7', fg='#92400E').pack(anchor='w', padx=10, pady=(8, 2))
            tk.Label(hora_frame, text=hora, font=('Arial', 12, 'bold'),
                    bg='#FEF3C7', fg='#1E3A8A').pack(anchor='w', padx=10, pady=(0, 8))
            
            # Doctor
            doctor_frame = tk.Frame(info_section, bg='#E8F6F3', relief='solid', bd=1)
            doctor_frame.pack(fill='x', pady=(10, 5))
            
            tk.Label(doctor_frame, text="üë®‚Äç‚öïÔ∏è Doctor:", font=('Arial', 10, 'bold'),
                    bg='#E8F6F3', fg='#0D7377').pack(anchor='w', padx=15, pady=(8, 2))
            tk.Label(doctor_frame, text=doctor, font=('Arial', 12, 'bold'),
                    bg='#E8F6F3', fg='#16A085').pack(anchor='w', padx=15, pady=(0, 8))
            
            # Motivo actual
            motivo_frame = tk.Frame(info_section, bg='#F0F9FF', relief='solid', bd=1)
            motivo_frame.pack(fill='x', pady=(5, 0))
            
            tk.Label(motivo_frame, text="ÔøΩ Motivo de la Consulta:", font=('Arial', 10, 'bold'),
                    bg='#F0F9FF', fg='#1E40AF').pack(anchor='w', padx=15, pady=(8, 2))
            tk.Label(motivo_frame, text=motivo, font=('Arial', 11),
                    bg='#F0F9FF', fg='#1E3A8A', wraplength=500).pack(anchor='w', padx=15, pady=(0, 8))
            
            # SECCI√ìN: Motivo de cancelaci√≥n
            cancel_section = tk.LabelFrame(scrollable_frame, text="‚ùì Motivo de Cancelaci√≥n", 
                                         font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                         padx=20, pady=15)
            cancel_section.pack(fill='x', pady=(0, 20))
            
            tk.Label(cancel_section, text="Por favor seleccione el motivo de la cancelaci√≥n:", 
                    font=('Arial', 11), bg='#F8FAFC', fg='#64748B').pack(anchor='w', pady=(5, 10))
            
            # Variable para motivo
            motivo_cancel_var = tk.StringVar()
            
            # Opciones de motivo predefinidas
            motivos_frame = tk.Frame(cancel_section, bg='#F8FAFC')
            motivos_frame.pack(fill='x', pady=(0, 15))
            
            motivos_opciones = [
                "Problema de salud que impide asistir",
                "Cambio en horario de trabajo",
                "Emergencia familiar",
                "Viaje imprevisto",
                "Problemas de transporte",
                "Conflicto con otra cita m√©dica",
                "Recuperaci√≥n completa (ya no necesito la consulta)",
                "Otro motivo"
            ]
            
            for motivo_op in motivos_opciones:
                tk.Radiobutton(motivos_frame, text=motivo_op, variable=motivo_cancel_var, value=motivo_op,
                              bg='#F8FAFC', font=('Arial', 10), anchor='w').pack(anchor='w', pady=2)
            
            # Campo de texto para "Otro motivo"
            tk.Label(cancel_section, text="Si seleccion√≥ 'Otro motivo', especifique:", 
                    font=('Arial', 10, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w', pady=(15, 2))
            
            otro_motivo_text = tk.Text(cancel_section, height=3, font=('Arial', 11),
                                     relief='solid', bd=2, bg='white', wrap='word')
            otro_motivo_text.pack(fill='x', pady=(0, 5))
            
            tk.Label(cancel_section, text="Detalle adicional sobre la cancelaci√≥n (opcional)", 
                    font=('Arial', 9), bg='#F8FAFC', fg='#64748B').pack(anchor='w')
            
            # SECCI√ìN: Advertencias importantes
            warning_section = tk.Frame(scrollable_frame, bg='#FEF2F2', relief='solid', bd=2)
            warning_section.pack(fill='x', pady=(0, 20))
            
            warning_content = tk.Frame(warning_section, bg='#FEF2F2')
            warning_content.pack(fill='x', padx=15, pady=12)
            
            tk.Label(warning_content, text="‚ö†Ô∏è IMPORTANTE - POL√çTICA DE CANCELACI√ìN:", 
                    font=('Arial', 11, 'bold'), bg='#FEF2F2', fg='#DC2626').pack(anchor='w')
            
            warning_text = ("‚Ä¢ Las cancelaciones deben realizarse con al menos 24 horas de anticipaci√≥n\n"
                          "‚Ä¢ Cancelaciones tard√≠as pueden incurrir en cargos\n"
                          "‚Ä¢ Esta acci√≥n no se puede deshacer una vez confirmada\n"
                          "‚Ä¢ Para reprogramar, deber√° agendar una nueva cita\n"
                          "‚Ä¢ Se enviar√° notificaci√≥n de cancelaci√≥n al doctor")
            
            tk.Label(warning_content, text=warning_text, 
                    font=('Arial', 9), bg='#FEF2F2', fg='#DC2626',
                    justify='left').pack(anchor='w', pady=(5, 0))
            
            # Funci√≥n para confirmar cancelaci√≥n
            def confirm_cancellation():
                try:
                    # Validar que se haya seleccionado un motivo
                    if not motivo_cancel_var.get():
                        messagebox.showerror("Error", "Debe seleccionar un motivo de cancelaci√≥n")
                        return
                    
                    # Obtener motivo final
                    motivo_final = motivo_cancel_var.get()
                    if motivo_final == "Otro motivo":
                        otro_texto = otro_motivo_text.get('1.0', 'end-1c').strip()
                        if not otro_texto:
                            messagebox.showerror("Error", "Debe especificar el motivo en el campo de texto")
                            return
                        motivo_final = f"Otro motivo: {otro_texto}"
                    else:
                        # Agregar detalles adicionales si los hay
                        otro_texto = otro_motivo_text.get('1.0', 'end-1c').strip()
                        if otro_texto:
                            motivo_final += f" - Detalles: {otro_texto}"
                    
                    # Confirmaci√≥n final
                    if messagebox.askyesno("Confirmar Cancelaci√≥n", 
                                         f"¬øEst√° seguro que desea cancelar la cita?\n\n"
                                         f"Fecha: {fecha}\n"
                                         f"Hora: {hora}\n"
                                         f"Doctor: {doctor}\n\n"
                                         f"Motivo: {motivo_final}\n\n"
                                         f"Esta acci√≥n no se puede deshacer."):
                        
                        # Actualizar estado en la base de datos
                        conn = self.db_manager.get_connection()
                        cur = conn.cursor()
                        
                        cur.execute("""
                            UPDATE citas 
                            SET estado = 'cancelada', 
                                notas = COALESCE(notas, '') || '\n\nCANCELADA - Motivo: ' || ?
                            WHERE id = ?
                        """, (motivo_final, appt_id))
                        
                        conn.commit()
                        cur.close()
                        conn.close()
                        
                        messagebox.showinfo("Cancelaci√≥n Exitosa", 
                                          "‚úÖ La cita ha sido cancelada correctamente.\n\n"
                                          "Se ha enviado notificaci√≥n al doctor.")
                        cancel_window.destroy()
                        self.load_patient_appointments()  # Recargar lista
                        
                except Exception as e:
                    messagebox.showerror("Error", f"Error cancelando la cita: {str(e)}")
            
            # Pack del canvas y scrollbar
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # Configurar scroll con rueda del mouse
            canvas.bind("<MouseWheel>", lambda e: canvas.yview_scroll(int(-1*(e.delta/120)), "units"))
            
            # Panel de botones
            buttons_frame = tk.Frame(cancel_window, bg='#F8FAFC')
            buttons_frame.pack(fill='x', padx=25, pady=(0, 25))
            
            # Botones con mejor dise√±o
            tk.Button(buttons_frame, text="‚Ü©Ô∏è Volver", 
                     command=cancel_window.destroy,
                     bg='#95A5A6', fg='white', font=('Arial', 12, 'bold'),
                     relief='flat', padx=25, pady=12, cursor='hand2').pack(side='right', padx=(10, 0))
            
            tk.Button(buttons_frame, text="‚ùå Confirmar Cancelaci√≥n", 
                     command=confirm_cancellation,
                     bg='#E74C3C', fg='white', font=('Arial', 12, 'bold'),
                     relief='flat', padx=25, pady=12, cursor='hand2').pack(side='right')
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al abrir formulario de cancelaci√≥n: {str(e)}")
            print(f"Error en cancel_my_appointment: {e}")
            import traceback
            traceback.print_exc()

    def create_no_data_placeholder(self):
        """Crear placeholder cuando no hay datos - m√°s compacto"""
        try:
            # Limpiar frame
            for widget in self.scrollable_history_frame.winfo_children():
                widget.destroy()
            
            # Contenedor principal m√°s compacto
            placeholder_container = tk.Frame(self.scrollable_history_frame, bg='white', relief='solid', bd=1)
            placeholder_container.pack(fill='x', padx=20, pady=20)
            
            # Contenido del placeholder
            content_frame = tk.Frame(placeholder_container, bg='white')
            content_frame.pack(fill='x', padx=30, pady=20)
            
            # Icono y mensaje m√°s compacto
            tk.Label(content_frame, text="üìã", font=('Arial', 32), 
                    bg='white', fg='#CBD5E1').pack(pady=(10, 5))
            tk.Label(content_frame, text="No hay registros en tu historial m√©dico", 
                    font=('Arial', 14, 'bold'), bg='white', fg='#64748B').pack()
            tk.Label(content_frame, text="Cuando tengas consultas m√©dicas, aparecer√°n aqu√≠", 
                    font=('Arial', 11), bg='white', fg='#9CA3AF').pack(pady=(5, 10))
            
            # Bot√≥n para agendar cita
            tk.Button(content_frame, text="üìÖ Agendar Nueva Cita", 
                     command=self.open_patient_schedule_dialog,
                     bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                     relief='flat', padx=20, pady=8, cursor='hand2').pack(pady=(10, 5))
            
        except Exception as e:
            print(f"Error creando placeholder: {e}")

    def create_history_card(self, parent, record_data, row_num):
        """Crear una carta moderna para cada registro del historial"""
        try:
            # Frame principal de la carta con sombra visual
            card_frame = tk.Frame(parent, bg='white', relief='solid', bd=1)
            card_frame.pack(fill='x', padx=20, pady=10)
            
            # Determinar color del borde seg√∫n estado
            status = record_data.get('estado', 'Completado')
            border_colors = {
                'Completado': '#059669',
                'En proceso': '#D97706', 
                'Pendiente': '#DC2626',
                'Cancelado': '#6B7280'
            }
            border_color = border_colors.get(status, '#059669')
            
            # Borde superior coloreado
            top_border = tk.Frame(card_frame, bg=border_color, height=4)
            top_border.pack(fill='x')
            
            # Header de la carta
            header_frame = tk.Frame(card_frame, bg='#F8FAFC')
            header_frame.pack(fill='x', padx=15, pady=(10, 0))
            
            # Lado izquierdo del header - Fecha y hora
            header_left = tk.Frame(header_frame, bg='#F8FAFC')
            header_left.pack(side='left', fill='y')
            
            # Fecha grande y prominente
            fecha_str = record_data.get('fecha', 'Fecha no disponible')
            tk.Label(header_left, text=fecha_str, 
                    font=('Arial', 14, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(anchor='w')
            
            # Informaci√≥n del doctor
            doctor_info = f"Dr. {record_data.get('doctor_nombre', '')} {record_data.get('doctor_apellido', '')}"
            especialidad = record_data.get('especialidad', 'Medicina General')
            tk.Label(header_left, text=f"{doctor_info} ‚Ä¢ {especialidad}", 
                    font=('Arial', 10), bg='#F8FAFC', fg='#64748B').pack(anchor='w')
            
            # Lado derecho del header - Estado
            header_right = tk.Frame(header_frame, bg='#F8FAFC')
            header_right.pack(side='right', fill='y')
            
            # Badge de estado
            status_colors = {
                'Completado': ('#059669', '#ECFDF5'),
                'En proceso': ('#D97706', '#FFFBEB'),
                'Pendiente': ('#DC2626', '#FEF2F2'),
                'Cancelado': ('#6B7280', '#F9FAFB')
            }
            bg_color, text_color = status_colors.get(status, ('#059669', '#ECFDF5'))
            
            status_badge = tk.Frame(header_right, bg=text_color, relief='solid', bd=1)
            status_badge.pack(pady=5)
            
            tk.Label(status_badge, text=f"‚óè {status}", 
                    font=('Arial', 9, 'bold'), bg=text_color, fg=bg_color, 
                    padx=12, pady=4).pack()
            
            # Contenido principal de la carta - Tabla de informaci√≥n
            content_frame = tk.Frame(card_frame, bg='white')
            content_frame.pack(fill='x', padx=15, pady=10)
            
            # Crear tabla de informaci√≥n en dos columnas
            info_table = tk.Frame(content_frame, bg='white')
            info_table.pack(fill='x')
            
            # Datos para mostrar en tabla con m√°s informaci√≥n relevante
            table_data = [
                ('üéØ Motivo', record_data.get('motivo_consulta', 'No especificado')[:60] + '...' if len(record_data.get('motivo_consulta', '')) > 60 else record_data.get('motivo_consulta', 'No especificado'), '#7C3AED'),
                ('ü©∫ Diagn√≥stico', record_data.get('diagnostico', 'No especificado')[:60] + '...' if len(record_data.get('diagnostico', '')) > 60 else record_data.get('diagnostico', 'No especificado'), '#1E3A8A'),
                ('ÔøΩ Tratamiento', record_data.get('tratamiento', 'No especificado')[:60] + '...' if len(record_data.get('tratamiento', '')) > 60 else record_data.get('tratamiento', 'No especificado'), '#059669'),
                ('üìù Observaciones', record_data.get('observaciones', 'Sin observaciones')[:80] + '...' if len(record_data.get('observaciones', '')) > 80 else record_data.get('observaciones', 'Sin observaciones'), '#DC2626')
            ]
            
            # Crear filas de la tabla
            for i, (label, value, color) in enumerate(table_data):
                row_frame = tk.Frame(info_table, bg='white')
                row_frame.pack(fill='x', pady=3)
                
                # Label
                label_frame = tk.Frame(row_frame, bg='white', width=120)
                label_frame.pack(side='left', fill='y')
                label_frame.pack_propagate(False)
                
                tk.Label(label_frame, text=label, 
                        font=('Arial', 10, 'bold'), bg='white', fg='#374151', 
                        anchor='w').pack(fill='both', padx=(0, 10))
                
                # Valor
                value_frame = tk.Frame(row_frame, bg='white')
                value_frame.pack(side='left', fill='both', expand=True)
                
                tk.Label(value_frame, text=value, 
                        font=('Arial', 10), bg='white', fg=color, 
                        anchor='w', wraplength=400, justify='left').pack(fill='both')
            
            # Secci√≥n de signos vitales (si est√°n disponibles y no son valores por defecto)
            has_vitals = any([
                record_data.get('presion_arterial') and record_data.get('presion_arterial') not in ['No medida', 'No registrada'],
                record_data.get('peso') and record_data.get('peso') != 'No registrado',
                record_data.get('temperatura') and record_data.get('temperatura') not in ['No medida', 'No registrada'],
                record_data.get('frecuencia_cardiaca') and record_data.get('frecuencia_cardiaca') not in ['No medida', 'No registrada']
            ])
            
            if has_vitals:
                # Separador
                separator = tk.Frame(content_frame, bg='#E5E7EB', height=1)
                separator.pack(fill='x', pady=(10, 5))
                
                # T√≠tulo de signos vitales
                vitals_title = tk.Frame(content_frame, bg='white')
                vitals_title.pack(fill='x', pady=(5, 5))
                tk.Label(vitals_title, text="üíì Signos Vitales:", 
                        font=('Arial', 10, 'bold'), bg='white', fg='#374151').pack(side='left')
                
                # Grid de signos vitales
                vitals_grid = tk.Frame(content_frame, bg='white')
                vitals_grid.pack(fill='x')
                
                vitals_data = []
                if record_data.get('presion_arterial') and record_data.get('presion_arterial') != 'No medida':
                    vitals_data.append(('ü©∏ PA:', record_data.get('presion_arterial')))
                if record_data.get('peso') and record_data.get('peso') != 'No registrado':
                    vitals_data.append(('‚öñÔ∏è Peso:', record_data.get('peso')))
                if record_data.get('temperatura') and record_data.get('temperatura') != 'No medida':
                    vitals_data.append(('üå°Ô∏è Temp:', record_data.get('temperatura')))
                if record_data.get('frecuencia_cardiaca') and record_data.get('frecuencia_cardiaca') != 'No medida':
                    vitals_data.append(('üíì FC:', record_data.get('frecuencia_cardiaca')))
                
                # Mostrar signos vitales en una fila compacta
                vitals_row = tk.Frame(vitals_grid, bg='white')
                vitals_row.pack(fill='x', pady=2)
                
                for i, (label, value) in enumerate(vitals_data):
                    if i > 0:
                        tk.Label(vitals_row, text="‚Ä¢", font=('Arial', 8), 
                                bg='white', fg='#9CA3AF').pack(side='left', padx=(5, 5))
                    
                    vital_item = tk.Frame(vitals_row, bg='white')
                    vital_item.pack(side='left')
                    
                    tk.Label(vital_item, text=label, font=('Arial', 8, 'bold'), 
                            bg='white', fg='#6B7280').pack(side='left')
                    tk.Label(vital_item, text=value, font=('Arial', 8), 
                            bg='white', fg='#059669').pack(side='left', padx=(2, 0))
            
            # Footer de la carta con acciones
            footer_frame = tk.Frame(card_frame, bg='#F8FAFC')
            footer_frame.pack(fill='x', padx=15, pady=(5, 10))
            
            # Botones de acci√≥n
            actions_frame = tk.Frame(footer_frame, bg='#F8FAFC')
            actions_frame.pack(side='right')
            
            # Bot√≥n Ver Detalles
            detail_btn = tk.Button(actions_frame, text="üëÅÔ∏è Ver Detalles", 
                                  command=lambda: self.view_history_detail_card(record_data),
                                  bg='#0B5394', fg='white', font=('Arial', 9, 'bold'),
                                  relief='flat', padx=12, pady=6, cursor='hand2')
            detail_btn.pack(side='right', padx=(5, 0))
            
            # Bot√≥n Exportar PDF (si hay observaciones)
            if record_data.get('observaciones') and len(record_data.get('observaciones', '')) > 0:
                pdf_btn = tk.Button(actions_frame, text="üìÑ PDF", 
                                   command=lambda: self.export_single_record_pdf(record_data),
                                   bg='#DC2626', fg='white', font=('Arial', 9, 'bold'),
                                   relief='flat', padx=12, pady=6, cursor='hand2')
                pdf_btn.pack(side='right', padx=(5, 0))
            
            # Informaci√≥n adicional en el footer
            footer_info = tk.Frame(footer_frame, bg='#F8FAFC')
            footer_info.pack(side='left', fill='y')
            
            # ID del registro (peque√±o)
            if 'id' in record_data:
                tk.Label(footer_info, text=f"ID: {record_data['id']}", 
                        font=('Arial', 8), bg='#F8FAFC', fg='#9CA3AF').pack(anchor='w')
            
            # Hacer la carta clickeable
            def on_card_click(event):
                self.view_history_detail_card(record_data)
            
            # Bind click a todos los elementos de la carta
            for widget in [card_frame, header_frame, content_frame]:
                widget.bind("<Button-1>", on_card_click)
                widget.configure(cursor='hand2')
            
            return card_frame
            
        except Exception as e:
            print(f"Error creando carta de historial: {e}")
            return None

    def view_history_detail_card(self, record_data):
        """Ver detalles completos de un registro desde una carta"""
        try:
            # Crear ventana de detalles
            detail_window = tk.Toplevel(self.root)
            detail_window.title(f"Detalle M√©dico - {record_data.get('fecha', 'Sin fecha')}")
            detail_window.geometry("800x700")
            detail_window.configure(bg='#F8FAFC')
            detail_window.transient(self.root)
            detail_window.grab_set()
            
            # Header de la ventana
            header = tk.Frame(detail_window, bg='#1E3A8A', height=80)
            header.pack(fill='x')
            header.pack_propagate(False)
            
            header_content = tk.Frame(header, bg='#1E3A8A')
            header_content.pack(expand=True, fill='both', padx=20, pady=15)
            
            tk.Label(header_content, text="üìã Detalle Completo del Registro M√©dico", 
                    font=('Arial', 16, 'bold'), bg='#1E3A8A', fg='white').pack(side='left')
            
            # Bot√≥n cerrar
            tk.Button(header_content, text="‚úï Cerrar", 
                     command=detail_window.destroy,
                     bg='#DC2626', fg='white', font=('Arial', 10, 'bold'),
                     relief='flat', padx=15, pady=5).pack(side='right')
            
            # Contenido principal con scroll
            main_frame = tk.Frame(detail_window, bg='#F8FAFC')
            main_frame.pack(fill='both', expand=True, padx=20, pady=20)
            
            # Canvas para scroll
            canvas = tk.Canvas(main_frame, bg='#F8FAFC', highlightthickness=0)
            scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
            scrollable_frame = tk.Frame(canvas, bg='#F8FAFC')
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # Informaci√≥n b√°sica
            basic_info = tk.LabelFrame(scrollable_frame, text="üìä Informaci√≥n B√°sica", 
                                      font=('Arial', 12, 'bold'), bg='white', padx=20, pady=15)
            basic_info.pack(fill='x', pady=(0, 15))
            
            basic_data = [
                ("üìÖ Fecha de Consulta:", record_data.get('fecha', 'No disponible')),
                ("üë®‚Äç‚öïÔ∏è Doctor:", f"Dr. {record_data.get('doctor_nombre', '')} {record_data.get('doctor_apellido', '')}"),
                ("üè• Especialidad:", record_data.get('especialidad', 'Medicina General')),
                ("üìä Estado:", record_data.get('estado', 'Completado')),
                ("üÜî ID Registro:", str(record_data.get('id', 'N/A')))
            ]
            
            for label, value in basic_data:
                row = tk.Frame(basic_info, bg='white')
                row.pack(fill='x', pady=5)
                tk.Label(row, text=label, font=('Arial', 11, 'bold'), 
                        bg='white', fg='#374151', width=20, anchor='w').pack(side='left')
                tk.Label(row, text=value, font=('Arial', 11), 
                        bg='white', fg='#1E3A8A', anchor='w').pack(side='left', padx=(10, 0))
            
            # Diagn√≥stico y Tratamiento
            medical_info = tk.LabelFrame(scrollable_frame, text="ü©∫ Informaci√≥n M√©dica", 
                                        font=('Arial', 12, 'bold'), bg='white', padx=20, pady=15)
            medical_info.pack(fill='x', pady=(0, 15))
            
            # Diagn√≥stico
            diag_frame = tk.Frame(medical_info, bg='white')
            diag_frame.pack(fill='x', pady=5)
            tk.Label(diag_frame, text="üîç Diagn√≥stico:", font=('Arial', 11, 'bold'), 
                    bg='white', fg='#374151').pack(anchor='w')
            tk.Text(diag_frame, height=3, wrap='word', font=('Arial', 10), 
                   bg='#F8FAFC', relief='solid', bd=1).pack(fill='x', pady=(5, 0))
            diag_text = diag_frame.winfo_children()[-1]
            diag_text.insert('1.0', record_data.get('diagnostico', 'No especificado'))
            diag_text.configure(state='disabled')
            
            # Tratamiento
            treat_frame = tk.Frame(medical_info, bg='white')
            treat_frame.pack(fill='x', pady=10)
            tk.Label(treat_frame, text="üíä Tratamiento:", font=('Arial', 11, 'bold'), 
                    bg='white', fg='#374151').pack(anchor='w')
            tk.Text(treat_frame, height=3, wrap='word', font=('Arial', 10), 
                   bg='#F8FAFC', relief='solid', bd=1).pack(fill='x', pady=(5, 0))
            treat_text = treat_frame.winfo_children()[-1]
            treat_text.insert('1.0', record_data.get('tratamiento', 'No especificado'))
            treat_text.configure(state='disabled')
            
            # Medicamentos
            med_frame = tk.Frame(medical_info, bg='white')
            med_frame.pack(fill='x', pady=5)
            tk.Label(med_frame, text="üíâ Medicamentos:", font=('Arial', 11, 'bold'), 
                    bg='white', fg='#374151').pack(anchor='w')
            tk.Text(med_frame, height=2, wrap='word', font=('Arial', 10), 
                   bg='#F8FAFC', relief='solid', bd=1).pack(fill='x', pady=(5, 0))
            med_text = med_frame.winfo_children()[-1]
            med_text.insert('1.0', record_data.get('medicamentos', 'No prescritos'))
            med_text.configure(state='disabled')
            
            # Observaciones del Doctor - Secci√≥n expandida
            if record_data.get('observaciones'):
                obs_info = tk.LabelFrame(scrollable_frame, text="üìù Observaciones del Doctor", 
                                        font=('Arial', 12, 'bold'), bg='white', padx=20, pady=15)
                obs_info.pack(fill='x', pady=(0, 15))
                
                obs_text = tk.Text(obs_info, height=6, wrap='word', font=('Arial', 10), 
                                  bg='#F8FAFC', relief='solid', bd=1)
                obs_text.pack(fill='both', expand=True)
                obs_text.insert('1.0', record_data.get('observaciones', ''))
                obs_text.configure(state='disabled')
            
            # Signos Vitales (solo mostrar si hay datos reales)
            vitals_data = [
                ("ü©∏ Presi√≥n Arterial:", record_data.get('presion_arterial', 'No registrada')),
                ("‚öñÔ∏è Peso:", record_data.get('peso', 'No registrado')),
                ("üìè Altura:", record_data.get('altura', 'No registrada')),
                ("üå°Ô∏è Temperatura:", record_data.get('temperatura', 'No registrada')),
                ("üíì Frecuencia Card√≠aca:", record_data.get('frecuencia_cardiaca', 'No registrada'))
            ]
            
            # Solo mostrar secci√≥n de signos vitales si hay datos √∫tiles
            has_useful_vitals = any([value not in ['No registrada', 'No registrado', 'No medida'] for _, value in vitals_data])
            
            if has_useful_vitals:
                vitals_info = tk.LabelFrame(scrollable_frame, text="üíì Signos Vitales", 
                                           font=('Arial', 12, 'bold'), bg='white', padx=20, pady=15)
                vitals_info.pack(fill='x', pady=(0, 15))
                
                vitals_grid = tk.Frame(vitals_info, bg='white')
                vitals_grid.pack(fill='x')
                
                for i, (label, value) in enumerate(vitals_data):
                    if value not in ['No registrada', 'No registrado', 'No medida']:
                        row = i // 2
                        col = i % 2
                        
                        vital_frame = tk.Frame(vitals_grid, bg='white')
                        vital_frame.grid(row=row, column=col, sticky='ew', padx=(0, 20), pady=5)
                        
                        tk.Label(vital_frame, text=label, font=('Arial', 10, 'bold'), 
                                bg='white', fg='#374151', width=18, anchor='w').pack(side='left')
                        tk.Label(vital_frame, text=value, font=('Arial', 10), 
                                bg='white', fg='#1E3A8A', anchor='w').pack(side='left', padx=(10, 0))
                
                vitals_grid.columnconfigure(0, weight=1)
                vitals_grid.columnconfigure(1, weight=1)
            
            # Informaci√≥n Adicional
            additional_info = tk.LabelFrame(scrollable_frame, text="üìã Informaci√≥n Adicional", 
                                          font=('Arial', 12, 'bold'), bg='white', padx=20, pady=15)
            additional_info.pack(fill='x', pady=(0, 15))
            
            # Motivo de consulta
            if record_data.get('motivo_consulta') and record_data.get('motivo_consulta') != 'No especificado':
                motivo_frame = tk.Frame(additional_info, bg='white')
                motivo_frame.pack(fill='x', pady=5)
                tk.Label(motivo_frame, text="üéØ Motivo de Consulta:", font=('Arial', 11, 'bold'), 
                        bg='white', fg='#374151').pack(anchor='w')
                tk.Text(motivo_frame, height=2, wrap='word', font=('Arial', 10), 
                       bg='#F8FAFC', relief='solid', bd=1).pack(fill='x', pady=(5, 0))
                motivo_text = motivo_frame.winfo_children()[-1]
                motivo_text.insert('1.0', record_data.get('motivo_consulta', ''))
                motivo_text.configure(state='disabled')
            
            # S√≠ntomas
            if record_data.get('sintomas') and record_data.get('sintomas') != 'No registrados':
                sintomas_frame = tk.Frame(additional_info, bg='white')
                sintomas_frame.pack(fill='x', pady=5)
                tk.Label(sintomas_frame, text="ü§í S√≠ntomas Reportados:", font=('Arial', 11, 'bold'), 
                        bg='white', fg='#374151').pack(anchor='w')
                tk.Text(sintomas_frame, height=3, wrap='word', font=('Arial', 10), 
                       bg='#F8FAFC', relief='solid', bd=1).pack(fill='x', pady=(5, 0))
                sintomas_text = sintomas_frame.winfo_children()[-1]
                sintomas_text.insert('1.0', record_data.get('sintomas', ''))
                sintomas_text.configure(state='disabled')
            
            # Ex√°menes solicitados
            if record_data.get('examenes_solicitados') and record_data.get('examenes_solicitados') not in ['Ninguno', 'No especificado']:
                examenes_frame = tk.Frame(additional_info, bg='white')
                examenes_frame.pack(fill='x', pady=5)
                tk.Label(examenes_frame, text="üî¨ Ex√°menes Solicitados:", font=('Arial', 11, 'bold'), 
                        bg='white', fg='#374151').pack(anchor='w')
                tk.Text(examenes_frame, height=2, wrap='word', font=('Arial', 10), 
                       bg='#F8FAFC', relief='solid', bd=1).pack(fill='x', pady=(5, 0))
                examenes_text = examenes_frame.winfo_children()[-1]
                examenes_text.insert('1.0', record_data.get('examenes_solicitados', ''))
                examenes_text.configure(state='disabled')
            
            # Recomendaciones
            if record_data.get('recomendaciones') and record_data.get('recomendaciones') not in ['Ninguna', 'No especificado']:
                recom_frame = tk.Frame(additional_info, bg='white')
                recom_frame.pack(fill='x', pady=5)
                tk.Label(recom_frame, text="üí° Recomendaciones M√©dicas:", font=('Arial', 11, 'bold'), 
                        bg='white', fg='#374151').pack(anchor='w')
                tk.Text(recom_frame, height=3, wrap='word', font=('Arial', 10), 
                       bg='#F8FAFC', relief='solid', bd=1).pack(fill='x', pady=(5, 0))
                recom_text = recom_frame.winfo_children()[-1]
                recom_text.insert('1.0', record_data.get('recomendaciones', ''))
                recom_text.configure(state='disabled')
            
            # Pr√≥xima cita
            if record_data.get('proxima_cita') and record_data.get('proxima_cita') not in ['No programada', 'No especificado']:
                cita_frame = tk.Frame(additional_info, bg='white')
                cita_frame.pack(fill='x', pady=5)
                tk.Label(cita_frame, text="üìÖ Pr√≥xima Cita:", font=('Arial', 11, 'bold'), 
                        bg='white', fg='#374151').pack(anchor='w')
                tk.Label(cita_frame, text=record_data.get('proxima_cita', ''), font=('Arial', 10), 
                        bg='white', fg='#059669').pack(anchor='w', pady=(5, 0))
            
            # Panel de acciones
            actions_panel = tk.Frame(scrollable_frame, bg='white', relief='solid', bd=1)
            actions_panel.pack(fill='x', pady=(15, 0))
            
            actions_header = tk.Frame(actions_panel, bg='#F1F5F9')
            actions_header.pack(fill='x')
            tk.Label(actions_header, text="‚ö° Acciones Disponibles", 
                    font=('Arial', 11, 'bold'), bg='#F1F5F9', fg='#1E3A8A', pady=8).pack()
            
            actions_content = tk.Frame(actions_panel, bg='white')
            actions_content.pack(fill='x', padx=15, pady=10)
            
            # Botones de acci√≥n
            action_buttons = [
                ("üìÑ Exportar PDF", lambda: self.export_single_record_pdf(record_data), "#DC2626"),
                ("üñ®Ô∏è Imprimir", lambda: self.print_single_record(record_data), "#059669"),
                ("üìß Enviar por Email", lambda: self.email_single_record(record_data), "#7C3AED"),
                ("üìã Copiar Info", lambda: self.copy_record_to_clipboard(record_data), "#0B5394")
            ]
            
            for text, command, color in action_buttons:
                btn = tk.Button(actions_content, text=text, command=command,
                               bg=color, fg='white', font=('Arial', 10, 'bold'),
                               relief='flat', padx=15, pady=8, cursor='hand2')
                btn.pack(side='left', padx=(0, 10))
            
            # Pack canvas y scrollbar
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # Bind scroll del mouse
            def _on_mousewheel(event):
                canvas.yview_scroll(int(-1*(event.delta/120)), "units")
            canvas.bind_all("<MouseWheel>", _on_mousewheel)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al mostrar detalles: {str(e)}")
            print(f"Error en view_history_detail_card: {e}")

    def load_patient_medical_history(self):
        """Cargar historial m√©dico en la tabla simple"""
        try:
            # Limpiar tabla
            for item in self.medical_history_tree.get_children():
                self.medical_history_tree.delete(item)
            
            # Inicializar diccionario para almacenar IDs de registros
            self.history_record_ids = {}
            
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Query simplificada
            query = """
                SELECT 
                    hm.id,
                    hm.fecha_consulta,
                    u.nombre || ' ' || u.apellido as doctor_nombre,
                    COALESCE(d.especialidad, 'Medicina General') as especialidad,
                    COALESCE(hm.diagnostico, 'No especificado') as diagnostico,
                    COALESCE(hm.tratamiento, 'No especificado') as tratamiento,
                    COALESCE(hm.observaciones, '') as observaciones,
                    COALESCE(hm.medicamentos, '') as medicamentos
                FROM historial_medico hm
                JOIN usuarios u ON u.id = hm.doctor_id
                LEFT JOIN doctores d ON d.id = hm.doctor_id
                WHERE hm.paciente_id = ?
            """
            
            params = [self.current_user.id]
            
            # Aplicar filtro de b√∫squeda
            if hasattr(self, 'history_search_var') and self.history_search_var.get():
                search_text = f"%{self.history_search_var.get()}%"
                query += " AND (hm.diagnostico LIKE ? OR hm.tratamiento LIKE ? OR hm.observaciones LIKE ?)"
                params.extend([search_text, search_text, search_text])
            
            query += " ORDER BY hm.fecha_consulta DESC"
            
            cursor.execute(query, params)
            records = cursor.fetchall()
            
            # Insertar datos en la tabla
            for record in records:
                try:
                    # Formatear fecha
                    fecha_str = record[1]
                    if isinstance(fecha_str, str) and len(fecha_str) >= 10:
                        from datetime import datetime
                        fecha_obj = datetime.strptime(fecha_str[:10], '%Y-%m-%d')
                        fecha_formatted = fecha_obj.strftime('%d/%m/%Y')
                    else:
                        fecha_formatted = str(fecha_str)
                    
                    # Truncar textos largos
                    diagnostico = record[4][:40] + '...' if len(record[4]) > 40 else record[4]
                    tratamiento = record[5][:35] + '...' if len(record[5]) > 35 else record[5]
                    
                    # Insertar en la tabla
                    item_id = self.medical_history_tree.insert('', 'end', values=(
                        fecha_formatted,
                        record[2],  # doctor_nombre
                        record[3],  # especialidad
                        diagnostico,
                        tratamiento
                    ))
                    
                    # Guardar el ID del registro para acceso posterior
                    self.history_record_ids[item_id] = record[0]
                    
                except Exception as e:
                    print(f"Error procesando registro: {e}")
                    continue
            
            # Actualizar informaci√≥n
            total_records = len(records)
            self.history_info_label.config(
                text=f"üìã Total: {total_records} registros encontrados - Doble clic para ver detalles completos"
            )
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            print(f"Error cargando historial: {e}")
            messagebox.showerror("Error", f"Error al cargar el historial m√©dico: {str(e)}")
            if 'conn' in locals():
                conn.close()

    def filter_medical_history(self, event=None):
        """Aplicar filtros a la tabla de historial m√©dico del paciente"""
        self.load_patient_medical_history()
    
    def create_patient_billing(self, parent):
        """Mis facturas y pagos - Vista simplificada con tabla y tarjetas laterales"""
        # Frame principal
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True)
        
        # Header simple
        header_frame = tk.Frame(main_frame, bg='#1E3A8A', height=70)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Contenido del header
        header_content = tk.Frame(header_frame, bg='#1E3A8A')
        header_content.pack(expand=True, fill='both', padx=30, pady=15)
        
        tk.Label(header_content, text="üí∞ Mis Facturas", 
                font=('Arial', 18, 'bold'), bg='#1E3A8A', fg='white').pack(side='left')
        
        user_info = f"Paciente: {self.current_user.nombre} {self.current_user.apellido}"
        tk.Label(header_content, text=user_info, 
                font=('Arial', 11), bg='#1E3A8A', fg='#CBD5E1').pack(side='right')
        
        # Contenido principal
        content_frame = tk.Frame(main_frame, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True, padx=30, pady=20)
        
        # Contenedor principal horizontal (tarjetas laterales + tabla)
        main_container = tk.Frame(content_frame, bg='#F8FAFC')
        main_container.pack(fill='both', expand=True)
        
        # Panel lateral con tarjetas de estado
        sidebar_frame = tk.Frame(main_container, bg='#F8FAFC', width=250)
        sidebar_frame.pack(side='left', fill='y', padx=(0, 20))
        sidebar_frame.pack_propagate(False)
        
        # T√≠tulo del sidebar
        tk.Label(sidebar_frame, text="üìä Estado de Facturas", 
                font=('Arial', 14, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(pady=(0, 15))
        
        # Crear las tarjetas de estado
        self.create_billing_status_cards(sidebar_frame)
        
        # Panel principal con tabla
        table_frame = tk.Frame(main_container, bg='white', relief='solid', bd=1)
        table_frame.pack(side='right', fill='both', expand=True)
        
        # Header de la tabla
        table_header = tk.Frame(table_frame, bg='#1E3A8A', height=40)
        table_header.pack(fill='x')
        table_header.pack_propagate(False)
        
        tk.Label(table_header, text="üí∞ Mis Facturas - Doble clic para ver detalles", 
                font=('Arial', 12, 'bold'), bg='#1E3A8A', fg='white').pack(expand=True)
        
        # Panel de filtros simple
        filters_frame = tk.Frame(table_frame, bg='white')
        filters_frame.pack(fill='x', padx=15, pady=10)
        
        # B√∫squeda simple
        search_row = tk.Frame(filters_frame, bg='white')
        search_row.pack(fill='x')
        
        tk.Label(search_row, text="ÔøΩ Buscar:", font=('Arial', 10, 'bold'), 
                bg='white', fg='#374151').grid(row=0, column=0, sticky='w', padx=(0, 10))
        
        self.billing_search_var = tk.StringVar()
        search_entry = tk.Entry(search_row, textvariable=self.billing_search_var, 
                               font=('Arial', 10), width=25)
        search_entry.grid(row=0, column=1, sticky='w', padx=(0, 20))
        search_entry.bind('<KeyRelease>', lambda e: self.load_patient_billing_data())
        
        # Filtro por estado
        tk.Label(search_row, text="Estado:", font=('Arial', 10, 'bold'), 
                bg='white', fg='#374151').grid(row=0, column=2, sticky='w', padx=(0, 10))
        
        self.billing_status_filter = ttk.Combobox(search_row, 
                                                values=['Todos', 'pendiente', 'pagado', 'vencido'], 
                                                state='readonly', width=15, font=('Arial', 9))
        self.billing_status_filter.set('Todos')
        self.billing_status_filter.grid(row=0, column=3, sticky='w', padx=(0, 20))
        self.billing_status_filter.bind('<<ComboboxSelected>>', lambda e: self.load_patient_billing_data())
        
        # Bot√≥n actualizar
        tk.Button(search_row, text="ÔøΩ Actualizar", 
                 command=self.load_patient_billing_data,
                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                 relief='flat', padx=15, pady=5).grid(row=0, column=4, sticky='w')
        
        # Contenedor de la tabla con scrollbars
        table_container = tk.Frame(table_frame, bg='white')
        table_container.pack(fill='both', expand=True, padx=15, pady=10)
        
        # Crear Treeview para facturas
        columns = ('N√∫mero', 'Fecha', 'Servicio', 'Monto', 'Estado')
        self.patient_billing_tree = ttk.Treeview(table_container, columns=columns, show='headings', height=12)
        
        # Configurar columnas
        column_widths = {
            'N√∫mero': 120,
            'Fecha': 100,
            'Servicio': 200,
            'Monto': 120,
            'Estado': 100
        }
        
        for col in columns:
            self.patient_billing_tree.heading(col, text=col)
            self.patient_billing_tree.column(col, width=column_widths[col], anchor='center')
        
        # Scrollbars
        v_scrollbar = ttk.Scrollbar(table_container, orient='vertical', command=self.patient_billing_tree.yview)
        h_scrollbar = ttk.Scrollbar(table_container, orient='horizontal', command=self.patient_billing_tree.xview)
        self.patient_billing_tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        
        # Layout
        self.patient_billing_tree.grid(row=0, column=0, sticky='nsew')
        v_scrollbar.grid(row=0, column=1, sticky='ns')
        h_scrollbar.grid(row=1, column=0, sticky='ew')
        
        table_container.grid_rowconfigure(0, weight=1)
        table_container.grid_columnconfigure(0, weight=1)
        
        # Eventos de la tabla
        self.patient_billing_tree.bind('<Double-1>', self.view_billing_detail_simple)
        
        # Panel de informaci√≥n
        info_frame = tk.Frame(table_frame, bg='white', height=50)
        info_frame.pack(fill='x', padx=15, pady=(0, 15))
        info_frame.pack_propagate(False)
        
        self.billing_info_label = tk.Label(info_frame, 
                                         text="ÔøΩ Consejo: Haga doble clic en una factura para ver los detalles completos", 
                                         font=('Arial', 10, 'italic'), bg='white', fg='#64748B')
        self.billing_info_label.pack(expand=True)
        
        # Diccionario para almacenar IDs de facturas
        self.billing_record_ids = {}
        
        # Cargar datos
        self.load_patient_billing_data()

    def create_billing_status_cards(self, parent):
        """Crear tarjetas de estado en el panel lateral"""
        try:
            # Obtener estad√≠sticas de facturas
            billing_stats = self.get_billing_statistics()
            
            # Configuraci√≥n de las tarjetas
            cards_config = [
                {
                    'title': 'Pendientes',
                    'value': str(billing_stats.get('pendientes', 0)),
                    'icon': '‚è≥',
                    'color': '#E74C3C',
                    'bg_color': '#FADBD8'
                },
                {
                    'title': 'Pagadas',
                    'value': str(billing_stats.get('pagadas', 0)),
                    'icon': '‚úÖ',
                    'color': '#27AE60',
                    'bg_color': '#D5F5E3'
                },
                {
                    'title': 'Vencidas',
                    'value': str(billing_stats.get('vencidas', 0)),
                    'icon': 'üö®',
                    'color': '#8E44AD',
                    'bg_color': '#E8DAEF'
                },
                {
                    'title': 'Total',
                    'value': f"RD${billing_stats.get('total_monto', 0):,.0f}",
                    'icon': 'üí∞',
                    'color': '#3498DB',
                    'bg_color': '#D6EAF8'
                }
            ]
            
            # Crear cada tarjeta
            for card in cards_config:
                self.create_status_card(parent, card)
                
        except Exception as e:
            # Tarjeta de error
            error_card = tk.Frame(parent, bg='#FADBD8', relief='solid', bd=1, height=80)
            error_card.pack(fill='x', pady=5)
            error_card.pack_propagate(False)
            
            tk.Label(error_card, text="‚ùå Error cargando estad√≠sticas", 
                    font=('Arial', 10), bg='#FADBD8', fg='#E74C3C').pack(expand=True)

    def create_status_card(self, parent, config):
        """Crear una tarjeta individual de estado"""
        # Frame de la tarjeta
        card_frame = tk.Frame(parent, bg=config['bg_color'], relief='solid', bd=1, height=80)
        card_frame.pack(fill='x', pady=5)
        card_frame.pack_propagate(False)
        
        # Contenido de la tarjeta
        content_frame = tk.Frame(card_frame, bg=config['bg_color'])
        content_frame.pack(expand=True, fill='both', padx=15, pady=10)
        
        # Fila superior con √≠cono y valor
        top_row = tk.Frame(content_frame, bg=config['bg_color'])
        top_row.pack(fill='x')
        
        # √çcono
        tk.Label(top_row, text=config['icon'], font=('Arial', 18), 
                bg=config['bg_color'], fg=config['color']).pack(side='left')
        
        # Valor
        tk.Label(top_row, text=config['value'], font=('Arial', 16, 'bold'), 
                bg=config['bg_color'], fg=config['color']).pack(side='right')
        
        # T√≠tulo
        tk.Label(content_frame, text=config['title'], font=('Arial', 11), 
                bg=config['bg_color'], fg='#2C3E50').pack(anchor='w', pady=(5, 0))

    def get_billing_statistics(self):
        """Obtener estad√≠sticas de facturaci√≥n del paciente actual"""
        try:
            if not self.current_user:
                return {'pendientes': 0, 'pagadas': 0, 'vencidas': 0, 'total_monto': 0}
            
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Obtener estad√≠sticas
            cursor.execute("""
                SELECT 
                    COUNT(CASE WHEN estado = 'pendiente' THEN 1 END) as pendientes,
                    COUNT(CASE WHEN estado = 'pagado' THEN 1 END) as pagadas,
                    COUNT(CASE WHEN estado = 'vencido' THEN 1 END) as vencidas,
                    COALESCE(SUM(monto), 0) as total_monto
                FROM facturas 
                WHERE paciente_id = ?
            """, (self.current_user.id,))
            
            result = cursor.fetchone()
            
            stats = {
                'pendientes': result[0] if result[0] else 0,
                'pagadas': result[1] if result[1] else 0,
                'vencidas': result[2] if result[2] else 0,
                'total_monto': result[3] if result[3] else 0
            }
            
            cursor.close()
            conn.close()
            
            return stats
            
        except Exception as e:
            print(f"Error obteniendo estad√≠sticas de facturaci√≥n: {e}")
            return {'pendientes': 0, 'pagadas': 0, 'vencidas': 0, 'total_monto': 0}

    def get_patient_billing_summary(self):
        """Obtener resumen de facturaci√≥n del paciente actual"""
        try:
            if not self.current_user:
                return {'total_paid': 0, 'total_pending': 0, 'total_invoices': 0, 'month_total': 0}
            
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            patient_id = self.current_user.id
            current_month = datetime.now().strftime('%Y-%m')
            
            # Total pagado
            cursor.execute('''
                SELECT COALESCE(SUM(monto), 0) 
                FROM facturas 
                WHERE paciente_id = ? AND estado IN ('pagada', 'pago_parcial')
            ''', (patient_id,))
            total_paid = cursor.fetchone()[0]
            
            # Total pendiente
            cursor.execute('''
                SELECT COALESCE(SUM(monto), 0) 
                FROM facturas 
                WHERE paciente_id = ? AND estado = 'pendiente'
            ''', (patient_id,))
            total_pending = cursor.fetchone()[0]
            
            # Total facturas
            cursor.execute('SELECT COUNT(*) FROM facturas WHERE paciente_id = ?', (patient_id,))
            total_invoices = cursor.fetchone()[0]
            
            # Total del mes
            cursor.execute('''
                SELECT COALESCE(SUM(monto), 0) 
                FROM facturas 
                WHERE paciente_id = ? AND strftime('%Y-%m', fecha_creacion) = ?
            ''', (patient_id, current_month))
            month_total = cursor.fetchone()[0]
            
            conn.close()
            
            return {
                'total_paid': float(total_paid),
                'total_pending': float(total_pending),
                'total_invoices': total_invoices,
                'month_total': float(month_total)
            }
            
        except Exception as e:
            print(f"Error obteniendo resumen del paciente: {e}")
            return {'total_paid': 0, 'total_pending': 0, 'total_invoices': 0, 'month_total': 0}
    
    def load_patient_billing_data(self, period_filter='Todos', status_filter='Todos'):
        """Cargar facturas del paciente actual en la tabla simplificada"""
        try:
            if not self.current_user or not hasattr(self, 'patient_billing_tree'):
                return
            
            # Limpiar tabla
            for item in self.patient_billing_tree.get_children():
                self.patient_billing_tree.delete(item)
            
            # Limpiar diccionario de IDs
            self.billing_record_ids = {}
            
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Query simplificada
            query = """
                SELECT 
                    f.id,
                    f.numero_factura,
                    f.fecha_creacion,
                    COALESCE(f.concepto, 'Consulta m√©dica') as concepto,
                    f.monto,
                    f.estado,
                    f.fecha_vencimiento
                FROM facturas f
                WHERE f.paciente_id = ?
            """
            
            params = [self.current_user.id]
            
            # Aplicar filtro de b√∫squeda
            if hasattr(self, 'billing_search_var') and self.billing_search_var.get():
                search_text = f"%{self.billing_search_var.get()}%"
                query += " AND (f.numero_factura LIKE ? OR f.concepto LIKE ?)"
                params.extend([search_text, search_text])
            
            # Aplicar filtro de estado
            if hasattr(self, 'billing_status_filter') and self.billing_status_filter.get() != 'Todos':
                query += " AND f.estado = ?"
                params.append(self.billing_status_filter.get())
            
            query += " ORDER BY f.fecha_creacion DESC"
            
            cursor.execute(query, params)
            records = cursor.fetchall()
            
            # Insertar datos en la tabla
            for record in records:
                try:
                    # Formatear fecha
                    fecha_str = record[2]
                    if isinstance(fecha_str, str) and len(fecha_str) >= 10:
                        from datetime import datetime
                        fecha_obj = datetime.strptime(fecha_str[:10], '%Y-%m-%d')
                        fecha_formatted = fecha_obj.strftime('%d/%m/%Y')
                    else:
                        fecha_formatted = str(fecha_str)
                    
                    # Formatear monto
                    monto = f"RD${record[4]:,.0f}" if record[4] else "RD$0"
                    
                    # Truncar concepto si es muy largo
                    concepto = record[3][:30] + '...' if len(record[3]) > 30 else record[3]
                    
                    # Insertar en la tabla
                    item_id = self.patient_billing_tree.insert('', 'end', values=(
                        record[1],  # numero_factura
                        fecha_formatted,
                        concepto,
                        monto,
                        record[5]  # estado
                    ))
                    
                    # Guardar el ID completo del registro
                    self.billing_record_ids[item_id] = record[0]
                    
                    # Colorear filas seg√∫n estado
                    if record[5] == 'vencido':
                        self.patient_billing_tree.set(item_id, 'Estado', 'üö® Vencido')
                    elif record[5] == 'pagado':
                        self.patient_billing_tree.set(item_id, 'Estado', '‚úÖ Pagado')
                    elif record[5] == 'pendiente':
                        self.patient_billing_tree.set(item_id, 'Estado', '‚è≥ Pendiente')
                    
                except Exception as e:
                    print(f"Error procesando factura: {e}")
                    continue
            
            # Actualizar informaci√≥n
            total_records = len(records)
            if hasattr(self, 'billing_info_label'):
                self.billing_info_label.config(
                    text=f"üí∞ Total: {total_records} facturas encontradas - Doble clic para ver detalles"
                )
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            print(f"Error cargando facturas: {e}")
            messagebox.showerror("Error", f"Error al cargar las facturas: {str(e)}")
            if 'conn' in locals():
                conn.close()
    
    def refresh_patient_billing(self):
        """Actualizar datos de facturaci√≥n del paciente"""
        self.load_patient_billing_data()
        messagebox.showinfo("Actualizado", "‚úÖ Mis facturas han sido actualizadas")
    
    def download_patient_invoice(self):
        """Descargar factura seleccionada"""
        selection = self.patient_invoices_tree.selection()
        if not selection:
            messagebox.showwarning("Selecci√≥n", "Seleccione una factura para descargar")
            return
        
        item = self.patient_invoices_tree.item(selection[0])
        invoice_number = item['values'][0]
        
        messagebox.showinfo("Descargar Factura", 
                           f"Descarga de factura: {invoice_number}\n\n" +
                           "La funcionalidad de descarga PDF est√° disponible en el Sistema Completo de Facturaci√≥n")
    
    def view_payment_history(self):
        """Ver historial de pagos del paciente"""
        messagebox.showinfo("Historial de Pagos", 
                           "Su historial completo de pagos incluye:\n\n" +
                           "‚Ä¢ Fechas y montos de pagos\n‚Ä¢ M√©todos de pago utilizados\n‚Ä¢ Comprobantes disponibles\n\n" +
                           "Consulte con secretar√≠a para detalles espec√≠ficos")
    
    def request_account_statement(self):
        """Solicitar estado de cuenta"""
        messagebox.showinfo("Estado de Cuenta", 
                           "Su solicitud de estado de cuenta ha sido registrada.\n\n" +
                           "Recibir√° un reporte detallado por email en las pr√≥ximas 24 horas.\n\n" +
                           "Para solicitudes urgentes, contacte directamente a secretar√≠a")
    
    def billing_inquiry(self):
        """Consulta sobre facturaci√≥n"""
        messagebox.showinfo("Consultas de Facturaci√≥n", 
                           "Para consultas sobre facturaci√≥n puede:\n\n" +
                           "‚Ä¢ Contactar secretar√≠a durante horario de atenci√≥n\n" +
                           "‚Ä¢ Llamar al tel√©fono principal de la cl√≠nica\n" +
                           "‚Ä¢ Solicitar cita con administraci√≥n\n\n" +
                           "Horario: Lunes a Viernes 8:00 AM - 5:00 PM")

    def filter_patient_billing(self):
        """Filtrar facturas del paciente seg√∫n per√≠odo y estado"""
        try:
            period = self.billing_period_filter.get()
            status = self.billing_status_filter.get()
            self.load_patient_billing_data(period_filter=period, status_filter=status)
        except Exception as e:
            print(f"Error filtrando facturas: {e}")
            self.load_patient_billing_data()
    
    def clear_billing_filters(self):
        """Limpiar filtros de facturaci√≥n"""
        try:
            self.billing_period_filter.set('Todos')
            self.billing_status_filter.set('Todos')
            self.load_patient_billing_data()
        except Exception as e:
            print(f"Error limpiando filtros: {e}")
    
    def view_billing_detail(self):
        """Ver detalle de factura seleccionada"""
        try:
            selection = self.patient_billing_tree.selection()
            if not selection:
                messagebox.showwarning("Selecci√≥n", "Por favor seleccione una factura para ver detalles")
                return
            
            item = self.patient_billing_tree.item(selection[0])
            values = item['values']
            
            detail_text = f"""üìÑ DETALLE DE FACTURA
            
üî¢ N√∫mero: {values[0]}
üìÖ Fecha: {values[1]}
üè• Servicio: {values[2]}
üí∞ Monto: {values[3]}
üìä Estado: {values[4]}
üìÖ Vencimiento: {values[5]}

Para m√°s informaci√≥n o dudas sobre esta factura,
contacte a secretar√≠a."""
            
            messagebox.showinfo("Detalle de Factura", detail_text)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error mostrando detalle: {e}")
    
    def download_billing_pdf(self):
        """Descargar PDF de factura seleccionada"""
        try:
            selection = self.patient_billing_tree.selection()
            if not selection:
                messagebox.showwarning("Selecci√≥n", "Por favor seleccione una factura para descargar")
                return
            
            item = self.patient_billing_tree.item(selection[0])
            factura_numero = item['values'][0]
            
            messagebox.showinfo("Descarga PDF", 
                              f"üì• Descargando factura {factura_numero}\n\n" +
                              "La funcionalidad de descarga PDF estar√° disponible pr√≥ximamente.")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error descargando PDF: {e}")
    
    def email_my_billing(self):
        """Enviar factura por email"""
        try:
            selection = self.patient_billing_tree.selection()
            if not selection:
                messagebox.showwarning("Selecci√≥n", "Por favor seleccione una factura para enviar")
                return
            
            item = self.patient_billing_tree.item(selection[0])
            factura_numero = item['values'][0]
            
            messagebox.showinfo("Env√≠o por Email", 
                              f"üìß Enviando factura {factura_numero} por email\n\n" +
                              "La factura ser√° enviada a su correo registrado.")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error enviando email: {e}")
    

    def view_billing_detail_simple(self, event=None):
        """Ver detalles de la factura seleccionada con doble clic"""
        try:
            selection = self.patient_billing_tree.selection()
            if not selection:
                messagebox.showwarning("Advertencia", "Por favor seleccione una factura")
                return
            
            # Obtener datos de la fila seleccionada
            item = self.patient_billing_tree.item(selection[0])
            values = item['values']
            
            # Crear ventana de detalles simple
            detail_window = tk.Toplevel(self.root)
            detail_window.title(f"Detalle de Factura - {values[0]}")
            detail_window.geometry("500x400")
            detail_window.configure(bg='#F8FAFC')
            detail_window.transient(self.root)
            detail_window.grab_set()
            
            # Header
            header = tk.Frame(detail_window, bg='#1E3A8A', height=60)
            header.pack(fill='x')
            header.pack_propagate(False)
            
            tk.Label(header, text="üí∞ Detalle de Factura", 
                    font=('Arial', 14, 'bold'), bg='#1E3A8A', fg='white').pack(expand=True)
            
            # Contenido
            content = tk.Frame(detail_window, bg='#F8FAFC')
            content.pack(fill='both', expand=True, padx=20, pady=20)
            
            # Info frame
            info_frame = tk.LabelFrame(content, text="üìÑ Informaci√≥n", 
                                     font=('Arial', 12, 'bold'), bg='white', padx=15, pady=10)
            info_frame.pack(fill='x', pady=(0, 10))
            
            # Mostrar datos
            datos = [
                ("N√∫mero:", values[0]),
                ("Fecha:", values[1]),
                ("Servicio:", values[2]),
                ("Monto:", values[3]),
                ("Estado:", values[4])
            ]
            
            for label, value in datos:
                row = tk.Frame(info_frame, bg='white')
                row.pack(fill='x', pady=3)
                tk.Label(row, text=label, font=('Arial', 10, 'bold'), 
                        bg='white', fg='#374151', width=12, anchor='w').pack(side='left')
                tk.Label(row, text=value, font=('Arial', 10), 
                        bg='white', fg='#1E3A8A', anchor='w').pack(side='left', padx=(10, 0))
            
            # Botones
            buttons_frame = tk.Frame(content, bg='white', relief='solid', bd=1)
            buttons_frame.pack(fill='x', pady=10)
            
            button_content = tk.Frame(buttons_frame, bg='white')
            button_content.pack(fill='x', padx=15, pady=10)
            
            tk.Button(button_content, text="‚úï Cerrar", 
                     command=detail_window.destroy,
                     bg='#DC2626', fg='white', font=('Arial', 10, 'bold'),
                     relief='flat', padx=15, pady=6).pack(side='right')
            
        except Exception as e:
            messagebox.showerror("Error", f"Error: {str(e)}")

    def show_billing_summary(self):
        """Mostrar resumen de facturaci√≥n"""
        try:
            summary = self.get_patient_billing_summary()
            
            summary_text = f"""üí∞ RESUMEN DE FACTURACI√ìN
            
üí≥ Total Pagado: RD${summary.get('total_paid', 0):,.2f}
‚è≥ Total Pendiente: RD${summary.get('total_pending', 0):,.2f}
üìã Total de Facturas: {summary.get('total_invoices', 0)}
üìÖ Total Este Mes: RD${summary.get('month_total', 0):,.2f}

Estado de cuenta actualizado al {datetime.now().strftime('%d/%m/%Y')}"""
            
            messagebox.showinfo("Resumen Financiero", summary_text)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error mostrando resumen: {e}")
    
    def filter_patient_invoices(self, event=None):
        """Filtrar facturas del paciente"""
        # Implementaci√≥n b√°sica de filtrado para pacientes
        self.load_patient_billing_data()  # Por simplicidad, recargamos
    
    def view_patient_invoice_details(self, event=None):
        """Ver detalles de factura del paciente"""
        selection = self.patient_invoices_tree.selection()
        if not selection:
            return
        
        item = self.patient_invoices_tree.item(selection[0])
        invoice_data = item['values']
        
        details_text = f"""üìÑ DETALLES DE FACTURA

üî¢ N√∫mero: {invoice_data[0]}
üìÖ Fecha: {invoice_data[1]}
üë®‚Äç‚öïÔ∏è Doctor: {invoice_data[2]}
üí≠ Concepto: {invoice_data[3]}
üí∞ Monto: {invoice_data[4]}
üìä Estado: {invoice_data[5]}

üí° Para obtener una copia PDF de esta factura o m√°s detalles, 
consulte con secretar√≠a o use el Sistema Completo de Facturaci√≥n"""
        
        messagebox.showinfo("Detalles de Mi Factura", details_text)
        
    def create_patient_profile(self, parent):
        """Mi perfil para pacientes"""
        main_frame = tk.Frame(parent, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # T√≠tulo
        tk.Label(main_frame, text="Mi Perfil Personal", 
                font=('Arial', 18, 'bold'), bg='#F8FAFC', fg='#1E3A8A').pack(pady=(0, 20))
        
        # Panel principal dividido
        content_frame = tk.Frame(main_frame, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True)
        
        # Panel izquierdo - Informaci√≥n personal
        left_panel = tk.Frame(content_frame, bg='white', relief='solid', bd=1)
        left_panel.pack(side='left', fill='both', expand=True, padx=(0, 10))
        
        # Header del panel izquierdo
        left_header = tk.Frame(left_panel, bg='#0B5394', height=60)
        left_header.pack(fill='x')
        left_header.pack_propagate(False)
        
        tk.Label(left_header, text="üë§ Informaci√≥n Personal", font=('Arial', 14, 'bold'), 
                bg='#0B5394', fg='white').pack(expand=True)
        
        # Contenido del perfil
        profile_content = tk.Frame(left_panel, bg='white')
        profile_content.pack(fill='both', expand=True, padx=20, pady=20)
        
        try:
            patient_data = self.get_patient_profile_data()
            
            # Avatar
            avatar_frame = tk.Frame(profile_content, bg='#FFFFFF', width=120, height=120)
            avatar_frame.pack(pady=(0, 20))
            avatar_frame.pack_propagate(False)
            tk.Label(avatar_frame, text="üë§", font=('Arial', 60), bg='#FFFFFF', fg='#64748B').pack(expand=True)
            
            # Informaci√≥n personal
            personal_fields = [
                ("Nombre completo:", f"{patient_data.get('nombre', '')} {patient_data.get('apellido', '')}"),
                ("Email:", patient_data.get('email', '')),
                ("Tel√©fono:", patient_data.get('telefono', '')),
                ("Fecha de nacimiento:", patient_data.get('fecha_nacimiento', '')),
                ("Direcci√≥n:", patient_data.get('direccion', '')),
                ("N√∫mero de expediente:", patient_data.get('numero_expediente', '')),
                ("Seguro m√©dico:", patient_data.get('seguro_nombre', 'Sin seguro')),
                ("Contacto de emergencia:", patient_data.get('contacto_emergencia', '')),
                ("Tel√©fono de emergencia:", patient_data.get('telefono_emergencia', ''))
            ]
            
            for label, value in personal_fields:
                field_frame = tk.Frame(profile_content, bg='white')
                field_frame.pack(fill='x', pady=5)
                
                tk.Label(field_frame, text=label, font=('Arial', 10, 'bold'), 
                        bg='white', fg='#1E3A8A', width=20, anchor='w').pack(side='left')
                tk.Label(field_frame, text=value or 'No especificado', font=('Arial', 10), 
                        bg='white', fg='#64748B', anchor='w').pack(side='left', padx=(10, 0))
                        
        except Exception as e:
            tk.Label(profile_content, text=f"Error cargando perfil: {str(e)}", 
                    fg='red', bg='white').pack()
        
        # Panel derecho - Configuraciones y estad√≠sticas
        right_panel = tk.Frame(content_frame, bg='white', relief='solid', bd=1)
        right_panel.pack(side='right', fill='both', expand=True, padx=(10, 0))
        
        # Header del panel derecho
        right_header = tk.Frame(right_panel, bg='#0B5394', height=60)
        right_header.pack(fill='x')
        right_header.pack_propagate(False)
        
        tk.Label(right_header, text="‚öôÔ∏è Configuraciones", font=('Arial', 14, 'bold'), 
                bg='#0B5394', fg='white').pack(expand=True)
        
        # Contenido del panel derecho
        config_content = tk.Frame(right_panel, bg='white')
        config_content.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Botones de configuraci√≥n
        config_buttons = [
            ("‚úèÔ∏è Editar Informaci√≥n Personal", self.edit_patient_personal_info, "#0B5394"),
            ("üîë Cambiar Contrase√±a", self.change_patient_password, "#E67E22"),
            ("üìß Configurar Notificaciones", self.configure_notifications, "#16A085"),
            ("üè• Actualizar Seguro M√©dico", self.update_insurance_info, "#1abc9c"),
            ("üë• Contactos de Emergencia", self.manage_emergency_contacts, "#C0392B")
        ]
        
        for text, command, color in config_buttons:
            btn = tk.Button(config_content, text=text, command=command, 
                           bg=color, fg='white', font=('Arial', 10, 'bold'),
                           width=25, height=2)
            btn.pack(fill='x', pady=8)
        
        # Estad√≠sticas del paciente
        stats_frame = tk.LabelFrame(config_content, text="üìä Mis Estad√≠sticas", 
                                  font=('Arial', 11, 'bold'), padx=15, pady=10)
        stats_frame.pack(fill='x', pady=(20, 0))
        
        try:
            patient_stats = self.get_patient_personal_stats()
            
            stats_text = f"""
üìÖ Miembro desde: {patient_stats.get('member_since', 'N/A')}
ü©∫ Total de consultas: {patient_stats.get('total_consultations', 0)}
üë®‚Äç‚öïÔ∏è Doctores consultados: {patient_stats.get('doctors_count', 0)}
üí∞ Total pagado: RD$ {patient_stats.get('total_paid', 0):,.2f}
üìã √öltima consulta: {patient_stats.get('last_consultation', 'Nunca')}
            """
            
            tk.Label(stats_frame, text=stats_text, font=('Arial', 9), 
                    justify='left', bg='white').pack()
                    
        except Exception as e:
            tk.Label(stats_frame, text=f"Error en estad√≠sticas: {str(e)}", 
                    fg='red', bg='white').pack()
    
    # ==================== FUNCIONES DE SOPORTE Y UTILIDADES ====================
    
    # Funciones para obtener datos
    def get_doctor_stats(self):
        """Obtener estad√≠sticas espec√≠ficas del doctor"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            stats = {}
            doctor_id = self.current_user.id
            today = datetime.now().strftime('%Y-%m-%d')
            current_month = datetime.now().strftime('%Y-%m')
            
            # Citas de hoy
            cursor.execute("SELECT COUNT(*) FROM citas WHERE doctor_id = ? AND DATE(fecha_hora) = ?", 
                         (doctor_id, today))
            stats['appointments_today'] = cursor.fetchone()[0]
            
            # Total de pacientes √∫nicos
            cursor.execute("""
                SELECT COUNT(DISTINCT paciente_id) FROM citas WHERE doctor_id = ?
            """, (doctor_id,))
            stats['total_patients'] = cursor.fetchone()[0]
            
            # Ingresos del mes
            cursor.execute("""
                SELECT COALESCE(SUM(tarifa_consulta), 0) FROM citas 
                WHERE doctor_id = ? AND estado = 'completada' 
                AND strftime('%Y-%m', fecha_hora) = ?
            """, (doctor_id, current_month))
            stats['monthly_income'] = cursor.fetchone()[0] or 0
            
            # Consultas del mes
            cursor.execute("""
                SELECT COUNT(*) FROM citas 
                WHERE doctor_id = ? AND estado = 'completada' 
                AND strftime('%Y-%m', fecha_hora) = ?
            """, (doctor_id, current_month))
            stats['consultations_month'] = cursor.fetchone()[0]
            
            # Total de consultas
            cursor.execute("SELECT COUNT(*) FROM citas WHERE doctor_id = ? AND estado = 'completada'", 
                         (doctor_id,))
            stats['total_consultations'] = cursor.fetchone()[0]
            
            # Ingresos totales
            cursor.execute("""
                SELECT COALESCE(SUM(tarifa_consulta), 0) FROM citas 
                WHERE doctor_id = ? AND estado = 'completada'
            """, (doctor_id,))
            stats['total_income'] = cursor.fetchone()[0] or 0
            
            # Promedio mensual (aproximado)
            if stats['total_consultations'] > 0:
                stats['avg_monthly'] = stats['total_consultations'] // 12
            else:
                stats['avg_monthly'] = 0
            
            cursor.close()
            conn.close()
            return stats
            
        except Exception as e:
            print(f"Error obteniendo estad√≠sticas del doctor: {e}")
            return {}
    
    def get_doctor_upcoming_appointments(self):
        """Obtener pr√≥ximas citas del doctor"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            doctor_id = self.current_user.id
            now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            cursor.execute("""
                SELECT c.*, u.nombre || ' ' || u.apellido as paciente_nombre
                FROM citas c
                JOIN usuarios u ON c.paciente_id = u.id
                WHERE c.doctor_id = ? AND c.fecha_hora > ? AND c.estado = 'programada'
                ORDER BY c.fecha_hora ASC
            """, (doctor_id, now))
            
            appointments = []
            for row in cursor.fetchall():
                apt = dict(zip([col[0] for col in cursor.description], row))
                # Formatear fecha/hora
                try:
                    dt = datetime.fromisoformat(apt['fecha_hora'])
                    apt['fecha_hora_formatted'] = dt.strftime('%d/%m/%Y %H:%M')
                except:
                    apt['fecha_hora_formatted'] = apt['fecha_hora']
                appointments.append(apt)
            
            cursor.close()
            conn.close()
            return appointments
            
        except Exception as e:
            print(f"Error obteniendo pr√≥ximas citas: {e}")
            return []
    
    def get_secretaria_stats(self):
        """Obtener estad√≠sticas para secretarias"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            stats = {}
            today = datetime.now().strftime('%Y-%m-%d')
            
            # Citas de hoy
            cursor.execute("SELECT COUNT(*) FROM citas WHERE DATE(fecha_hora) = ?", (today,))
            stats['appointments_today'] = cursor.fetchone()[0]
            
            # Citas pendientes
            cursor.execute("SELECT COUNT(*) FROM citas WHERE estado = 'programada'", )
            stats['pending_appointments'] = cursor.fetchone()[0]
            
            # Facturas pendientes
            cursor.execute("SELECT COUNT(*) FROM facturas WHERE estado = 'pendiente'", )
            stats['pending_invoices'] = cursor.fetchone()[0]
            
            # Nuevos pacientes hoy
            cursor.execute("""
                SELECT COUNT(*) FROM usuarios 
                WHERE tipo_usuario = 'paciente' AND DATE(fecha_creacion) = ?
            """, (today,))
            stats['new_patients_today'] = cursor.fetchone()[0]
            
            cursor.close()
            conn.close()
            return stats
            
        except Exception as e:
            print(f"Error obteniendo estad√≠sticas de secretaria: {e}")
            return {}
    
    def get_today_appointments(self):
        """Obtener citas de hoy para la agenda"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            today = datetime.now().strftime('%Y-%m-%d')
            
            cursor.execute("""
                SELECT c.*, 
                       up.nombre || ' ' || up.apellido as paciente_nombre,
                       ud.nombre || ' ' || ud.apellido as doctor_nombre,
                       TIME(c.fecha_hora) as hora
                FROM citas c
                JOIN usuarios up ON c.paciente_id = up.id
                JOIN usuarios ud ON c.doctor_id = ud.id
                WHERE DATE(c.fecha_hora) = ?
                ORDER BY c.fecha_hora ASC
            """, (today,))
            
            appointments = []
            for row in cursor.fetchall():
                apt = dict(zip([col[0] for col in cursor.description], row))
                appointments.append(apt)
            
            cursor.close()
            conn.close()
            return appointments
            
        except Exception as e:
            print(f"Error obteniendo citas de hoy: {e}")
            return []
    
    def get_patient_info(self):
        """Obtener informaci√≥n del paciente actual con detecci√≥n robusta de esquema."""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()

            patient_id = self.current_user.id

            # Base sin datos de seguro (si todo falla)
            base_sql = (
                "SELECT u.*, p.numero_expediente, p.contacto_emergencia, p.telefono_emergencia "
                "FROM usuarios u LEFT JOIN pacientes p ON u.id = p.id WHERE u.id = ?"
            )

            # 1) Intentar usando seguro_medico_id
            try:
                sql = (
                    "SELECT u.*, p.numero_expediente, p.contacto_emergencia, p.telefono_emergencia, "
                    "p.seguro_medico_id as seguro_medico_id, s.nombre as seguro_nombre "
                    "FROM usuarios u LEFT JOIN pacientes p ON u.id = p.id "
                    "LEFT JOIN seguros_medicos s ON p.seguro_medico_id = s.id WHERE u.id = ?"
                )
                cursor.execute(sql, (patient_id,))
            except Exception:
                # 2) Intentar usando seguro_id (muy legado)
                try:
                    sql = (
                        "SELECT u.*, p.numero_expediente, p.contacto_emergencia, p.telefono_emergencia, "
                        "p.seguro_id as seguro_medico_id, s.nombre as seguro_nombre "
                        "FROM usuarios u LEFT JOIN pacientes p ON u.id = p.id "
                        "LEFT JOIN seguros_medicos s ON p.seguro_id = s.id WHERE u.id = ?"
                    )
                    cursor.execute(sql, (patient_id,))
                except Exception:
                    # 3) Intentar usando texto del seguro_medico
                    try:
                        sql = (
                            "SELECT u.*, p.numero_expediente, p.contacto_emergencia, p.telefono_emergencia, "
                            "p.seguro_medico as seguro_nombre "
                            "FROM usuarios u LEFT JOIN pacientes p ON u.id = p.id WHERE u.id = ?"
                        )
                        cursor.execute(sql, (patient_id,))
                    except Exception:
                        # 4) √öltimo recurso: datos b√°sicos
                        cursor.execute(base_sql, (patient_id,))

            result = cursor.fetchone()
            if result:
                columns = [description[0] for description in cursor.description]
                patient_data = dict(zip(columns, result))
                cursor.close()
                conn.close()
                return patient_data
            else:
                cursor.close()
                conn.close()
                return {}

        except Exception as e:
            print(f"Error obteniendo informaci√≥n del paciente: {e}")
            return {}

    def get_patient_stats(self):
        """Obtener estad√≠sticas del paciente actual"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            patient_id = self.current_user.id
            
            stats = {}
            
            # Pr√≥ximas citas
            cursor.execute("""
                SELECT COUNT(*) FROM citas 
                WHERE paciente_id = ? AND fecha_hora > datetime('now')
                AND estado IN ('confirmada', 'pendiente')
            """, (patient_id,))
            stats['upcoming_appointments'] = cursor.fetchone()[0]
            
            # Total de consultas
            cursor.execute("""
                SELECT COUNT(*) FROM citas WHERE paciente_id = ?
            """, (patient_id,))
            stats['total_consultations'] = cursor.fetchone()[0]
            
            # Facturas pendientes
            cursor.execute("""
                SELECT COUNT(*) FROM facturas 
                WHERE paciente_id = ? AND estado = 'pendiente'
            """, (patient_id,))
            stats['pending_bills'] = cursor.fetchone()[0]
            
            # Doctores visitados (√∫nicos)
            cursor.execute("""
                SELECT COUNT(DISTINCT doctor_id) FROM citas WHERE paciente_id = ?
            """, (patient_id,))
            stats['doctors_visited'] = cursor.fetchone()[0]
            
            cursor.close()
            conn.close()
            return stats
            
        except Exception as e:
            print(f"Error obteniendo estad√≠sticas del paciente: {e}")
            return {
                'upcoming_appointments': 0,
                'total_consultations': 0, 
                'pending_bills': 0,
                'doctors_visited': 0
            }

    def get_patient_info(self, patient_id):
        """Obtener informaci√≥n completa del paciente"""
        try:
            conn = sqlite3.connect('database/medisync.db')
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            # Query base con columnas correctas
            base_sql = """
                SELECT u.id, u.nombre, u.apellido, u.email, u.telefono, u.direccion,
                       u.fecha_nacimiento, u.fecha_creacion, u.fecha_actualizacion,
                       p.numero_expediente, p.tipo_sangre, p.alergias, p.contacto_emergencia,
                       p.telefono_emergencia, p.seguro_medico
                FROM usuarios u 
                LEFT JOIN pacientes p ON u.id = p.id 
                WHERE u.id = ?
            """
            
            try:
                cursor.execute(base_sql, (patient_id,))
            except Exception:
                # Query simplificado si hay problemas
                cursor.execute("SELECT * FROM usuarios WHERE id = ?", (patient_id,))

            row = cursor.fetchone()
            if row:
                try:
                    patient_data = dict(row)
                except Exception:
                    patient_data = dict(zip([col[0] for col in cursor.description], row))
            else:
                patient_data = {}

            cursor.close()
            conn.close()
            return patient_data
        except Exception as e:
            print(f"Error obteniendo informaci√≥n del paciente: {e}")
            return {}

    # ----- Acciones del historial del paciente (stubs seguros) -----
    def view_history_detail(self):
        """Mostrar detalle completo del registro seleccionado del historial con observaciones del doctor"""
        try:
            if not hasattr(self, 'patient_history_tree'):
                return
                
            sel = self.patient_history_tree.selection()
            if not sel:
                messagebox.showinfo('Historial', 'Seleccione un registro para ver el detalle completo')
                return
            
            # Obtener el ID del registro para consultar datos completos
            item = self.patient_history_tree.item(sel[0])
            record_data = item.get('values', [])
            
            if not record_data:
                messagebox.showerror('Error', 'No se pudieron obtener los datos del registro')
                return
            
            # Obtener datos completos de la base de datos incluyendo observaciones
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Buscar el registro por fecha y doctor (m√°s confiable que por ID en este contexto)
            fecha_consulta = record_data[0]  # Fecha formateada
            doctor_nombre = record_data[1]   # Nombre del doctor
            
            cursor.execute("""
                SELECT hm.*, 
                       u.nombre || ' ' || u.apellido as doctor_completo,
                       COALESCE(d.especialidad, 'Medicina General') as especialidad,
                       d.cedula_profesional,
                       hm.observaciones,
                       hm.tipo_consulta,
                       hm.fecha_consulta
                FROM historial_medico hm
                JOIN usuarios u ON u.id = hm.doctor_id
                LEFT JOIN doctores d ON d.id = hm.doctor_id
                WHERE hm.paciente_id = ? AND u.nombre || ' ' || u.apellido = ?
                ORDER BY hm.fecha_consulta DESC
                LIMIT 1
            """, (self.current_user.id, doctor_nombre))
            
            full_record = cursor.fetchone()
            cursor.close()
            conn.close()
            
            if not full_record:
                messagebox.showerror('Error', 'No se encontraron los datos completos del registro')
                return
            
            # Crear ventana de detalle con dise√±o moderno
            detail_window = tk.Toplevel(self.window)
            detail_window.title("üìã Detalle Completo del Historial M√©dico")
            detail_window.geometry("800x700")
            detail_window.configure(bg='#F8FAFC')
            detail_window.resizable(True, True)
            
            # Centrar ventana
            detail_window.transient(self.window)
            detail_window.grab_set()
            
            # Frame principal con scroll
            main_frame = tk.Frame(detail_window, bg='#F8FAFC')
            main_frame.pack(fill='both', expand=True, padx=20, pady=20)
            
            # Header de la ventana
            header_frame = tk.Frame(main_frame, bg='#1E3A8A', relief='flat')
            header_frame.pack(fill='x', pady=(0, 20))
            
            tk.Label(header_frame, text="üìã Registro M√©dico Detallado", 
                    font=('Arial', 16, 'bold'), bg='#1E3A8A', fg='white', pady=15).pack()
            
            # Frame con scroll para contenido
            canvas = tk.Canvas(main_frame, bg='#F8FAFC', highlightthickness=0)
            scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
            scrollable_frame = tk.Frame(canvas, bg='#F8FAFC')
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # Informaci√≥n del doctor
            doctor_section = tk.LabelFrame(scrollable_frame, text="üë®‚Äç‚öïÔ∏è Informaci√≥n del Doctor", 
                                         font=('Arial', 12, 'bold'), bg='white', fg='#1E3A8A',
                                         padx=15, pady=15)
            doctor_section.pack(fill='x', pady=(0, 15))
            
            doctor_info = [
                ("Nombre Completo:", full_record[7]),  # doctor_completo
                ("Especialidad:", full_record[8]),     # especialidad
                ("C√©dula Profesional:", full_record[9] or 'No especificada'),  # cedula_profesional
                ("Fecha de Consulta:", record_data[0])
            ]
            
            for label, value in doctor_info:
                info_frame = tk.Frame(doctor_section, bg='white')
                info_frame.pack(fill='x', pady=3)
                tk.Label(info_frame, text=label, font=('Arial', 10, 'bold'), 
                        bg='white', fg='#374151', width=20, anchor='w').pack(side='left')
                tk.Label(info_frame, text=str(value), font=('Arial', 10), 
                        bg='white', fg='#1E3A8A', anchor='w').pack(side='left', padx=(10, 0))
            
            # Diagn√≥stico y tratamiento
            medical_section = tk.LabelFrame(scrollable_frame, text="ü©∫ Informaci√≥n M√©dica", 
                                          font=('Arial', 12, 'bold'), bg='white', fg='#1E3A8A',
                                          padx=15, pady=15)
            medical_section.pack(fill='x', pady=(0, 15))
            
            # Diagn√≥stico
            diag_frame = tk.Frame(medical_section, bg='white')
            diag_frame.pack(fill='x', pady=(0, 10))
            tk.Label(diag_frame, text="Diagn√≥stico Principal:", font=('Arial', 11, 'bold'), 
                    bg='white', fg='#374151').pack(anchor='w')
            diag_text = tk.Text(diag_frame, height=3, wrap='word', font=('Arial', 10),
                               bg='#F8FAFC', relief='solid', bd=1, state='normal')
            diag_text.insert('1.0', full_record[4] or 'No especificado')
            diag_text.config(state='disabled')
            diag_text.pack(fill='x', pady=(5, 0))
            
            # Tratamiento
            treat_frame = tk.Frame(medical_section, bg='white')
            treat_frame.pack(fill='x', pady=(0, 10))
            tk.Label(treat_frame, text="Tratamiento Indicado:", font=('Arial', 11, 'bold'), 
                    bg='white', fg='#374151').pack(anchor='w')
            treat_text = tk.Text(treat_frame, height=3, wrap='word', font=('Arial', 10),
                                bg='#F8FAFC', relief='solid', bd=1, state='normal')
            treat_text.insert('1.0', full_record[5] or 'No especificado')
            treat_text.config(state='disabled')
            treat_text.pack(fill='x', pady=(5, 0))
            
            # Medicamentos
            med_frame = tk.Frame(medical_section, bg='white')
            med_frame.pack(fill='x', pady=(0, 10))
            tk.Label(med_frame, text="Medicamentos Prescritos:", font=('Arial', 11, 'bold'), 
                    bg='white', fg='#374151').pack(anchor='w')
            med_text = tk.Text(med_frame, height=3, wrap='word', font=('Arial', 10),
                              bg='#F8FAFC', relief='solid', bd=1, state='normal')
            med_text.insert('1.0', full_record[6] or 'Ninguno')
            med_text.config(state='disabled')
            med_text.pack(fill='x', pady=(5, 0))
            
            # Observaciones del doctor (secci√≥n destacada)
            obs_section = tk.LabelFrame(scrollable_frame, text="üìù Observaciones del Doctor", 
                                       font=('Arial', 12, 'bold'), bg='#FFF7ED', fg='#DC2626',
                                       padx=15, pady=15)
            obs_section.pack(fill='x', pady=(0, 15))
            
            tk.Label(obs_section, text="Notas y observaciones cl√≠nicas del doctor:", 
                    font=('Arial', 10, 'italic'), bg='#FFF7ED', fg='#B45309').pack(anchor='w', pady=(0, 10))
            
            obs_text = tk.Text(obs_section, height=6, wrap='word', font=('Arial', 11),
                              bg='white', relief='solid', bd=2, state='normal')
            observaciones = full_record[10] or 'El doctor no registr√≥ observaciones adicionales para esta consulta.'
            obs_text.insert('1.0', observaciones)
            obs_text.config(state='disabled')
            obs_text.pack(fill='both', expand=True)
            
            # Informaci√≥n adicional
            additional_section = tk.LabelFrame(scrollable_frame, text="‚ÑπÔ∏è Informaci√≥n Adicional", 
                                             font=('Arial', 12, 'bold'), bg='white', fg='#1E3A8A',
                                             padx=15, pady=15)
            additional_section.pack(fill='x', pady=(0, 15))
            
            additional_info = [
                ("Tipo de Consulta:", full_record[11] or 'Consulta General'),
                ("Estado del Registro:", 'Activo'),
                ("Fecha de Registro:", full_record[12])
            ]
            
            for label, value in additional_info:
                info_frame = tk.Frame(additional_section, bg='white')
                info_frame.pack(fill='x', pady=3)
                tk.Label(info_frame, text=label, font=('Arial', 10, 'bold'), 
                        bg='white', fg='#374151', width=20, anchor='w').pack(side='left')
                tk.Label(info_frame, text=str(value), font=('Arial', 10), 
                        bg='white', fg='#1E3A8A', anchor='w').pack(side='left', padx=(10, 0))
            
            # Pack canvas y scrollbar
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # Botones de acci√≥n
            buttons_frame = tk.Frame(main_frame, bg='#F8FAFC')
            buttons_frame.pack(fill='x', pady=(15, 0))
            
            tk.Button(buttons_frame, text="üìÑ Imprimir Registro", 
                     command=lambda: self.print_single_record(full_record),
                     bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                     relief='flat', padx=20, pady=8).pack(side='left', padx=(0, 10))
            
            tk.Button(buttons_frame, text="üìß Enviar por Email", 
                     command=lambda: self.email_single_record(full_record),
                     bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                     relief='flat', padx=20, pady=8).pack(side='left', padx=(0, 10))
            
            tk.Button(buttons_frame, text="üìã Copiar al Portapapeles", 
                     command=lambda: self.copy_record_to_clipboard(full_record),
                     bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                     relief='flat', padx=20, pady=8).pack(side='left', padx=(0, 10))
            
            tk.Button(buttons_frame, text="‚ùå Cerrar", 
                     command=detail_window.destroy,
                     bg='#6B7280', fg='white', font=('Arial', 10, 'bold'),
                     relief='flat', padx=20, pady=8).pack(side='right')
            
        except Exception as e:
            messagebox.showerror('Error', f'Error mostrando detalle del historial: {str(e)}')
            print(f"Error en view_history_detail: {e}")

    def print_my_history(self):
        """Imprimir historial (stub b√°sico)"""
        messagebox.showinfo('Historial', 'Impresi√≥n del historial pr√≥ximamente disponible')

    def export_history_pdf(self):
        """Exportar historial a PDF (stub b√°sico)"""
        messagebox.showinfo('Historial', 'Exportaci√≥n a PDF pr√≥ximamente disponible')

    def email_my_history(self):
        """Enviar historial por email (stub b√°sico)"""
        messagebox.showinfo('Historial', 'Env√≠o por email pr√≥ximamente disponible')
    
    def get_patient_upcoming_appointments(self):
        """Obtener pr√≥ximas citas del paciente"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            patient_id = self.current_user.id
            now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            cursor.execute("""
                SELECT c.*, u.nombre || ' ' || u.apellido as doctor_nombre,
                       DATE(c.fecha_hora) as fecha,
                       TIME(c.fecha_hora) as hora,
                       c.motivo
                FROM citas c
                JOIN usuarios u ON c.doctor_id = u.id
                WHERE c.paciente_id = ? AND c.fecha_hora > ? 
                AND c.estado IN ('confirmada', 'pendiente')
                ORDER BY c.fecha_hora ASC
                LIMIT 5
            """, (patient_id, now))
            
            appointments = []
            for row in cursor.fetchall():
                apt = dict(zip([col[0] for col in cursor.description], row))
                # Ajustar nombres de campos para compatibilidad
                apt['doctor'] = apt.get('doctor_nombre', 'N/A')
                appointments.append(apt)
            
            cursor.close()
            conn.close()
            return appointments
            
        except Exception as e:
            print(f"Error obteniendo pr√≥ximas citas del paciente: {e}")
            return []
    
    def get_patient_reminders(self):
        """Obtener recordatorios del paciente"""
        # Esta funci√≥n puede expandirse para incluir recordatorios espec√≠ficos
        # Por ahora devolvemos recordatorios b√°sicos basados en citas pr√≥ximas
        try:
            reminders = []
            upcoming = self.get_patient_upcoming_appointments()
            
            for apt in upcoming:
                try:
                    apt_date = datetime.fromisoformat(apt['fecha_hora'])
                    days_until = (apt_date - datetime.now()).days
                    
                    if days_until <= 1:
                        reminders.append({
                            'message': f"Tienes una cita ma√±ana con Dr. {apt['doctor_nombre']} a las {apt.get('hora_formatted', 'N/A')}"
                        })
                    elif days_until <= 7:
                        reminders.append({
                            'message': f"Tienes una cita en {days_until} d√≠as con Dr. {apt['doctor_nombre']}"
                        })
                except:
                    continue
            
            return reminders
            
        except Exception as e:
            print(f"Error obteniendo recordatorios: {e}")
            return []
    
    # Funciones placeholder para botones (implementar seg√∫n necesidades)
    def new_appointment_quick(self):
        """Abrir ventana de nueva cita"""
        self.new_appointment_window()
    
    def new_patient_quick(self):
        messagebox.showinfo("Acci√≥n", "Funcionalidad de nuevo paciente r√°pido - En desarrollo")
    
    def process_payment_quick(self):
        """Acceso r√°pido al sistema de facturaci√≥n para procesamiento de pagos"""
        self.switch_tab("Facturaci√≥n Avanzada")
        messagebox.showinfo("Sistema de Facturaci√≥n", 
                           "üöÄ Accediendo al sistema de facturaci√≥n integrado\n\n" +
                           "Desde aqu√≠ podr√°:\n" +
                           "‚Ä¢ Procesar pagos completos\n" +
                           "‚Ä¢ Calcular cambio y faltante\n" +
                           "‚Ä¢ Generar PDFs autom√°ticamente")
    
    def generate_invoice_quick(self):
        """Acceso r√°pido al sistema de facturaci√≥n para generar facturas"""
        self.switch_tab("Facturaci√≥n Avanzada")
        messagebox.showinfo("Sistema de Facturaci√≥n", 
                           "üöÄ Accediendo al sistema de facturaci√≥n integrado\n\n" +
                           "Desde aqu√≠ podr√°:\n" +
                           "‚Ä¢ Crear facturas completas\n" +
                           "‚Ä¢ Seleccionar servicios m√©dicos\n" +
                           "‚Ä¢ Generar PDFs profesionales\n" +
                           "‚Ä¢ Procesar pagos en tiempo real")
    
    def manage_waiting_list(self):
        messagebox.showinfo("Acci√≥n", "Gesti√≥n de lista de espera - En desarrollo")
    
    def daily_report(self):
        messagebox.showinfo("Acci√≥n", "Reporte diario - En desarrollo")
    
    def filter_doctor_appointments(self, event=None):
        self.load_doctor_appointments()
    
    def load_doctor_appointments(self):
        """Cargar citas del doctor"""
        try:
            # Limpiar tabla
            for item in self.doctor_appointments_tree.get_children():
                self.doctor_appointments_tree.delete(item)
            
            # Obtener citas seg√∫n filtro
            filter_value = self.appointment_filter.get()
            doctor_id = self.current_user.id
            
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Construir query seg√∫n filtro
            today = datetime.now().strftime('%Y-%m-%d')
            where_clause = "WHERE c.doctor_id = ?"
            params = [doctor_id]
            
            if filter_value == 'Hoy':
                where_clause += " AND DATE(c.fecha_hora) = ?"
                params.append(today)
            elif filter_value == 'Esta Semana':
                start_week = datetime.now() - timedelta(days=datetime.now().weekday())
                end_week = start_week + timedelta(days=6)
                where_clause += " AND DATE(c.fecha_hora) BETWEEN ? AND ?"
                params.extend([start_week.strftime('%Y-%m-%d'), end_week.strftime('%Y-%m-%d')])
            elif filter_value == 'Este Mes':
                current_month = datetime.now().strftime('%Y-%m')
                where_clause += " AND strftime('%Y-%m', c.fecha_hora) = ?"
                params.append(current_month)
            
            cursor.execute(f"""
                SELECT c.fecha_hora, u.nombre || ' ' || u.apellido as paciente_nombre,
                       c.motivo, c.estado, c.duracion_minutos
                FROM citas c
                JOIN usuarios u ON c.paciente_id = u.id
                {where_clause}
                ORDER BY c.fecha_hora DESC
            """, params)
            
            for row in cursor.fetchall():
                # Formatear fecha/hora
                fecha_hora = row[0]
                try:
                    dt = datetime.fromisoformat(fecha_hora)
                    fecha_hora_formatted = dt.strftime('%d/%m/%Y %H:%M')
                except:
                    fecha_hora_formatted = fecha_hora
                
                self.doctor_appointments_tree.insert('', 'end', values=(
                    fecha_hora_formatted, row[1], row[2], row[3], 
                    f"{row[4]} min" if row[4] else 'N/A', 'Ver'
                ))
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error cargando citas: {str(e)}")
    
    def load_doctor_patients(self):
        """Cargar pacientes del doctor"""
        try:
            # Limpiar tabla
            for item in self.doctor_patients_tree.get_children():
                self.doctor_patients_tree.delete(item)
            
            doctor_id = self.current_user.id
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT DISTINCT u.nombre, u.apellido, u.email, u.telefono,
                       MAX(c.fecha_hora) as ultima_consulta,
                       CASE WHEN u.activo THEN 'Activo' ELSE 'Inactivo' END as estado
                FROM usuarios u
                JOIN citas c ON u.id = c.paciente_id
                WHERE c.doctor_id = ? AND u.tipo_usuario = 'paciente'
                GROUP BY u.id, u.nombre, u.apellido, u.email, u.telefono, u.activo
                ORDER BY MAX(c.fecha_hora) DESC
            """, (doctor_id,))
            
            for row in cursor.fetchall():
                # Formatear √∫ltima consulta
                ultima_consulta = row[4]
                if ultima_consulta:
                    try:
                        dt = datetime.fromisoformat(ultima_consulta)
                        ultima_consulta_formatted = dt.strftime('%d/%m/%Y')
                    except:
                        ultima_consulta_formatted = ultima_consulta
                else:
                    ultima_consulta_formatted = 'Nunca'
                
                self.doctor_patients_tree.insert('', 'end', values=(
                    row[0], row[1], row[2], row[3], ultima_consulta_formatted, row[5]
                ))
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error cargando pacientes: {str(e)}")
    
    def load_medical_patients(self):
        """Cargar pacientes para historiales m√©dicos"""
        try:
            # Limpiar listbox
            self.medical_patients_listbox.delete(0, tk.END)
            
            doctor_id = self.current_user.id
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT DISTINCT u.id, u.nombre || ' ' || u.apellido as nombre_completo
                FROM usuarios u
                JOIN citas c ON u.id = c.paciente_id
                WHERE c.doctor_id = ? AND u.tipo_usuario = 'paciente'
                ORDER BY nombre_completo
            """, (doctor_id,))
            
            for row in cursor.fetchall():
                self.medical_patients_listbox.insert(tk.END, f"{row[1]} (ID: {row[0]})")
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error cargando pacientes: {str(e)}")
    
    # M√°s funciones placeholder para completar la funcionalidad
    def add_appointment_notes(self): 
        messagebox.showinfo("Acci√≥n", "Agregar notas - En desarrollo")
    def search_patients(self, event=None): 
        messagebox.showinfo("Acci√≥n", "Buscar pacientes - En desarrollo")
    def view_patient_profile(self): 
        messagebox.showinfo("Acci√≥n", "Ver perfil de paciente - En desarrollo")
    def view_medical_history(self): 
        messagebox.showinfo("Acci√≥n", "Ver historial m√©dico - En desarrollo")
    def schedule_appointment(self): 
        messagebox.showinfo("Acci√≥n", "Programar cita - En desarrollo")
    def load_patient_medical_records(self, event=None): 
        messagebox.showinfo("Acci√≥n", "Cargar historiales m√©dicos - En desarrollo")
    
    # ==================== FUNCIONES HISTORIAL M√âDICO ====================
    
    def load_patients_for_medical_history(self):
        """Cargar lista de pacientes para historial m√©dico"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Obtener filtro de b√∫squeda
            search_term = getattr(self, 'patient_search_var', tk.StringVar()).get().lower()
            
            # Query base
            query = """
                SELECT u.id, u.nombre, u.apellido, u.email, u.telefono, u.fecha_nacimiento,
                       CASE 
                           WHEN u.fecha_nacimiento IS NOT NULL 
                           THEN CAST((julianday('now') - julianday(u.fecha_nacimiento)) / 365.25 AS INTEGER)
                           ELSE 0 
                       END as edad
                FROM usuarios u 
                WHERE u.tipo_usuario = 'paciente' AND u.activo = 1
            """
            
            params = []
            if search_term:
                query += " AND (LOWER(u.nombre) LIKE ? OR LOWER(u.apellido) LIKE ? OR LOWER(u.email) LIKE ?)"
                search_pattern = f"%{search_term}%"
                params.extend([search_pattern, search_pattern, search_pattern])
            
            query += " ORDER BY u.apellido, u.nombre"
            
            cursor.execute(query, params)
            patients = cursor.fetchall()
            
            # Limpiar tree
            for item in self.patients_medical_tree.get_children():
                self.patients_medical_tree.delete(item)
            
            # Agregar pacientes
            for patient in patients:
                # Convertir Row object a valores individuales
                patient_values = (
                    patient[0],  # id
                    patient[1],  # nombre
                    patient[2],  # apellido
                    patient[6],  # edad
                    patient[4] or "No especificado"  # telefono
                )
                self.patients_medical_tree.insert('', 'end', values=patient_values)
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al cargar pacientes: {str(e)}")
    
    def search_patients_medical(self, event=None):
        """Buscar pacientes en historial m√©dico"""
        self.load_patients_for_medical_history()
    
    def on_patient_select_medical(self, event):
        """Manejar selecci√≥n de paciente en historial m√©dico"""
        selection = self.patients_medical_tree.selection()
        if selection:
            item = self.patients_medical_tree.item(selection[0])
            values = item['values']
            
            if len(values) >= 3:
                self.selected_patient_id = values[0]
                patient_name = f"{values[1]} {values[2]}"
                
                # Actualizar header
                self.patient_name_label.config(text=f"üìã Historial de {patient_name}")
                
                # Mostrar informaci√≥n del paciente
                self.show_patient_info_medical(values)
                
                # Cargar registros m√©dicos del paciente
                self.load_medical_records_for_patient(self.selected_patient_id)
            else:
                messagebox.showerror("Error", "Datos de paciente inv√°lidos")
        else:
            self.selected_patient_id = None
            self.show_default_medical_info()
    
    def show_patient_info_medical(self, patient_data):
        """Mostrar informaci√≥n del paciente seleccionado"""
        # Limpiar frame
        for widget in self.patient_info_frame.winfo_children():
            widget.destroy()
        
        # Crear tarjeta de informaci√≥n
        info_card = tk.Frame(self.patient_info_frame, bg='#FFFFFF', relief='solid', bd=1)
        info_card.pack(fill='x', pady=5)
        
        # Header de la tarjeta
        card_header = tk.Frame(info_card, bg='#0B5394', height=30)
        card_header.pack(fill='x')
        card_header.pack_propagate(False)
        
        tk.Label(card_header, text="üë§ Informaci√≥n del Paciente", font=('Arial', 10, 'bold'), 
                bg='#0B5394', fg='white').pack(expand=True)
        
        # Contenido de la tarjeta
        card_content = tk.Frame(info_card, bg='#FFFFFF')
        card_content.pack(fill='x', padx=10, pady=8)
        
        # Informaci√≥n b√°sica
        info_items = [
            ("ID:", str(patient_data[0])),
            ("Nombre:", f"{patient_data[1]} {patient_data[2]}"),
            ("Edad:", f"{patient_data[3]} a√±os" if patient_data[3] else "No especificada"),
            ("Tel√©fono:", patient_data[4] or "No especificado")
        ]
        
        for label, value in info_items:
            row = tk.Frame(card_content, bg='#FFFFFF')
            row.pack(fill='x', pady=1)
            
            tk.Label(row, text=label, font=('Arial', 9, 'bold'), bg='#FFFFFF', width=12, anchor='w').pack(side='left')
            tk.Label(row, text=value, font=('Arial', 9), bg='#FFFFFF', anchor='w').pack(side='left', padx=(5, 0))
    
    def show_default_medical_info(self):
        """Mostrar informaci√≥n por defecto cuando no hay paciente seleccionado"""
        # Limpiar frames
        for widget in self.patient_info_frame.winfo_children():
            widget.destroy()
        
        # Limpiar registros m√©dicos
        for item in self.medical_records_tree.get_children():
            self.medical_records_tree.delete(item)
        
        # Mensaje por defecto
        default_label = tk.Label(self.patient_info_frame, 
                               text="üëÜ Seleccione un paciente de la lista\npara ver su historial m√©dico", 
                               font=('Arial', 11), bg='#FFFFFF', fg='#64748B', 
                               justify='center', pady=20)
        default_label.pack(fill='x')
        
        # Actualizar header
        self.patient_name_label.config(text="üìã Historial M√©dico")
    
    def load_medical_records_for_patient(self, patient_id):
        """Cargar registros m√©dicos del paciente seleccionado"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            query = """
                SELECT hm.id, hm.fecha_consulta, hm.tipo_consulta, 
                       (d.nombre || ' ' || d.apellido) as doctor,
                       hm.diagnostico, hm.estado
                FROM historial_medico hm
                JOIN usuarios d ON hm.doctor_id = d.id
                WHERE hm.paciente_id = ?
                ORDER BY hm.fecha_consulta DESC
            """
            
            cursor.execute(query, (patient_id,))
            records = cursor.fetchall()
            
            # Limpiar tree
            for item in self.medical_records_tree.get_children():
                self.medical_records_tree.delete(item)
            
            # Agregar registros
            for record in records:
                # Formatear fecha
                fecha = record[1][:10] if record[1] else "N/A"
                self.medical_records_tree.insert('', 'end', values=(
                    record[0], fecha, record[2] or "Consulta", 
                    record[3], record[4] or "Sin diagn√≥stico", 
                    record[5] or "Pendiente"
                ))
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al cargar registros m√©dicos: {str(e)}")
    
    def on_medical_record_select(self, event):
        """Manejar selecci√≥n de registro m√©dico"""
        selection = self.medical_records_tree.selection()
        if selection:
            item = self.medical_records_tree.item(selection[0])
            self.selected_medical_record_id = item['values'][0]
        else:
            self.selected_medical_record_id = None
    
    def add_medical_record(self):
        """Agregar nuevo registro m√©dico"""
        if not self.selected_patient_id:
            messagebox.showwarning("Advertencia", "Por favor seleccione un paciente")
            return
        
        self.open_medical_record_form()
    
    def open_medical_record_form(self, edit_mode=False):
        """Abrir formulario para crear/editar registro m√©dico - Dise√±o Premium"""
        form_window = tk.Toplevel()
        title = "Editar Consulta" if edit_mode else "Nueva Consulta M√©dica"
        form_window.title(f"{title} - MEDISYNC")
        form_window.geometry("900x750")
        form_window.configure(bg='#f0f4f7')
        form_window.resizable(False, False)
        
        # Centrar ventana
        form_window.transient(self.root)
        form_window.grab_set()
        self.center_window(form_window, 900, 750)
        
        # Header Premium con gradiente visual
        header_frame = tk.Frame(form_window, bg='#2c5aa0', height=80)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Container del header
        header_container = tk.Frame(header_frame, bg='#2c5aa0')
        header_container.pack(expand=True, fill='both', padx=30, pady=15)
        
        # Icono y t√≠tulo del header
        icon = "‚úèÔ∏è" if edit_mode else "ü©∫"
        icon_label = tk.Label(header_container, text=icon, font=('Arial', 24), 
                             bg='#2c5aa0', fg='white')
        icon_label.pack(side='left')
        
        title_label = tk.Label(header_container, text=title, font=('Arial', 20, 'bold'), 
                              bg='#2c5aa0', fg='white')
        title_label.pack(side='left', padx=(15, 0))
        
        # Subt√≠tulo
        subtitle = "Edici√≥n de registro m√©dico" if edit_mode else "Registro de nueva consulta m√©dica"
        subtitle_label = tk.Label(header_container, text=subtitle, font=('Arial', 11), 
                                 bg='#2c5aa0', fg='#a8c5e8')
        subtitle_label.pack(side='right')
        
        # Variables del formulario
        form_vars = {
            'fecha_consulta': tk.StringVar(value=datetime.now().strftime('%Y-%m-%d')),
            'tipo_consulta': tk.StringVar(value='Consulta General'),
            'motivo_consulta': tk.StringVar(),
            'sintomas': tk.StringVar(),
            'diagnostico': tk.StringVar(),
            'tratamiento': tk.StringVar(),
            'medicamentos': tk.StringVar(),
            'observaciones': tk.StringVar(),
            'proxima_cita': tk.StringVar(),
            'estado': tk.StringVar(value='Completada')
        }
        
        # Scrollable content
        main_canvas = tk.Canvas(form_window, bg='#f0f4f7', highlightthickness=0)
        scrollbar = ttk.Scrollbar(form_window, orient="vertical", command=main_canvas.yview)
        scrollable_frame = tk.Frame(main_canvas, bg='#f0f4f7')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all"))
        )
        
        main_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        main_canvas.configure(yscrollcommand=scrollbar.set)
        
        # Contenido principal con padding elegante
        content_frame = tk.Frame(scrollable_frame, bg='#f0f4f7')
        content_frame.pack(fill='both', expand=True, padx=40, pady=30)
        
        # ========== SECCI√ìN 1: INFORMACI√ìN DEL PACIENTE ==========
        patient_container = tk.Frame(content_frame, bg='white', relief='solid', bd=1)
        patient_container.pack(fill='x', pady=(0, 20))
        
        # Header de la secci√≥n paciente
        patient_header = tk.Frame(patient_container, bg='#F8FAFC', height=50)
        patient_header.pack(fill='x')
        patient_header.pack_propagate(False)
        
        tk.Label(patient_header, text="üë§", font=('Arial', 20), bg='#F8FAFC', fg='#2c5aa0').pack(side='left', padx=(20, 10), pady=12)
        tk.Label(patient_header, text="Paciente", font=('Arial', 14, 'bold'), bg='#F8FAFC', fg='#2c5aa0').pack(side='left', pady=12)
        
        # Contenido del paciente
        patient_content = tk.Frame(patient_container, bg='white')
        patient_content.pack(fill='x', padx=25, pady=20)
        
        selection = self.patients_medical_tree.selection()
        if selection:
            item = self.patients_medical_tree.item(selection[0])
            patient_name = f"{item['values'][1]} {item['values'][2]}"
            
            # Informaci√≥n del paciente con estilo
            patient_info_frame = tk.Frame(patient_content, bg='#f8fffe', relief='solid', bd=1, padx=15, pady=12)
            patient_info_frame.pack(fill='x')
            
            tk.Label(patient_info_frame, text=f"Paciente: {patient_name}", 
                    font=('Arial', 12, 'bold'), bg='#f8fffe', fg='#2c5aa0').pack(anchor='w')
            
            # Informaci√≥n adicional del paciente
            edad_info = f"Edad: {item['values'][3]} a√±os" if len(item['values']) > 3 else ""
            if edad_info:
                tk.Label(patient_info_frame, text=edad_info, 
                        font=('Arial', 10), bg='#f8fffe', fg='#5a7a92').pack(anchor='w')
        
        # ========== SECCI√ìN 2: DATOS B√ÅSICOS DE LA CONSULTA ==========
        basic_container = tk.Frame(content_frame, bg='white', relief='solid', bd=1)
        basic_container.pack(fill='x', pady=(0, 20))
        
        # Header de datos b√°sicos
        basic_header = tk.Frame(basic_container, bg='#F8FAFC', height=50)
        basic_header.pack(fill='x')
        basic_header.pack_propagate(False)
        
        tk.Label(basic_header, text="üìÖ", font=('Arial', 20), bg='#F8FAFC', fg='#2c5aa0').pack(side='left', padx=(20, 10), pady=12)
        tk.Label(basic_header, text="Datos de la Consulta", font=('Arial', 14, 'bold'), bg='#F8FAFC', fg='#2c5aa0').pack(side='left', pady=12)
        
        # Grid para datos b√°sicos
        basic_content = tk.Frame(basic_container, bg='white')
        basic_content.pack(fill='x', padx=25, pady=20)
        
        basic_grid = tk.Frame(basic_content, bg='white')
        basic_grid.pack(fill='x')
        
        # Fecha y Tipo en la misma fila con mejor espaciado
        tk.Label(basic_grid, text="Fecha:", font=('Arial', 11, 'bold'), bg='white', fg='#2c5aa0').grid(row=0, column=0, sticky='w', pady=8, padx=(0, 10))
        
        fecha_frame = tk.Frame(basic_grid, bg='white')
        fecha_frame.grid(row=0, column=1, sticky='ew', padx=(0, 30), pady=8)
        
        fecha_entry = tk.Entry(fecha_frame, textvariable=form_vars['fecha_consulta'], 
                              font=('Arial', 11), width=12, relief='solid', bd=1, bg='#fafafa')
        fecha_entry.pack(side='left')
        
        tk.Label(basic_grid, text="Tipo:", font=('Arial', 11, 'bold'), bg='white', fg='#2c5aa0').grid(row=0, column=2, sticky='w', pady=8, padx=(0, 10))
        
        tipo_combo = ttk.Combobox(basic_grid, textvariable=form_vars['tipo_consulta'], 
                                values=['Consulta General', 'Consulta Especializada', 'Emergencia', 'Control', 'Revisi√≥n'], 
                                state='readonly', width=22, font=('Arial', 11))
        tipo_combo.grid(row=0, column=3, sticky='ew', pady=8)
        
        basic_grid.columnconfigure(1, weight=1)
        basic_grid.columnconfigure(3, weight=2)
        
        # ========== SECCI√ìN 3: INFORMACI√ìN M√âDICA DETALLADA ==========
        medical_container = tk.Frame(content_frame, bg='white', relief='solid', bd=1)
        medical_container.pack(fill='x', pady=(0, 20))
        
        # Header de informaci√≥n m√©dica
        medical_header = tk.Frame(medical_container, bg='#F8FAFC', height=50)
        medical_header.pack(fill='x')
        medical_header.pack_propagate(False)
        
        tk.Label(medical_header, text="üîç", font=('Arial', 20), bg='#F8FAFC', fg='#2c5aa0').pack(side='left', padx=(20, 10), pady=12)
        tk.Label(medical_header, text="Informaci√≥n M√©dica", font=('Arial', 14, 'bold'), bg='#F8FAFC', fg='#2c5aa0').pack(side='left', pady=12)
        
        # Contenido m√©dico
        medical_content = tk.Frame(medical_container, bg='white')
        medical_content.pack(fill='x', padx=25, pady=20)
        
        # Motivo de consulta con estilo mejorado
        motivo_section = tk.Frame(medical_content, bg='white')
        motivo_section.pack(fill='x', pady=(0, 15))
        
        tk.Label(motivo_section, text="Motivo de la Consulta", font=('Arial', 11, 'bold'), 
                bg='white', fg='#2c5aa0').pack(anchor='w', pady=(0, 5))
        
        motivo_text = tk.Text(motivo_section, height=3, font=('Arial', 11), wrap='word',
                             relief='solid', bd=1, bg='#fafafa', padx=10, pady=8)
        motivo_text.pack(fill='x')
        
        # S√≠ntomas
        sintomas_section = tk.Frame(medical_content, bg='white')
        sintomas_section.pack(fill='x', pady=(0, 15))
        
        tk.Label(sintomas_section, text="S√≠ntomas Observados", font=('Arial', 11, 'bold'), 
                bg='white', fg='#2c5aa0').pack(anchor='w', pady=(0, 5))
        
        sintomas_text = tk.Text(sintomas_section, height=3, font=('Arial', 11), wrap='word',
                               relief='solid', bd=1, bg='#fafafa', padx=10, pady=8)
        sintomas_text.pack(fill='x')
        
        # Diagn√≥stico
        diagnostico_section = tk.Frame(medical_content, bg='white')
        diagnostico_section.pack(fill='x', pady=(0, 15))
        
        tk.Label(diagnostico_section, text="Diagn√≥stico", font=('Arial', 11, 'bold'), 
                bg='white', fg='#2c5aa0').pack(anchor='w', pady=(0, 5))
        
        diagnostico_text = tk.Text(diagnostico_section, height=3, font=('Arial', 11), wrap='word',
                                  relief='solid', bd=1, bg='#fafafa', padx=10, pady=8)
        diagnostico_text.pack(fill='x')
        
        # Tratamiento
        tratamiento_section = tk.Frame(medical_content, bg='white')
        tratamiento_section.pack(fill='x', pady=(0, 15))
        
        tk.Label(tratamiento_section, text="Tratamiento Recomendado", font=('Arial', 11, 'bold'), 
                bg='white', fg='#2c5aa0').pack(anchor='w', pady=(0, 5))
        
        tratamiento_text = tk.Text(tratamiento_section, height=3, font=('Arial', 11), wrap='word',
                                  relief='solid', bd=1, bg='#fafafa', padx=10, pady=8)
        tratamiento_text.pack(fill='x')
        
        # Medicamentos
        medicamentos_section = tk.Frame(medical_content, bg='white')
        medicamentos_section.pack(fill='x', pady=(0, 15))
        
        tk.Label(medicamentos_section, text="Medicamentos Recetados", font=('Arial', 11, 'bold'), 
                bg='white', fg='#2c5aa0').pack(anchor='w', pady=(0, 5))
        
        medicamentos_text = tk.Text(medicamentos_section, height=3, font=('Arial', 11), wrap='word',
                                   relief='solid', bd=1, bg='#fafafa', padx=10, pady=8)
        medicamentos_text.pack(fill='x')
        
        # ========== BOTONES DE ACCI√ìN PREMIUM ==========
        buttons_container = tk.Frame(content_frame, bg='#f0f4f7')
        buttons_container.pack(fill='x', pady=(30, 0))
        
        buttons_frame = tk.Frame(buttons_container, bg='white', relief='solid', bd=1)
        buttons_frame.pack(fill='x', padx=0, pady=0)
        
        button_content = tk.Frame(buttons_frame, bg='white')
        button_content.pack(fill='x', padx=25, pady=20)
        
        # Bot√≥n Cancelar con estilo
        cancel_btn = tk.Button(button_content, text="‚ùå Cancelar", 
                              bg='#0B5394', fg='white', font=('Arial', 12, 'bold'), 
                              width=15, height=2, relief='flat', cursor='hand2',
                              command=form_window.destroy)
        cancel_btn.pack(side='right', padx=(15, 0))
        
        # Efecto hover para cancelar
        def on_cancel_enter(e):
            cancel_btn.config(bg='#0B5394')
        def on_cancel_leave(e):
            cancel_btn.config(bg='#0B5394')
        
        cancel_btn.bind("<Enter>", on_cancel_enter)
        cancel_btn.bind("<Leave>", on_cancel_leave)
        
        # Bot√≥n Guardar con estilo premium
        save_text = "üíæ Actualizar Consulta" if edit_mode else "üíæ Guardar Consulta"
        save_btn = tk.Button(button_content, text=save_text, 
                            bg='#0B5394', fg='white', font=('Arial', 12, 'bold'), 
                            width=18, height=2, relief='flat', cursor='hand2',
                            command=lambda: self.save_medical_record(form_vars, form_window, edit_mode, 
                                                                   motivo_text, sintomas_text, diagnostico_text, 
                                                                   tratamiento_text, medicamentos_text))
        save_btn.pack(side='right')
        
        # Efecto hover para guardar
        def on_save_enter(e):
            save_btn.config(bg='#0B5394')
        def on_save_leave(e):
            save_btn.config(bg='#0B5394')
        
        save_btn.bind("<Enter>", on_save_enter)
        save_btn.bind("<Leave>", on_save_leave)
        
        # Configurar canvas y scrollbar
        main_canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Bind mousewheel para scroll
        def _on_mousewheel(event):
            main_canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        main_canvas.bind_all("<MouseWheel>", _on_mousewheel)
        
        # Focus en el primer campo
        motivo_text.focus()
    
    def save_medical_record(self, form_vars, form_window, edit_mode, motivo_text, sintomas_text, 
                          diagnostico_text, tratamiento_text, medicamentos_text):
        """Guardar registro m√©dico"""
        try:
            # Validar campos obligatorios
            if not form_vars['fecha_consulta'].get():
                messagebox.showerror("Error", "La fecha de consulta es obligatoria")
                return
            
            # Obtener datos de los Text widgets
            motivo = motivo_text.get("1.0", tk.END).strip()
            sintomas = sintomas_text.get("1.0", tk.END).strip()
            diagnostico = diagnostico_text.get("1.0", tk.END).strip()
            tratamiento = tratamiento_text.get("1.0", tk.END).strip()
            medicamentos = medicamentos_text.get("1.0", tk.END).strip()
            
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            if edit_mode:
                # Actualizar registro existente
                query = """
                    UPDATE historial_medico 
                    SET fecha_consulta=?, tipo_consulta=?, motivo_consulta=?, 
                        sintomas=?, diagnostico=?, tratamiento=?, medicamentos=?, estado=?
                    WHERE id=?
                """
                cursor.execute(query, (
                    form_vars['fecha_consulta'].get(),
                    form_vars['tipo_consulta'].get(),
                    motivo,
                    sintomas,
                    diagnostico,
                    tratamiento,
                    medicamentos,
                    form_vars['estado'].get(),
                    self.selected_medical_record_id
                ))
            else:
                # Crear nuevo registro
                query = """
                    INSERT INTO historial_medico 
                    (paciente_id, doctor_id, fecha_consulta, tipo_consulta, motivo_consulta, 
                     sintomas, diagnostico, tratamiento, medicamentos, estado, fecha_creacion)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """
                cursor.execute(query, (
                    self.selected_patient_id,
                    self.current_user.id,  # Doctor actual
                    form_vars['fecha_consulta'].get(),
                    form_vars['tipo_consulta'].get(),
                    motivo,
                    sintomas,
                    diagnostico,
                    tratamiento,
                    medicamentos,
                    form_vars['estado'].get(),
                    datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                ))
            
            conn.commit()
            cursor.close()
            conn.close()
            
            messagebox.showinfo("√âxito", "Registro m√©dico guardado correctamente")
            form_window.destroy()
            
            # Recargar registros m√©dicos
            self.load_medical_records_for_patient(self.selected_patient_id)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al guardar registro m√©dico: {str(e)}")
    
    def create_medical_record(self): 
        """Crear nuevo registro m√©dico - acceso desde otros m√≥dulos"""
        if hasattr(self, 'selected_patient_id') and self.selected_patient_id:
            self.add_medical_record()
        else:
            messagebox.showwarning("Advertencia", "Por favor seleccione un paciente primero")
    
    def view_medical_record_detail(self): 
        """Ver detalles completos del registro m√©dico"""
        if not self.selected_medical_record_id:
            messagebox.showwarning("Advertencia", "Por favor seleccione un registro m√©dico")
            return
        
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            query = """
                SELECT hm.*, 
                       ud.nombre as doctor_nombre, ud.apellido as doctor_apellido,
                       up.nombre as paciente_nombre, up.apellido as paciente_apellido
                FROM historiales_medicos hm
                LEFT JOIN usuarios ud ON hm.doctor_id = ud.id
                LEFT JOIN usuarios up ON hm.paciente_id = up.id
                WHERE hm.id = ?
            """
            
            cursor.execute(query, (self.selected_medical_record_id,))
            record = cursor.fetchone()
            
            if record:
                self.show_medical_record_details(record)
            else:
                messagebox.showerror("Error", "Registro m√©dico no encontrado")
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al obtener detalles: {str(e)}")
    
    def show_medical_record_details(self, record):
        """Mostrar ventana con detalles completos del registro m√©dico"""
        details_window = tk.Toplevel()
        details_window.title("Detalle de Consulta M√©dica - MEDISYNC")
        details_window.geometry("600x700")
        details_window.configure(bg='#F8FAFC')
        
        # Centrar ventana
        details_window.transient(self.root)
        details_window.grab_set()
        
        # Header
        header_frame = tk.Frame(details_window, bg='#0B5394', height=60)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        tk.Label(header_frame, text="ü©∫ Detalle de Consulta M√©dica", font=('Arial', 16, 'bold'), 
                bg='#0B5394', fg='white').pack(expand=True)
        
        # Contenido scrollable
        content_frame = tk.Frame(details_window, bg='white')
        content_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        canvas = tk.Canvas(content_frame, bg='white')
        scrollbar = ttk.Scrollbar(content_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='white')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Extraer datos del record (basado en la estructura de historiales_medicos)
        # record = (id, paciente_id, doctor_id, cita_id, fecha_consulta, diagnostico, 
        #          tratamiento, medicamentos, observaciones, adjuntos, estado, 
        #          fecha_creacion, doctor_nombre, doctor_apellido, paciente_nombre, paciente_apellido)
        
        paciente_nombre = f"{record[14]} {record[15]}" if len(record) > 15 and record[14] and record[15] else "N/A"
        doctor_nombre = f"Dr. {record[12]} {record[13]}" if len(record) > 13 and record[12] and record[13] else "N/A"
        
        # Informaci√≥n del paciente y doctor
        info_frame = tk.LabelFrame(scrollable_frame, text="üë• Informaci√≥n General", 
                                 font=('Arial', 12, 'bold'), padx=15, pady=10)
        info_frame.pack(fill='x', pady=(0, 10))
        
        general_info = [
            ("Paciente:", paciente_nombre),
            ("Doctor:", doctor_nombre),
            ("Fecha de Consulta:", record[4] if len(record) > 4 and record[4] else "N/A"),
            ("Estado:", record[10] if len(record) > 10 and record[10] else "Pendiente")
        ]
        
        for label, value in general_info:
            row = tk.Frame(info_frame, bg='white')
            row.pack(fill='x', pady=2)
            
            tk.Label(row, text=label, font=('Arial', 10, 'bold'), 
                    bg='white', width=20, anchor='w').pack(side='left')
            tk.Label(row, text=value, font=('Arial', 10), 
                    bg='white', anchor='w').pack(side='left', padx=(10, 0))
        
        # Detalles m√©dicos
        medical_sections = [
            ("üîç Diagn√≥stico", record[5] if len(record) > 5 else ""),
            ("üíä Tratamiento", record[6] if len(record) > 6 else ""),
            ("ÔøΩ Medicamentos", record[7] if len(record) > 7 else ""),
            ("ÔøΩ Observaciones", record[8] if len(record) > 8 else "")
        ]
        
        for title, content in medical_sections:
            section_frame = tk.LabelFrame(scrollable_frame, text=title, 
                                        font=('Arial', 11, 'bold'), padx=15, pady=10)
            section_frame.pack(fill='x', pady=(0, 10))
            
            text_widget = tk.Text(section_frame, height=4, font=('Arial', 10), 
                                wrap=tk.WORD, state='disabled', bg='#F8FAFC')
            text_widget.pack(fill='x')
            
            if content:
                text_widget.config(state='normal')
                text_widget.insert('1.0', content)
                text_widget.config(state='disabled')
            else:
                text_widget.config(state='normal')
                text_widget.insert('1.0', "No especificado")
                text_widget.config(state='disabled')
        
        # Bot√≥n cerrar
        btn_frame = tk.Frame(scrollable_frame, bg='white')
        btn_frame.pack(fill='x', pady=20)
        
        tk.Button(btn_frame, text="Cerrar", bg='#0B5394', fg='white',
                 font=('Arial', 11, 'bold'), width=15,
                 command=details_window.destroy).pack()
        
        # Pack scrollable components
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
    
    def edit_medical_record(self): 
        """Editar registro m√©dico seleccionado"""
        if not self.selected_medical_record_id:
            messagebox.showwarning("Advertencia", "Por favor seleccione un registro m√©dico para editar")
            return
        
        self.open_medical_record_form(edit_mode=True)
    
    def print_medical_record(self): 
        """Sistema completo de impresi√≥n del historial m√©dico"""
        # Obtener el registro seleccionado directamente del TreeView
        selection = self.medical_records_tree.selection()
        if not selection:
            messagebox.showwarning("Advertencia", "Por favor seleccione un registro m√©dico para imprimir")
            return
        
        # Obtener el ID del registro seleccionado
        item = self.medical_records_tree.item(selection[0])
        print(f"üîç DEBUG: TreeView selection = {selection}")
        print(f"üîç DEBUG: TreeView item completo = {item}")
        print(f"üîç DEBUG: TreeView item['values'] = {item['values']}")
        
        # Verificar todos los items en el TreeView
        print("üîç DEBUG: Todos los items en el TreeView:")
        for child in self.medical_records_tree.get_children():
            child_item = self.medical_records_tree.item(child)
            print(f"  - ID: {child}, values: {child_item['values']}")
        
        selected_record_id = item['values'][0]
        
        print(f"üîç DEBUG: selected_record_id desde TreeView = {selected_record_id}")
        print(f"üîç DEBUG: selected_medical_record_id global = {self.selected_medical_record_id}")
        
        # Obtener informaci√≥n del paciente asociado al registro
        patient_info = self.get_patient_from_medical_record(selected_record_id)
        print(f"üîç DEBUG: patient_info = {patient_info}")
        
        if not patient_info:
            messagebox.showerror("Error", "No se pudo obtener informaci√≥n del paciente")
            return
        
        self.open_medical_history_print_window(patient_info)
    
    def get_patient_from_medical_record(self, medical_record_id):
        """Obtener informaci√≥n del paciente desde un registro m√©dico"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            query = """
                SELECT p.id, p.nombre, p.apellido, p.email, p.telefono, p.fecha_nacimiento
                FROM historiales_medicos hm
                JOIN usuarios p ON hm.paciente_id = p.id
                WHERE hm.id = ?
            """
            print(f"üîç DEBUG: Buscando paciente para record_id = {medical_record_id}")
            cursor.execute(query, (medical_record_id,))
            result = cursor.fetchone()
            print(f"üîç DEBUG: Resultado query = {result}")
            
            if result:
                patient_info = {
                    'id': result[0],
                    'nombre': result[1],
                    'apellido': result[2],
                    'email': result[3],
                    'telefono': result[4],
                    'fecha_nacimiento': result[5]
                }
                print(f"üîç DEBUG: patient_info creado = {patient_info}")
                return patient_info
            return None
            
        except Exception as e:
            print(f"Error obteniendo paciente: {e}")
            return None
    
    def open_medical_history_print_window(self, patient_info):
        """Ventana para seleccionar e imprimir historial m√©dico"""
        window = tk.Toplevel(self.root)
        window.title("üñ®Ô∏è Imprimir Historial M√©dico")
        window.geometry("900x700")
        window.configure(bg='#F8FAFC')
        window.transient(self.root)
        window.grab_set()
        window.resizable(True, True)
        
        # Centrar ventana
        window.update_idletasks()
        x = (window.winfo_screenwidth() // 2) - (900 // 2)
        y = (window.winfo_screenheight() // 2) - (700 // 2)
        window.geometry(f"900x700+{x}+{y}")
        
        # Header
        header_frame = tk.Frame(window, bg='#0B5394', height=100)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        header_content = tk.Frame(header_frame, bg='#0B5394')
        header_content.pack(expand=True, fill='both')
        
        tk.Label(header_content, text="üñ®Ô∏è IMPRIMIR HISTORIAL M√âDICO", 
                font=('Arial', 18, 'bold'), bg='#0B5394', fg='white').pack(pady=(15, 5))
        
        tk.Label(header_content, text=f"Paciente: {patient_info['nombre']} {patient_info['apellido']}", 
                font=('Arial', 12), bg='#0B5394', fg='#CBD5E1').pack(pady=(0, 15))
        
        # Contenido principal
        main_container = tk.Frame(window, bg='#F8FAFC')
        main_container.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Panel izquierdo - Selecci√≥n de registros
        left_panel = tk.LabelFrame(main_container, text="üìã Seleccionar Registros a Imprimir", 
                                  font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                  padx=15, pady=10)
        left_panel.pack(side='left', fill='both', expand=True, padx=(0, 10))
        
        # Filtros
        filters_frame = tk.Frame(left_panel, bg='#F8FAFC')
        filters_frame.pack(fill='x', pady=(0, 10))
        
        tk.Label(filters_frame, text="Filtrar por:", font=('Arial', 10, 'bold'), 
                bg='#F8FAFC', fg='#64748B').pack(anchor='w')
        
        filter_options_frame = tk.Frame(filters_frame, bg='#F8FAFC')
        filter_options_frame.pack(fill='x', pady=(5, 0))
        
        # Variables para filtros
        self.print_filter_date_from = tk.StringVar()
        self.print_filter_date_to = tk.StringVar()
        self.print_filter_type = tk.StringVar(value="Todos")
        
        # Filtros de fecha
        date_filter_frame = tk.Frame(filter_options_frame, bg='#F8FAFC')
        date_filter_frame.pack(fill='x', pady=2)
        
        tk.Label(date_filter_frame, text="Desde:", font=('Arial', 9), 
                bg='#F8FAFC', fg='#64748B').pack(side='left')
        tk.Entry(date_filter_frame, textvariable=self.print_filter_date_from, 
                font=('Arial', 9), width=12).pack(side='left', padx=(5, 10))
        
        tk.Label(date_filter_frame, text="Hasta:", font=('Arial', 9), 
                bg='#F8FAFC', fg='#64748B').pack(side='left')
        tk.Entry(date_filter_frame, textvariable=self.print_filter_date_to, 
                font=('Arial', 9), width=12).pack(side='left', padx=(5, 10))
        
        # Filtro por tipo
        type_filter_frame = tk.Frame(filter_options_frame, bg='#F8FAFC')
        type_filter_frame.pack(fill='x', pady=2)
        
        tk.Label(type_filter_frame, text="Tipo:", font=('Arial', 9), 
                bg='#F8FAFC', fg='#64748B').pack(side='left')
        ttk.Combobox(type_filter_frame, textvariable=self.print_filter_type,
                    values=["Todos", "Consulta", "Examen", "Tratamiento", "Seguimiento"],
                    state="readonly", font=('Arial', 9), width=15).pack(side='left', padx=(5, 0))
        
        # Lista de registros con checkboxes
        records_frame = tk.Frame(left_panel, bg='#F8FAFC')
        records_frame.pack(fill='both', expand=True, pady=(10, 0))
        
        # Scrollbar para la lista
        records_canvas = tk.Canvas(records_frame, bg='#F8FAFC', highlightthickness=0)
        records_scrollbar = ttk.Scrollbar(records_frame, orient="vertical", command=records_canvas.yview)
        self.records_scrollable_frame = tk.Frame(records_canvas, bg='#F8FAFC')
        
        self.records_scrollable_frame.bind(
            "<Configure>",
            lambda e: records_canvas.configure(scrollregion=records_canvas.bbox("all"))
        )
        
        records_canvas.create_window((0, 0), window=self.records_scrollable_frame, anchor="nw")
        records_canvas.configure(yscrollcommand=records_scrollbar.set)
        
        records_canvas.pack(side="left", fill="both", expand=True)
        records_scrollbar.pack(side="right", fill="y")
        
        # Panel derecho - Vista previa y acciones
        right_panel = tk.LabelFrame(main_container, text="üëÅÔ∏è Vista Previa", 
                                   font=('Arial', 12, 'bold'), bg='#F8FAFC', fg='#1E3A8A',
                                   padx=15, pady=10)
        right_panel.pack(side='right', fill='both', expand=True, padx=(10, 0))
        
        # Vista previa
        preview_frame = tk.Frame(right_panel, bg='white', relief='sunken', bd=2)
        preview_frame.pack(fill='both', expand=True, pady=(0, 10))
        
        self.preview_text = tk.Text(preview_frame, font=('Arial', 10), bg='white', 
                                   state='disabled', wrap='word')
        preview_scrollbar = ttk.Scrollbar(preview_frame, orient="vertical", command=self.preview_text.yview)
        self.preview_text.configure(yscrollcommand=preview_scrollbar.set)
        
        self.preview_text.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        preview_scrollbar.pack(side="right", fill="y")
        
        # Botones de acci√≥n
        actions_frame = tk.Frame(right_panel, bg='#F8FAFC')
        actions_frame.pack(fill='x')
        
        tk.Button(actions_frame, text="üîÑ Actualizar Vista Previa", 
                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                 command=lambda: self.update_medical_history_preview(patient_info),
                 padx=15, pady=8).pack(fill='x', pady=2)
        
        tk.Button(actions_frame, text="üìÑ Generar PDF", 
                 bg='#16A085', fg='white', font=('Arial', 10, 'bold'),
                 command=lambda: self.generate_medical_history_pdf(patient_info),
                 padx=15, pady=8).pack(fill='x', pady=2)
        
        tk.Button(actions_frame, text="‚ùå Cerrar", 
                 bg='#E74C3C', fg='white', font=('Arial', 10, 'bold'),
                 command=window.destroy, padx=15, pady=8).pack(fill='x', pady=2)
        
        # Cargar registros m√©dicos del paciente
        self.load_patient_medical_records(patient_info['id'])
        
        # Actualizar vista previa inicial
        self.update_medical_history_preview(patient_info)
    
    def load_patient_medical_records(self, patient_id):
        """Cargar registros m√©dicos del paciente con checkboxes"""
        # Limpiar registros anteriores
        for widget in self.records_scrollable_frame.winfo_children():
            widget.destroy()
        
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            query = """
                SELECT id, fecha_consulta, diagnostico, tratamiento, medicamentos, observaciones
                FROM historiales_medicos 
                WHERE paciente_id = ? 
                ORDER BY fecha_consulta DESC
            """
            cursor.execute(query, (patient_id,))
            records = cursor.fetchall()
            
            # Variables para checkbox selection
            self.selected_records = {}
            
            if not records:
                tk.Label(self.records_scrollable_frame, 
                        text="No se encontraron registros m√©dicos para este paciente",
                        font=('Arial', 10), bg='#F8FAFC', fg='#64748B').pack(pady=20)
                return
            
            # Header con seleccionar todo
            header_frame = tk.Frame(self.records_scrollable_frame, bg='#E3F2FD', relief='raised', bd=1)
            header_frame.pack(fill='x', padx=2, pady=(0, 5))
            
            select_all_var = tk.BooleanVar()
            select_all_cb = tk.Checkbutton(header_frame, text="Seleccionar Todos",
                                          variable=select_all_var, bg='#E3F2FD',
                                          font=('Arial', 10, 'bold'),
                                          command=lambda: self.toggle_all_records(select_all_var.get()))
            select_all_cb.pack(side='left', padx=10, pady=5)
            
            # Crear checkbox para cada registro
            for i, record in enumerate(records):
                record_id, fecha_consulta, diagnostico, tratamiento, medicamentos, observaciones = record
                
                # Frame para cada registro
                record_frame = tk.Frame(self.records_scrollable_frame, bg='white', relief='raised', bd=1)
                record_frame.pack(fill='x', padx=2, pady=2)
                
                # Variable para checkbox
                var = tk.BooleanVar(value=True)  # Seleccionar todos por defecto
                self.selected_records[record_id] = var
                
                # Checkbox y contenido
                cb_frame = tk.Frame(record_frame, bg='white')
                cb_frame.pack(fill='x', padx=10, pady=5)
                
                tk.Checkbutton(cb_frame, variable=var, bg='white',
                              command=lambda: self.update_medical_history_preview(None)).pack(side='left')
                
                # Informaci√≥n del registro
                info_frame = tk.Frame(cb_frame, bg='white')
                info_frame.pack(side='left', fill='x', expand=True, padx=(10, 0))
                
                # Primera l√≠nea: fecha
                first_line = tk.Frame(info_frame, bg='white')
                first_line.pack(fill='x')
                
                tk.Label(first_line, text=f"üìÖ {fecha_consulta}", font=('Arial', 10, 'bold'),
                        bg='white', fg='#0B5394').pack(side='left')
                
                # Diagn√≥stico
                if diagnostico:
                    diag_text = diagnostico[:100] + "..." if len(diagnostico) > 100 else diagnostico
                    tk.Label(info_frame, text=f"ÔøΩ {diag_text}", font=('Arial', 9),
                            bg='white', fg='#E67E22', wraplength=300, justify='left').pack(anchor='w', pady=(2, 0))
                
                # Tratamiento
                if tratamiento:
                    treat_text = tratamiento[:80] + "..." if len(tratamiento) > 80 else tratamiento
                    tk.Label(info_frame, text=f"ÔøΩ {treat_text}", font=('Arial', 9),
                            bg='white', fg='#16A085', wraplength=300, justify='left').pack(anchor='w', pady=(1, 0))
            
            print(f"Cargados {len(records)} registros m√©dicos")
            
        except Exception as e:
            print(f"Error cargando registros m√©dicos: {e}")
            tk.Label(self.records_scrollable_frame, 
                    text="Error al cargar registros m√©dicos",
                    font=('Arial', 10), bg='#F8FAFC', fg='#E74C3C').pack(pady=20)
    
    def toggle_all_records(self, select_all):
        """Seleccionar/deseleccionar todos los registros"""
        if hasattr(self, 'selected_records') and self.selected_records:
            for var in self.selected_records.values():
                var.set(select_all)
            self.update_medical_history_preview(None)
    
    def update_medical_history_preview(self, patient_info):
        """Actualizar vista previa del historial m√©dico"""
        if patient_info is None:
            # Obtener info del paciente desde el registro seleccionado
            patient_info = self.get_patient_from_medical_record(self.selected_medical_record_id)
        
        if not patient_info:
            return
        
        # Verificar que selected_records exista
        if not hasattr(self, 'selected_records') or not self.selected_records:
            self.preview_text.config(state='normal')
            self.preview_text.delete(1.0, tk.END)
            self.preview_text.insert(tk.END, "Cargando registros m√©dicos...")
            self.preview_text.config(state='disabled')
            return
        
        # Obtener registros seleccionados
        selected_record_ids = [record_id for record_id, var in self.selected_records.items() if var.get()]
        
        if not selected_record_ids:
            self.preview_text.config(state='normal')
            self.preview_text.delete(1.0, tk.END)
            self.preview_text.insert(tk.END, "Seleccione al menos un registro para mostrar la vista previa")
            self.preview_text.config(state='disabled')
            return
        
        # Generar contenido de vista previa
        preview_content = self.generate_medical_history_content(patient_info, selected_record_ids)
        
        # Actualizar vista previa
        self.preview_text.config(state='normal')
        self.preview_text.delete(1.0, tk.END)
        self.preview_text.insert(tk.END, preview_content)
        self.preview_text.config(state='disabled')
    
    def generate_medical_history_content(self, patient_info, selected_record_ids):
        """Generar contenido del historial m√©dico para vista previa/PDF"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Obtener registros seleccionados
            placeholders = ','.join('?' * len(selected_record_ids))
            query = f"""
                SELECT fecha_consulta, diagnostico, tratamiento, medicamentos, 
                       observaciones, estado
                FROM historiales_medicos 
                WHERE id IN ({placeholders})
                ORDER BY fecha_consulta DESC
            """
            cursor.execute(query, selected_record_ids)
            records = cursor.fetchall()
            
            # Generar contenido
            content = []
            content.append("=" * 80)
            content.append("HISTORIAL M√âDICO COMPLETO")
            content.append("=" * 80)
            content.append("")
            
            # Informaci√≥n del paciente
            content.append("INFORMACI√ìN DEL PACIENTE")
            content.append("-" * 40)
            content.append(f"Nombre: {patient_info['nombre']} {patient_info['apellido']}")
            content.append(f"Email: {patient_info['email']}")
            content.append(f"Tel√©fono: {patient_info['telefono']}")
            content.append(f"Fecha de Nacimiento: {patient_info['fecha_nacimiento']}")
            content.append("")
            
            # Resumen
            content.append(f"RESUMEN DEL HISTORIAL")
            content.append("-" * 40)
            content.append(f"Total de registros: {len(records)}")
            content.append(f"Fecha de generaci√≥n: {datetime.now().strftime('%d/%m/%Y %H:%M')}")
            content.append("")
            
            # Registros m√©dicos
            content.append("REGISTROS M√âDICOS DETALLADOS")
            content.append("=" * 50)
            
            for i, record in enumerate(records, 1):
                fecha_consulta, diagnostico, tratamiento, medicamentos, observaciones, estado = record
                
                content.append("")
                content.append(f"REGISTRO #{i}")
                content.append("-" * 30)
                content.append(f"üìÖ Fecha de Consulta: {fecha_consulta}")
                
                if diagnostico:
                    content.append(f"üîç Diagn√≥stico:")
                    content.append(f"   {diagnostico}")
                
                if tratamiento:
                    content.append(f"üíä Tratamiento:")
                    content.append(f"   {tratamiento}")
                
                if medicamentos:
                    content.append(f"üíâ Medicamentos:")
                    content.append(f"   {medicamentos}")
                
                if observaciones:
                    content.append(f"üìã Observaciones:")
                    content.append(f"   {observaciones}")
                
                if estado:
                    content.append(f"üìä Estado:")
                    content.append(f"   {estado}")
                
                content.append("")
            
            content.append("=" * 80)
            content.append("FIN DEL HISTORIAL M√âDICO")
            content.append("=" * 80)
            
            return "\n".join(content)
            
        except Exception as e:
            print(f"Error generando contenido del historial: {e}")
            return f"Error al generar el historial m√©dico: {str(e)}"
    
    def generate_medical_history_pdf(self, patient_info):
        """Generar PDF del historial m√©dico"""
        try:
            # Verificar que selected_records exista
            if not hasattr(self, 'selected_records') or not self.selected_records:
                messagebox.showwarning("Advertencia", "No hay registros cargados para generar el PDF")
                return
            
            # Obtener registros seleccionados
            selected_record_ids = [record_id for record_id, var in self.selected_records.items() if var.get()]
            
            if not selected_record_ids:
                messagebox.showwarning("Advertencia", "Seleccione al menos un registro para generar el PDF")
                return
            
            # Obtener datos de los registros
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            placeholders = ','.join('?' * len(selected_record_ids))
            query = f"""
                SELECT fecha_consulta, diagnostico, tratamiento, medicamentos, 
                       observaciones, estado
                FROM historiales_medicos 
                WHERE id IN ({placeholders})
                ORDER BY fecha_consulta DESC
            """
            cursor.execute(query, selected_record_ids)
            records = cursor.fetchall()
            
            # Importar reportlab
            try:
                from reportlab.lib import colors
                from reportlab.lib.pagesizes import letter, A4
                from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
                from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
                from reportlab.lib.units import inch
                from reportlab.pdfgen import canvas
            except ImportError:
                messagebox.showerror("Error", "La librer√≠a reportlab no est√° instalada.\nInstale con: pip install reportlab")
                return
            
            # Crear directorio si no existe
            os.makedirs("historiales_pdf", exist_ok=True)
            
            # Nombre del archivo (limpiar caracteres especiales)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            nombre_limpio = patient_info['nombre'].replace(' ', '_').replace('√±', 'n').replace('√°', 'a').replace('√©', 'e').replace('√≠', 'i').replace('√≥', 'o').replace('√∫', 'u')
            apellido_limpio = patient_info['apellido'].replace(' ', '_').replace('√±', 'n').replace('√°', 'a').replace('√©', 'e').replace('√≠', 'i').replace('√≥', 'o').replace('√∫', 'u')
            filename = f"historiales_pdf/Historial_Medico_{nombre_limpio}_{apellido_limpio}_{timestamp}.pdf"
            print(f"üîç DEBUG: Generando PDF en: {filename}")
            
            # Crear PDF
            doc = SimpleDocTemplate(filename, pagesize=A4)
            styles = getSampleStyleSheet()
            story = []
            
            # Estilo personalizado para t√≠tulo
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=18,
                spaceAfter=30,
                alignment=1,  # Centrado
                textColor=colors.HexColor('#0B5394')
            )
            
            # Estilo personalizado para subt√≠tulos
            subtitle_style = ParagraphStyle(
                'CustomSubtitle',
                parent=styles['Heading2'],
                fontSize=14,
                spaceAfter=12,
                textColor=colors.HexColor('#16A085')
            )
            
            # Estilo para texto normal
            normal_style = ParagraphStyle(
                'CustomNormal',
                parent=styles['Normal'],
                fontSize=10,
                spaceAfter=6
            )
            
            # T√≠tulo principal
            story.append(Paragraph("HISTORIAL M√âDICO COMPLETO", title_style))
            story.append(Spacer(1, 20))
            
            # Informaci√≥n del paciente
            story.append(Paragraph("INFORMACI√ìN DEL PACIENTE", subtitle_style))
            
            patient_data = [
                ['Nombre:', f"{patient_info['nombre']} {patient_info['apellido']}"],
                ['Email:', patient_info['email']],
                ['Tel√©fono:', patient_info['telefono']],
                ['Fecha de Nacimiento:', patient_info['fecha_nacimiento']]
            ]
            
            patient_table = Table(patient_data, colWidths=[2*inch, 4*inch])
            patient_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#E3F2FD')),
                ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#0B5394')),
                ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 1, colors.grey),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('LEFTPADDING', (0, 0), (-1, -1), 6),
                ('RIGHTPADDING', (0, 0), (-1, -1), 6),
            ]))
            
            story.append(patient_table)
            story.append(Spacer(1, 20))
            
            # Resumen
            story.append(Paragraph("RESUMEN DEL HISTORIAL", subtitle_style))
            summary_text = f"""
            <b>Total de registros:</b> {len(records)}<br/>
            <b>Fecha de generaci√≥n:</b> {datetime.now().strftime('%d/%m/%Y %H:%M')}<br/>
            <b>Generado por:</b> MEDISYNC - Sistema de Gesti√≥n M√©dica
            """
            story.append(Paragraph(summary_text, normal_style))
            story.append(Spacer(1, 20))
            
            # Registros m√©dicos
            story.append(Paragraph("REGISTROS M√âDICOS DETALLADOS", subtitle_style))
            
            for i, record in enumerate(records, 1):
                fecha_consulta, diagnostico, tratamiento, medicamentos, observaciones, estado = record
                
                # T√≠tulo del registro
                record_title = f"REGISTRO #{i} - {fecha_consulta}"
                story.append(Paragraph(record_title, ParagraphStyle(
                    'RecordTitle',
                    parent=styles['Heading3'],
                    fontSize=12,
                    spaceAfter=10,
                    textColor=colors.HexColor('#E67E22'),
                    backColor=colors.HexColor('#FDF2E9'),
                    borderPadding=5
                )))
                
                # Crear tabla para los datos del registro
                record_data = []
                
                if diagnostico:
                    record_data.append(['Diagn√≥stico:', diagnostico])
                if tratamiento:
                    record_data.append(['Tratamiento:', tratamiento])
                if medicamentos:
                    record_data.append(['Medicamentos:', medicamentos])
                if observaciones:
                    record_data.append(['Observaciones:', observaciones])
                if estado:
                    record_data.append(['Estado:', estado])
                
                if record_data:
                    record_table = Table(record_data, colWidths=[1.5*inch, 4.5*inch])
                    record_table.setStyle(TableStyle([
                        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#F8F9FA')),
                        ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#0B5394')),
                        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                        ('FONTSIZE', (0, 0), (-1, -1), 9),
                        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                        ('LEFTPADDING', (0, 0), (-1, -1), 6),
                        ('RIGHTPADDING', (0, 0), (-1, -1), 6),
                        ('TOPPADDING', (0, 0), (-1, -1), 8),
                        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                    ]))
                    
                    story.append(record_table)
                
                story.append(Spacer(1, 15))
            
            # Pie de p√°gina
            story.append(Spacer(1, 30))
            footer_text = f"""
            <i>Este historial m√©dico fue generado autom√°ticamente por MEDISYNC el {datetime.now().strftime('%d/%m/%Y a las %H:%M')}.<br/>
            Para cualquier consulta, p√≥ngase en contacto con el centro m√©dico.</i>
            """
            story.append(Paragraph(footer_text, ParagraphStyle(
                'Footer',
                parent=styles['Normal'],
                fontSize=8,
                alignment=1,
                textColor=colors.grey
            )))
            
            # Generar PDF
            doc.build(story)
            
            # Verificar que el archivo se cre√≥ correctamente
            if os.path.exists(filename):
                print(f"‚úÖ PDF generado exitosamente: {filename}")
                # Mostrar mensaje de √©xito y abrir PDF
                result = messagebox.askyesno("PDF Generado", 
                                           f"El historial m√©dico se ha generado exitosamente.\n\n"
                                           f"Archivo: {filename}\n\n"
                                           f"¬øDesea abrir el archivo PDF ahora?")
                
                if result:
                    try:
                        import subprocess
                        import sys
                        
                        if sys.platform.startswith('win'):
                            os.startfile(filename)
                        elif sys.platform.startswith('darwin'):
                            subprocess.call(['open', filename])
                        else:
                            subprocess.call(['xdg-open', filename])
                    except Exception as e:
                        print(f"Error abriendo PDF: {e}")
                        messagebox.showinfo("Archivo Generado", f"PDF generado en: {filename}\nNo se pudo abrir autom√°ticamente.")
            else:
                messagebox.showerror("Error", "El archivo PDF no se pudo crear correctamente")
            
        except Exception as e:
            print(f"Error generando PDF: {e}")
            messagebox.showerror("Error", f"Error al generar el PDF del historial m√©dico:\n{str(e)}")
    
    def create_medical_note_from_appointment(self, appointment_id):
        """Crear nota m√©dica autom√°ticamente al completar una cita"""
        try:
            # Obtener datos de la cita
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            query = """
                SELECT c.paciente_id, c.doctor_id, c.fecha_hora, c.motivo,
                       p.nombre as paciente_nombre, p.apellido as paciente_apellido
                FROM citas c
                JOIN usuarios p ON c.paciente_id = p.id
                WHERE c.id = ?
            """
            
            cursor.execute(query, (appointment_id,))
            appointment_data = cursor.fetchone()
            
            if appointment_data:
                # Crear registro m√©dico b√°sico
                medical_query = """
                    INSERT INTO historial_medico 
                    (paciente_id, doctor_id, fecha_consulta, tipo_consulta, motivo_consulta, 
                     estado, fecha_creacion)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """
                
                cursor.execute(medical_query, (
                    appointment_data[0],  # paciente_id
                    appointment_data[1],  # doctor_id
                    appointment_data[2][:10],  # fecha_consulta (solo fecha)
                    'Consulta',
                    appointment_data[3] or 'Consulta m√©dica',  # motivo
                    'Pendiente',  # Estado inicial
                    datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                ))
                
                conn.commit()
                
                # Obtener el ID del registro creado
                medical_record_id = cursor.lastrowid
                
                messagebox.showinfo("Registro Creado", 
                                  f"Se ha creado un registro m√©dico autom√°tico para {appointment_data[4]} {appointment_data[5]}.\n\n"
                                  "Puede completar los detalles m√©dicos en la pesta√±a de Historial M√©dico.")
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            print(f"Error al crear registro m√©dico autom√°tico: {str(e)}")
    
    def edit_doctor_profile(self): 
        messagebox.showinfo("Acci√≥n", "Editar perfil de doctor - En desarrollo")
    def change_password(self): 
        messagebox.showinfo("Acci√≥n", "Cambiar contrase√±a - En desarrollo")
    def configure_schedule(self): 
        messagebox.showinfo("Acci√≥n", "Configurar horarios - En desarrollo")
    
    # Funciones para secretarias
    def create_new_appointment(self): 
        messagebox.showinfo("Acci√≥n", "Crear nueva cita - En desarrollo")
    def show_appointment_calendar(self): 
        messagebox.showinfo("Acci√≥n", "Mostrar calendario - En desarrollo")
    def apply_appointment_filters(self): 
        self.load_secretaria_appointments()
    def load_appointment_doctors(self): 
        """Cargar doctores para filtro"""
        try:
            doctors = self.db_manager.get_all_doctors()
            doctor_names = ['Todos'] + [f"Dr. {doc['nombre']} {doc['apellido']}" for doc in doctors]
            self.appointment_doctor_filter['values'] = doctor_names
            self.appointment_doctor_filter.set('Todos')
        except Exception as e:
            print(f"Error cargando doctores para filtro: {e}")
    
    def load_secretaria_appointments(self): 
        """Cargar citas para secretaria"""
        try:
            # Placeholder - implementar carga real
            appointments = self.db_manager.get_all_appointments()
            
            # Limpiar tabla
            for item in self.secretaria_appointments_tree.get_children():
                self.secretaria_appointments_tree.delete(item)
            
            for apt in appointments:
                fecha_hora = apt.get('fecha_hora', '')
                if fecha_hora:
                    try:
                        dt = datetime.fromisoformat(fecha_hora)
                        fecha_hora = dt.strftime('%d/%m/%Y %H:%M')
                    except:
                        pass
                
                self.secretaria_appointments_tree.insert('', 'end', values=(
                    apt.get('id', ''), fecha_hora,
                    apt.get('paciente_nombre', 'N/A'),
                    apt.get('doctor_nombre', 'N/A'),
                    apt.get('motivo', 'N/A'),
                    apt.get('estado', 'N/A'),
                    apt.get('telefono', 'N/A')
                ))
        except Exception as e:
            messagebox.showerror("Error", f"Error cargando citas: {str(e)}")
    
    # M√°s funciones placeholder para secretarias y pacientes
    def edit_appointment(self): 
        """Editar cita seleccionada"""
        try:
            selection = self.appointments_tree.selection()
            if not selection:
                messagebox.showwarning("Advertencia", "Por favor seleccione una cita para editar")
                return
            
            item = self.appointments_tree.item(selection[0])
            appointment_id = item['values'][0]
            
            # Obtener datos de la cita
            appointment = self.db_manager.get_appointment_by_id(appointment_id)
            if not appointment:
                messagebox.showerror("Error", "Cita no encontrada")
                return
            
            self.edit_appointment_window(appointment)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al editar cita: {str(e)}")
    
    def confirm_appointment(self):
        """Confirmar cita seleccionada - m√©todo de acceso r√°pido"""
        try:
            selection = self.appointments_tree.selection()
            if not selection:
                messagebox.showwarning("Advertencia", "Por favor seleccione una cita para confirmar")
                return
            
            item = self.appointments_tree.item(selection[0])
            appointment_id = item['values'][0]
            
            self.change_appointment_status(appointment_id, 'confirmada')
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al confirmar cita: {str(e)}")
    
    def cancel_appointment(self):
        """Cancelar cita seleccionada - m√©todo de acceso r√°pido"""
        try:
            selection = self.appointments_tree.selection()
            if not selection:
                messagebox.showwarning("Advertencia", "Por favor seleccione una cita para cancelar")
                return
            
            item = self.appointments_tree.item(selection[0])
            appointment_id = item['values'][0]
            
            self.cancel_appointment_with_reason(appointment_id)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al cancelar cita: {str(e)}")
    
    def call_patient(self): messagebox.showinfo("Acci√≥n", "Llamar paciente - En desarrollo")
    def generate_appointment_invoice(self): messagebox.showinfo("Acci√≥n", "Generar factura - En desarrollo")
    def register_new_patient(self): messagebox.showinfo("Acci√≥n", "Registrar nuevo paciente - En desarrollo")
    def import_patients(self): messagebox.showinfo("Acci√≥n", "Importar pacientes - En desarrollo")
    def export_patients(self): messagebox.showinfo("Acci√≥n", "Exportar pacientes - En desarrollo")
    def search_patients_secretaria(self, event=None): messagebox.showinfo("Acci√≥n", "Buscar pacientes - En desarrollo")
    def clear_patient_search(self): messagebox.showinfo("Acci√≥n", "Limpiar b√∫squeda - En desarrollo")
    def load_secretaria_patients(self): messagebox.showinfo("Acci√≥n", "Cargar pacientes - En desarrollo")
    
    # ==================== GESTI√ìN DE USUARIOS ====================
    
    def open_user_management(self):
        """Abrir ventana de gesti√≥n de usuarios"""
        user_window = tk.Toplevel(self.root)
        user_window.title("Gesti√≥n de Usuarios - MEDISYNC")
        user_window.geometry("1200x700")
        user_window.configure(bg='#F8FAFC')
        user_window.resizable(True, True)
        
        # Centrar ventana
        user_window.transient(self.root)
        user_window.grab_set()
        
        # Header principal
        header_frame = tk.Frame(user_window, bg='#1E3A8A', height=80)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        tk.Label(header_frame, text="üë• Gesti√≥n de Usuarios", font=('Arial', 20, 'bold'), 
                bg='#1E3A8A', fg='white').pack(expand=True)
        
        # Frame principal con divisi√≥n izquierda/derecha
        main_frame = tk.Frame(user_window, bg='#F8FAFC')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Panel izquierdo - Lista de usuarios
        left_panel = tk.Frame(main_frame, bg='white', relief='solid', bd=1)
        left_panel.pack(side='left', fill='both', expand=True, padx=(0, 10))
        
        # Header del panel izquierdo
        left_header = tk.Frame(left_panel, bg='#0B5394', height=50)
        left_header.pack(fill='x')
        left_header.pack_propagate(False)
        
        tk.Label(left_header, text="üìã Lista de Usuarios", font=('Arial', 14, 'bold'), 
                bg='#0B5394', fg='white').pack(side='left', padx=15, expand=True, anchor='w')
        
        # Botones de acci√≥n en header izquierdo
        btn_frame = tk.Frame(left_header, bg='#0B5394')
        btn_frame.pack(side='right', padx=15)
        
        tk.Button(btn_frame, text="‚ûï Nuevo Usuario", bg='#0B5394', fg='white',
                 font=('Arial', 9, 'bold'), command=self.add_new_user).pack(side='left', padx=2)
        tk.Button(btn_frame, text="üîÑ Actualizar", bg='#0B5394', fg='white',
                 font=('Arial', 9, 'bold'), command=self.refresh_user_list).pack(side='left', padx=2)
        
        # Filtros de b√∫squeda
        search_frame = tk.Frame(left_panel, bg='white')
        search_frame.pack(fill='x', padx=15, pady=10)
        
        # Primera fila de filtros
        search_row1 = tk.Frame(search_frame, bg='white')
        search_row1.pack(fill='x', pady=(0, 5))
        
        tk.Label(search_row1, text="Buscar:", font=('Arial', 10, 'bold'), bg='white').pack(side='left')
        self.user_search_entry = tk.Entry(search_row1, font=('Arial', 10), width=20)
        self.user_search_entry.pack(side='left', padx=5)
        self.user_search_entry.bind('<KeyRelease>', self.search_users)
        
        tk.Label(search_row1, text="Tipo:", font=('Arial', 10, 'bold'), bg='white').pack(side='left', padx=(15, 5))
        self.user_type_filter = ttk.Combobox(search_row1, values=['Todos', 'admin', 'doctor', 'secretaria', 'paciente'], 
                                           state='readonly', width=12)
        self.user_type_filter.set('Todos')
        self.user_type_filter.pack(side='left', padx=5)
        self.user_type_filter.bind('<<ComboboxSelected>>', self.filter_users)
        
        # Segunda fila de filtros
        search_row2 = tk.Frame(search_frame, bg='white')
        search_row2.pack(fill='x')
        
        tk.Label(search_row2, text="Estado:", font=('Arial', 10, 'bold'), bg='white').pack(side='left')
        self.user_status_filter = ttk.Combobox(search_row2, values=['Todos', 'Activo', 'Inactivo'], 
                                             state='readonly', width=12)
        self.user_status_filter.set('Todos')
        self.user_status_filter.pack(side='left', padx=5)
        self.user_status_filter.bind('<<ComboboxSelected>>', self.filter_users)
        
        tk.Button(search_row2, text="üîç Buscar", bg='#0B5394', fg='white', font=('Arial', 9),
                 command=self.search_users).pack(side='left', padx=(15, 5))
        tk.Button(search_row2, text="üóëÔ∏è Limpiar", bg='#0B5394', fg='white', font=('Arial', 9),
                 command=self.clear_user_search).pack(side='left', padx=2)
        
        # Tabla de usuarios
        users_table_frame = tk.Frame(left_panel, bg='white')
        users_table_frame.pack(fill='both', expand=True, padx=15, pady=(0, 15))
        
        columns = ('ID', 'Nombre', 'Apellido', 'Email', 'Tipo', 'Estado', '√öltimo Acceso')
        self.users_tree = ttk.Treeview(users_table_frame, columns=columns, show='headings', height=15)
        
        # Configurar headers
        column_widths = {'ID': 50, 'Nombre': 120, 'Apellido': 120, 'Email': 180, 
                        'Tipo': 80, 'Estado': 80, '√öltimo Acceso': 100}
        
        for col in columns:
            self.users_tree.heading(col, text=col)
            self.users_tree.column(col, width=column_widths.get(col, 100))
        
        # Scrollbars para la tabla
        scrollbar_y = ttk.Scrollbar(users_table_frame, orient="vertical", command=self.users_tree.yview)
        scrollbar_x = ttk.Scrollbar(users_table_frame, orient="horizontal", command=self.users_tree.xview)
        self.users_tree.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        
        self.users_tree.pack(side='left', fill='both', expand=True)
        scrollbar_y.pack(side='right', fill='y')
        scrollbar_x.pack(side='bottom', fill='x')
        
        # Bind para selecci√≥n
        self.users_tree.bind('<<TreeviewSelect>>', self.on_user_select)
        
        # Panel derecho - Detalles y acciones
        right_panel = tk.Frame(main_frame, bg='white', relief='solid', bd=1, width=400)
        right_panel.pack(side='right', fill='y', padx=(10, 0))
        right_panel.pack_propagate(False)
        
        # Header del panel derecho
        right_header = tk.Frame(right_panel, bg='#0B5394', height=50)
        right_header.pack(fill='x')
        right_header.pack_propagate(False)
        
        tk.Label(right_header, text="‚öôÔ∏è Acciones de Usuario", font=('Arial', 14, 'bold'), 
                bg='#0B5394', fg='white').pack(expand=True)
        
        # Informaci√≥n del usuario seleccionado
        self.user_info_frame = tk.Frame(right_panel, bg='white')
        self.user_info_frame.pack(fill='x', padx=15, pady=15)
        
        # Placeholder para informaci√≥n
        self.user_info_label = tk.Label(self.user_info_frame, text="Seleccione un usuario para ver sus detalles", 
                                       font=('Arial', 11), bg='white', fg='#64748B', wraplength=350)
        self.user_info_label.pack()
        
        # Crear frame con scrollbar para los botones de acci√≥n
        actions_container = tk.Frame(right_panel, bg='white')
        actions_container.pack(fill='both', expand=True, padx=15, pady=(0, 15))
        
        # Canvas y scrollbar para las acciones
        actions_canvas = tk.Canvas(actions_container, bg='white', highlightthickness=0, height=300)
        actions_scrollbar = ttk.Scrollbar(actions_container, orient="vertical", command=actions_canvas.yview)
        scrollable_actions_frame = tk.Frame(actions_canvas, bg='white')
        
        # Configurar el scroll
        def configure_scroll_region(event=None):
            actions_canvas.configure(scrollregion=actions_canvas.bbox("all"))
            # Forzar update de la regi√≥n de scroll
            actions_canvas.update_idletasks()
        
        def configure_canvas_width(event):
            canvas_width = event.width
            actions_canvas.itemconfig(window_id, width=canvas_width)
        
        scrollable_actions_frame.bind("<Configure>", configure_scroll_region)
        window_id = actions_canvas.create_window((0, 0), window=scrollable_actions_frame, anchor="nw")
        actions_canvas.bind("<Configure>", configure_canvas_width)
        actions_canvas.configure(yscrollcommand=actions_scrollbar.set)
        
        # Empaquetar canvas y scrollbar
        actions_canvas.pack(side="left", fill="both", expand=True)
        actions_scrollbar.pack(side="right", fill="y")
        
        # Funci√≥n para el scroll con la rueda del mouse
        def _on_mousewheel(event):
            actions_canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        # Bind del scroll del mouse a m√∫ltiples widgets
        actions_canvas.bind("<MouseWheel>", _on_mousewheel)
        scrollable_actions_frame.bind("<MouseWheel>", _on_mousewheel)
        actions_container.bind("<MouseWheel>", _on_mousewheel)
        
        # Guardar referencias para uso posterior
        self.actions_canvas = actions_canvas
        self.scrollable_actions_frame = scrollable_actions_frame
        
        # Definir botones de acci√≥n
        user_actions = [
            ("‚úèÔ∏è Editar Usuario", self.edit_selected_user, "#0B5394"),
            ("üîë Cambiar Contrase√±a", self.change_user_password, "#0B5394"),
            ("‚úÖ Activar Usuario", self.activate_user, "#0B5394"),
            ("‚ùå Desactivar Usuario", self.deactivate_user, "#0B5394"),
            ("üëÅÔ∏è Ver Detalles Completos", self.view_user_details, "#0B5394"),
            ("üìß Enviar Email", self.send_user_email, "#0B5394"),
            ("üìã Historial de Accesos", self.view_access_history, "#0B5394"),
            ("üóëÔ∏è Eliminar Usuario", self.delete_user, "#0B5394")
        ]
        
        for text, command, color in user_actions:
            btn = tk.Button(scrollable_actions_frame, text=text, command=command, 
                           bg=color, fg='white', font=('Arial', 10, 'bold'),
                           width=25, height=2, relief='flat', cursor='hand2')
            btn.pack(fill='x', pady=3, padx=5)
            # Bind scroll tambi√©n a cada bot√≥n
            btn.bind("<MouseWheel>", _on_mousewheel)
        
        # Funci√≥n para forzar actualizaci√≥n del scroll
        def force_scroll_update():
            scrollable_actions_frame.update_idletasks()
            actions_canvas.configure(scrollregion=actions_canvas.bbox("all"))
            # Verificar si necesita scroll
            bbox = actions_canvas.bbox("all")
            if bbox and bbox[3] > actions_canvas.winfo_height():
                actions_scrollbar.pack(side="right", fill="y")
            else:
                actions_scrollbar.pack_forget()
        
        # Actualizar la regi√≥n de scroll despu√©s de agregar todos los botones
        actions_canvas.after(100, force_scroll_update)
        
        # Estad√≠sticas r√°pidas
        stats_frame = tk.LabelFrame(right_panel, text="üìä Estad√≠sticas", 
                                   font=('Arial', 11, 'bold'), padx=10, pady=10)
        stats_frame.pack(fill='x', padx=15, pady=(0, 15))
        
        self.load_user_stats(stats_frame)
        
        # Cargar datos iniciales
        self.load_users_list()
        
        # Variables para mantener referencia al usuario seleccionado
        self.selected_user_id = None
        self.selected_user_data = None
    
    def load_users_list(self):
        """Cargar lista de usuarios en la tabla"""
        try:
            # Limpiar tabla
            for item in self.users_tree.get_children():
                self.users_tree.delete(item)
            
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Construir query con filtros
            where_conditions = []
            params = []
            
            # Filtro por tipo de usuario
            if hasattr(self, 'user_type_filter') and self.user_type_filter.get() != 'Todos':
                where_conditions.append("tipo_usuario = ?")
                params.append(self.user_type_filter.get())
            
            # Filtro por estado
            if hasattr(self, 'user_status_filter'):
                if self.user_status_filter.get() == 'Activo':
                    where_conditions.append("activo = 1")
                elif self.user_status_filter.get() == 'Inactivo':
                    where_conditions.append("activo = 0")
            
            # Filtro por b√∫squeda de texto
            if hasattr(self, 'user_search_entry') and self.user_search_entry.get().strip():
                search_term = f"%{self.user_search_entry.get().strip()}%"
                where_conditions.append("(nombre LIKE ? OR apellido LIKE ? OR email LIKE ?)")
                params.extend([search_term, search_term, search_term])
            
            where_clause = " WHERE " + " AND ".join(where_conditions) if where_conditions else ""
            
            query = f"""
                SELECT id, nombre, apellido, email, tipo_usuario, activo, ultimo_acceso
                FROM usuarios 
                {where_clause}
                ORDER BY fecha_creacion DESC
            """
            
            cursor.execute(query, params)
            
            for row in cursor.fetchall():
                user_id, nombre, apellido, email, tipo_usuario, activo, ultimo_acceso = row
                
                # Formatear estado
                estado = "Activo" if activo else "Inactivo"
                
                # Formatear √∫ltimo acceso
                if ultimo_acceso:
                    try:
                        dt = datetime.fromisoformat(ultimo_acceso)
                        ultimo_acceso_formatted = dt.strftime('%d/%m/%Y')
                    except:
                        ultimo_acceso_formatted = ultimo_acceso
                else:
                    ultimo_acceso_formatted = "Nunca"
                
                self.users_tree.insert('', 'end', values=(
                    user_id, nombre, apellido, email, tipo_usuario.title(), 
                    estado, ultimo_acceso_formatted
                ))
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error cargando usuarios: {str(e)}")
    
    def load_user_stats(self, parent):
        """Cargar estad√≠sticas de usuarios"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Total de usuarios
            cursor.execute("SELECT COUNT(*) FROM usuarios")
            total_users = cursor.fetchone()[0]
            
            # Usuarios activos
            cursor.execute("SELECT COUNT(*) FROM usuarios WHERE activo = 1")
            active_users = cursor.fetchone()[0]
            
            # Usuarios por tipo
            cursor.execute("SELECT tipo_usuario, COUNT(*) FROM usuarios GROUP BY tipo_usuario")
            user_types = dict(cursor.fetchall())
            
            # Nuevos usuarios esta semana
            week_ago = (datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d')
            cursor.execute("SELECT COUNT(*) FROM usuarios WHERE fecha_creacion >= ?", (week_ago,))
            new_this_week = cursor.fetchone()[0]
            
            stats_text = f"""
üìä Total de Usuarios: {total_users}
‚úÖ Usuarios Activos: {active_users}
‚ùå Usuarios Inactivos: {total_users - active_users}

üëë Administradores: {user_types.get('admin', 0)}
üë®‚Äç‚öïÔ∏è Doctores: {user_types.get('doctor', 0)}
üë©‚Äçüíº Secretarias: {user_types.get('secretaria', 0)}
ü§í Pacientes: {user_types.get('paciente', 0)}

üìÖ Nuevos esta semana: {new_this_week}
            """
            
            tk.Label(parent, text=stats_text, font=('Arial', 9), 
                    justify='left', bg='white').pack()
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            tk.Label(parent, text=f"Error cargando estad√≠sticas: {str(e)}", 
                    fg='red', bg='white').pack()
    
    def on_user_select(self, event):
        """Manejar selecci√≥n de usuario"""
        selection = self.users_tree.selection()
        if selection:
            item = self.users_tree.item(selection[0])
            values = item['values']
            
            if values:
                self.selected_user_id = values[0]
                self.load_selected_user_info()
                self.enable_action_buttons()
                # Actualizar el scroll despu√©s de cargar la informaci√≥n
                self.update_actions_scroll()
        else:
            self.selected_user_id = None
            self.selected_user_data = None
            self.disable_action_buttons()
            self.show_default_info()
    
    def update_actions_scroll(self):
        """Actualizar el √°rea de scroll de las acciones"""
        if hasattr(self, 'actions_canvas') and hasattr(self, 'scrollable_actions_frame'):
            self.scrollable_actions_frame.update_idletasks()
            self.actions_canvas.configure(scrollregion=self.actions_canvas.bbox("all"))
            # Scroll al principio cuando se selecciona un usuario
            self.actions_canvas.yview_moveto(0)
    
    def enable_action_buttons(self):
        """Habilitar botones de acci√≥n"""
        for btn in self.action_buttons:
            btn.config(state='normal')
    
    def disable_action_buttons(self):
        """Deshabilitar botones de acci√≥n"""
        for btn in self.action_buttons:
            btn.config(state='disabled')
    
    def show_default_info(self):
        """Mostrar informaci√≥n por defecto"""
        for widget in self.user_info_frame.winfo_children():
            widget.destroy()
        
        self.user_info_label = tk.Label(self.user_info_frame, 
                                       text="üëÜ Seleccione un usuario de la lista\npara ver sus detalles y opciones", 
                                       font=('Arial', 10), bg='white', fg='#64748B', 
                                       justify='center', wraplength=300)
        self.user_info_label.pack(pady=20)
    
    def load_selected_user_info(self):
        """Cargar informaci√≥n detallada del usuario seleccionado"""
        if not self.selected_user_id:
            return
        
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT u.*, 
                       CASE 
                           WHEN u.tipo_usuario = 'doctor' THEN d.especialidad
                           WHEN u.tipo_usuario = 'paciente' THEN p.numero_expediente
                           ELSE NULL
                       END as info_adicional
                FROM usuarios u
                LEFT JOIN doctores d ON u.id = d.id AND u.tipo_usuario = 'doctor'
                LEFT JOIN pacientes p ON u.id = p.id AND u.tipo_usuario = 'paciente'
                WHERE u.id = ?
            """, (self.selected_user_id,))
            
            user_data = cursor.fetchone()
            if user_data:
                # Convertir a diccionario
                columns = [description[0] for description in cursor.description]
                self.selected_user_data = dict(zip(columns, user_data))
                
                # Actualizar informaci√≥n mostrada
                self.update_user_info_display()
                # Actualizar scroll despu√©s de mostrar informaci√≥n
                self.update_actions_scroll()
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error cargando informaci√≥n del usuario: {str(e)}")
    
    def update_user_info_display(self):
        """Actualizar la visualizaci√≥n simplificada del usuario seleccionado"""
        if not self.selected_user_data:
            return
        
        # Limpiar frame
        for widget in self.user_info_frame.winfo_children():
            widget.destroy()
        
        data = self.selected_user_data
        
        # Solo mostrar encabezado simple con nombre y estado
        header_frame = tk.Frame(self.user_info_frame, bg='#0B5394', height=50)
        header_frame.pack(fill='x', pady=(0, 10))
        header_frame.pack_propagate(False)
        
        # Icono del usuario seg√∫n tipo
        user_icon = "üëë" if data['tipo_usuario'] == 'admin' else \
                   "üë®‚Äç‚öïÔ∏è" if data['tipo_usuario'] == 'doctor' else \
                   "üë©‚Äçüíº" if data['tipo_usuario'] == 'secretaria' else "ü§í"
        
        # Contenido del header
        content_frame = tk.Frame(header_frame, bg='#0B5394')
        content_frame.pack(expand=True, fill='both')
        
        icon_label = tk.Label(content_frame, text=user_icon, font=('Arial', 18), 
                             bg='#0B5394', fg='white')
        icon_label.pack(side='left', padx=15, pady=10)
        
        name_label = tk.Label(content_frame, text=f"{data['nombre']} {data['apellido']}", 
                             font=('Arial', 12, 'bold'), bg='#0B5394', fg='white')
        name_label.pack(side='left', pady=10, anchor='center')
        
        # Estado del usuario
        status_color = "#16A085" if data['activo'] else "#C0392B"
        status_text = "‚óè" if data['activo'] else "‚óè"
        status_label = tk.Label(content_frame, text=status_text, font=('Arial', 20), 
                               bg='#0B5394', fg=status_color)
        status_label.pack(side='right', padx=15, pady=10)
        
        # Los botones de acci√≥n se muestran en el panel derecho
        
    def search_users(self, event=None):
        """Buscar usuarios"""
        self.load_users_list()
    
    def filter_users(self, event=None):
        """Filtrar usuarios"""
        self.load_users_list()
    
    def clear_user_search(self):
        """Limpiar filtros de b√∫squeda"""
        if hasattr(self, 'user_search_entry'):
            self.user_search_entry.delete(0, tk.END)
        if hasattr(self, 'user_type_filter'):
            self.user_type_filter.set('Todos')
        if hasattr(self, 'user_status_filter'):
            self.user_status_filter.set('Todos')
        self.load_users_list()
    
    def refresh_user_list(self):
        """Actualizar lista de usuarios"""
        self.load_users_list()
        messagebox.showinfo("Actualizado", "Lista de usuarios actualizada correctamente")
    
    def add_new_user(self):
        """Abrir ventana para agregar nuevo usuario"""
        self.open_user_form()
    
    def edit_selected_user(self):
        """Editar usuario seleccionado"""
        if not self.selected_user_id:
            messagebox.showwarning("Selecci√≥n requerida", "Por favor seleccione un usuario para editar")
            return
        self.open_user_form(edit_mode=True)
    
    def open_user_form(self, edit_mode=False):
        """Abrir formulario para agregar/editar usuario"""
        form_window = tk.Toplevel()
        title = "Editar Usuario" if edit_mode else "Nuevo Usuario"
        form_window.title(f"{title} - MEDISYNC")
        form_window.geometry("600x700")
        form_window.configure(bg='#F8FAFC')
        form_window.resizable(False, False)
        
        # Centrar ventana
        form_window.transient(self.root)
        form_window.grab_set()
        
        # Header
        header_frame = tk.Frame(form_window, bg='#0B5394', height=60)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        icon = "‚úèÔ∏è" if edit_mode else "‚ûï"
        tk.Label(header_frame, text=f"{icon} {title}", font=('Arial', 16, 'bold'), 
                bg='#0B5394', fg='white').pack(expand=True)
        
        # Contenido principal
        content_frame = tk.Frame(form_window, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True, padx=30, pady=20)
        
        # Variables del formulario
        form_vars = {
            'nombre': tk.StringVar(),
            'apellido': tk.StringVar(),
            'email': tk.StringVar(),
            'telefono': tk.StringVar(),
            'direccion': tk.StringVar(),
            'fecha_nacimiento': tk.StringVar(),
            'tipo_usuario': tk.StringVar(),
            'activo': tk.BooleanVar(value=True),
            'especialidad': tk.StringVar(),  # Para doctores
            'seguro_id': tk.StringVar(),     # Para pacientes
            'contacto_emergencia': tk.StringVar(),  # Para pacientes
            'telefono_emergencia': tk.StringVar(),  # Para pacientes
        }
        
        # Si estamos editando, cargar datos existentes
        if edit_mode and self.selected_user_data:
            data = self.selected_user_data
            form_vars['nombre'].set(data.get('nombre', ''))
            form_vars['apellido'].set(data.get('apellido', ''))
            form_vars['email'].set(data.get('email', ''))
            form_vars['telefono'].set(data.get('telefono', ''))
            form_vars['direccion'].set(data.get('direccion', ''))
            form_vars['fecha_nacimiento'].set(data.get('fecha_nacimiento', ''))
            form_vars['tipo_usuario'].set(data.get('tipo_usuario', 'paciente'))
            form_vars['activo'].set(bool(data.get('activo', True)))
            
            # Cargar datos espec√≠ficos seg√∫n el tipo
            if data.get('tipo_usuario') == 'doctor':
                form_vars['especialidad'].set(data.get('info_adicional', ''))
        
        # Secci√≥n 1: Informaci√≥n Personal
        personal_frame = tk.LabelFrame(content_frame, text="üë§ Informaci√≥n Personal", 
                                     font=('Arial', 12, 'bold'), padx=20, pady=15)
        personal_frame.pack(fill='x', pady=(0, 15))
        
        # Grid para campos personales
        personal_grid = tk.Frame(personal_frame)
        personal_grid.pack(fill='x')
        
        # Nombre y Apellido
        tk.Label(personal_grid, text="Nombre *:", font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky='w', pady=5)
        nombre_entry = tk.Entry(personal_grid, textvariable=form_vars['nombre'], font=('Arial', 10), width=20)
        nombre_entry.grid(row=0, column=1, padx=(10, 20), pady=5, sticky='ew')
        
        tk.Label(personal_grid, text="Apellido *:", font=('Arial', 10, 'bold')).grid(row=0, column=2, sticky='w', pady=5)
        apellido_entry = tk.Entry(personal_grid, textvariable=form_vars['apellido'], font=('Arial', 10), width=20)
        apellido_entry.grid(row=0, column=3, padx=(10, 0), pady=5, sticky='ew')
        
        # Email y Tel√©fono
        tk.Label(personal_grid, text="Email *:", font=('Arial', 10, 'bold')).grid(row=1, column=0, sticky='w', pady=5)
        email_entry = tk.Entry(personal_grid, textvariable=form_vars['email'], font=('Arial', 10), width=20)
        email_entry.grid(row=1, column=1, padx=(10, 20), pady=5, sticky='ew')
        
        tk.Label(personal_grid, text="Tel√©fono:", font=('Arial', 10, 'bold')).grid(row=1, column=2, sticky='w', pady=5)
        telefono_entry = tk.Entry(personal_grid, textvariable=form_vars['telefono'], font=('Arial', 10), width=20)
        telefono_entry.grid(row=1, column=3, padx=(10, 0), pady=5, sticky='ew')
        
        # Fecha de Nacimiento con calendario
        tk.Label(personal_grid, text="Fecha Nacimiento:", font=('Arial', 10, 'bold')).grid(row=2, column=0, sticky='w', pady=5)
        
        fecha_frame = tk.Frame(personal_grid)
        fecha_frame.grid(row=2, column=1, padx=(10, 20), pady=5, sticky='ew')
        
        fecha_entry = tk.Entry(fecha_frame, textvariable=form_vars['fecha_nacimiento'], 
                              font=('Arial', 10), width=15, state='readonly')
        fecha_entry.pack(side='left', fill='x', expand=True)
        
        calendar_btn = tk.Button(fecha_frame, text="üìÖ", font=('Arial', 8), 
                               command=lambda: self.open_calendar(form_vars['fecha_nacimiento']))
        calendar_btn.pack(side='right', padx=(5, 0))
        
        # Direcci√≥n
        tk.Label(personal_grid, text="Direcci√≥n:", font=('Arial', 10, 'bold')).grid(row=2, column=2, sticky='w', pady=5)
        direccion_entry = tk.Entry(personal_grid, textvariable=form_vars['direccion'], font=('Arial', 10), width=20)
        direccion_entry.grid(row=2, column=3, padx=(10, 0), pady=5, sticky='ew')
        
        # Configurar grid weights
        personal_grid.columnconfigure(1, weight=1)
        personal_grid.columnconfigure(3, weight=1)
        
        # Secci√≥n 2: Configuraci√≥n de Usuario
        user_config_frame = tk.LabelFrame(content_frame, text="‚öôÔ∏è Configuraci√≥n de Usuario", 
                                        font=('Arial', 12, 'bold'), padx=20, pady=15)
        user_config_frame.pack(fill='x', pady=(0, 15))
        
        config_grid = tk.Frame(user_config_frame)
        config_grid.pack(fill='x')
        
        # Tipo de Usuario
        tk.Label(config_grid, text="Tipo de Usuario *:", font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky='w', pady=5)
        tipo_combo = ttk.Combobox(config_grid, textvariable=form_vars['tipo_usuario'], 
                                values=['admin', 'doctor', 'secretaria', 'paciente'], 
                                state='readonly', width=18)
        tipo_combo.grid(row=0, column=1, padx=(10, 20), pady=5, sticky='w')
        tipo_combo.bind('<<ComboboxSelected>>', lambda e: self.on_user_type_change(form_vars, specific_frame))
        
        # Estado Activo
        activo_frame = tk.Frame(config_grid)
        activo_frame.grid(row=0, column=2, padx=(10, 0), pady=5, sticky='w')
        
        activo_check = tk.Checkbutton(activo_frame, text="Usuario Activo", 
                                    variable=form_vars['activo'], font=('Arial', 10, 'bold'))
        activo_check.pack()
        
        # Secci√≥n 3: Informaci√≥n Espec√≠fica (din√°mico seg√∫n tipo de usuario)
        specific_frame = tk.LabelFrame(content_frame, text="üìã Informaci√≥n Espec√≠fica", 
                                     font=('Arial', 12, 'bold'), padx=20, pady=15)
        specific_frame.pack(fill='x', pady=(0, 15))
        
        # Contrase√±a (solo para usuarios nuevos)
        if not edit_mode:
            password_frame = tk.LabelFrame(content_frame, text="üîë Contrase√±a", 
                                         font=('Arial', 12, 'bold'), padx=20, pady=15)
            password_frame.pack(fill='x', pady=(0, 15))
            
            password_grid = tk.Frame(password_frame)
            password_grid.pack(fill='x')
            
            form_vars['password'] = tk.StringVar()
            form_vars['confirm_password'] = tk.StringVar()
            
            tk.Label(password_grid, text="Contrase√±a *:", font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky='w', pady=5)
            password_entry = tk.Entry(password_grid, textvariable=form_vars['password'], 
                                    font=('Arial', 10), show='*', width=20)
            password_entry.grid(row=0, column=1, padx=(10, 20), pady=5, sticky='ew')
            
            tk.Label(password_grid, text="Confirmar *:", font=('Arial', 10, 'bold')).grid(row=0, column=2, sticky='w', pady=5)
            confirm_entry = tk.Entry(password_grid, textvariable=form_vars['confirm_password'], 
                                   font=('Arial', 10), show='*', width=20)
            confirm_entry.grid(row=0, column=3, padx=(10, 0), pady=5, sticky='ew')
            
            password_grid.columnconfigure(1, weight=1)
            password_grid.columnconfigure(3, weight=1)
        
        # Botones de acci√≥n
        buttons_frame = tk.Frame(content_frame, bg='#F8FAFC')
        buttons_frame.pack(fill='x', pady=(20, 0))
        
        # Bot√≥n Cancelar
        tk.Button(buttons_frame, text="‚ùå Cancelar", bg='#0B5394', fg='white',
                 font=('Arial', 11, 'bold'), width=15,
                 command=form_window.destroy).pack(side='right', padx=(10, 0))
        
        # Bot√≥n Guardar
        save_text = "üíæ Actualizar" if edit_mode else "üíæ Crear Usuario"
        tk.Button(buttons_frame, text=save_text, bg='#0B5394', fg='white',
                 font=('Arial', 11, 'bold'), width=15,
                 command=lambda: self.save_user(form_vars, form_window, edit_mode, specific_frame)).pack(side='right')
        
        # Inicializar frame espec√≠fico
        self.on_user_type_change(form_vars, specific_frame)
        
        # Enfocar primer campo
        nombre_entry.focus()
    
    def open_calendar(self, date_var):
        """Abrir selector de calendario"""
        try:
            from tkcalendar import DateEntry
            
            calendar_window = tk.Toplevel()
            calendar_window.title("Seleccionar Fecha")
            calendar_window.geometry("300x250")
            calendar_window.resizable(False, False)
            calendar_window.configure(bg='white')
            
            # Centrar ventana
            calendar_window.transient(self.root)
            calendar_window.grab_set()
            
            tk.Label(calendar_window, text="Seleccionar Fecha de Nacimiento", 
                    font=('Arial', 12, 'bold'), bg='white').pack(pady=10)
            
            # DateEntry widget
            cal = DateEntry(calendar_window, width=12, background='darkblue',
                           foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
            cal.pack(pady=20)
            
            # Botones
            btn_frame = tk.Frame(calendar_window, bg='white')
            btn_frame.pack(pady=20)
            
            def select_date():
                selected_date = cal.get_date().strftime('%Y-%m-%d')
                date_var.set(selected_date)
                calendar_window.destroy()
            
            tk.Button(btn_frame, text="Seleccionar", bg='#0B5394', fg='white',
                     font=('Arial', 10, 'bold'), command=select_date).pack(side='left', padx=5)
            tk.Button(btn_frame, text="Cancelar", bg='#0B5394', fg='white',
                     font=('Arial', 10, 'bold'), command=calendar_window.destroy).pack(side='left', padx=5)
            
        except ImportError:
            # Si no est√° disponible tkcalendar, usar entrada manual
            date_dialog = tk.Toplevel()
            date_dialog.title("Introducir Fecha")
            date_dialog.geometry("300x150")
            date_dialog.configure(bg='white')
            
            tk.Label(date_dialog, text="Formato: YYYY-MM-DD", 
                    font=('Arial', 10), bg='white').pack(pady=10)
            
            date_entry = tk.Entry(date_dialog, font=('Arial', 12), width=15)
            date_entry.pack(pady=10)
            
            def save_manual_date():
                date_var.set(date_entry.get())
                date_dialog.destroy()
            
            btn_frame = tk.Frame(date_dialog, bg='white')
            btn_frame.pack(pady=10)
            
            tk.Button(btn_frame, text="Guardar", bg='#0B5394', fg='white',
                     command=save_manual_date).pack(side='left', padx=5)
            tk.Button(btn_frame, text="Cancelar", bg='#0B5394', fg='white',
                     command=date_dialog.destroy).pack(side='left', padx=5)
    
    def on_user_type_change(self, form_vars, specific_frame):
        """Manejar cambio de tipo de usuario"""
        # Limpiar frame espec√≠fico
        for widget in specific_frame.winfo_children():
            widget.destroy()
        
        user_type = form_vars['tipo_usuario'].get()
        
        if user_type == 'doctor':
            self.create_doctor_specific_fields(specific_frame, form_vars)
        elif user_type == 'paciente':
            self.create_patient_specific_fields(specific_frame, form_vars)
        # Para admin y secretaria no necesitan campos adicionales por ahora
    
    def create_doctor_specific_fields(self, parent, form_vars):
        """Crear campos espec√≠ficos para doctores"""
        grid = tk.Frame(parent)
        grid.pack(fill='x')
        
        tk.Label(grid, text="Especialidad *:", font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky='w', pady=5)
        especialidad_entry = tk.Entry(grid, textvariable=form_vars['especialidad'], 
                                    font=('Arial', 10), width=30)
        especialidad_entry.grid(row=0, column=1, padx=(10, 0), pady=5, sticky='ew')
        
        grid.columnconfigure(1, weight=1)
    
    def create_patient_specific_fields(self, parent, form_vars):
        """Crear campos espec√≠ficos para pacientes"""
        grid = tk.Frame(parent)
        grid.pack(fill='x')
        
        # Seguro m√©dico
        tk.Label(grid, text="Seguro M√©dico:", font=('Arial', 10, 'bold')).grid(row=0, column=0, sticky='w', pady=5)
        
        try:
            # Obtener lista de seguros
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            cursor.execute("SELECT id, nombre FROM seguros_medicos ORDER BY nombre")
            seguros = [("", "Sin seguro")] + cursor.fetchall()
            cursor.close()
            conn.close()
            
            seguro_combo = ttk.Combobox(grid, textvariable=form_vars['seguro_id'], 
                                      values=[f"{s[0]}|{s[1]}" for s in seguros], 
                                      state='readonly', width=25)
            seguro_combo.grid(row=0, column=1, padx=(10, 0), pady=5, sticky='ew')
            
        except Exception as e:
            # Si hay error, usar entry simple
            seguro_entry = tk.Entry(grid, textvariable=form_vars['seguro_id'], 
                                  font=('Arial', 10), width=30)
            seguro_entry.grid(row=0, column=1, padx=(10, 0), pady=5, sticky='ew')
        
        # Contacto de emergencia
        tk.Label(grid, text="Contacto Emergencia:", font=('Arial', 10, 'bold')).grid(row=1, column=0, sticky='w', pady=5)
        contacto_entry = tk.Entry(grid, textvariable=form_vars['contacto_emergencia'], 
                                font=('Arial', 10), width=30)
        contacto_entry.grid(row=1, column=1, padx=(10, 0), pady=5, sticky='ew')
        
        # Tel√©fono de emergencia
        tk.Label(grid, text="Tel. Emergencia:", font=('Arial', 10, 'bold')).grid(row=2, column=0, sticky='w', pady=5)
        tel_emerg_entry = tk.Entry(grid, textvariable=form_vars['telefono_emergencia'], 
                                 font=('Arial', 10), width=30)
        tel_emerg_entry.grid(row=2, column=1, padx=(10, 0), pady=5, sticky='ew')
        
        grid.columnconfigure(1, weight=1)
    
    def save_user(self, form_vars, form_window, edit_mode, specific_frame):
        """Guardar usuario (crear o actualizar)"""
        try:
            # Validar campos obligatorios
            if not form_vars['nombre'].get().strip():
                messagebox.showerror("Error", "El nombre es obligatorio")
                return
            
            if not form_vars['apellido'].get().strip():
                messagebox.showerror("Error", "El apellido es obligatorio")
                return
            
            if not form_vars['email'].get().strip():
                messagebox.showerror("Error", "El email es obligatorio")
                return
            
            if not form_vars['tipo_usuario'].get():
                messagebox.showerror("Error", "Debe seleccionar un tipo de usuario")
                return
            
            # Validar contrase√±a para usuarios nuevos
            if not edit_mode:
                if not form_vars['password'].get():
                    messagebox.showerror("Error", "La contrase√±a es obligatoria")
                    return
                
                if form_vars['password'].get() != form_vars['confirm_password'].get():
                    messagebox.showerror("Error", "Las contrase√±as no coinciden")
                    return
            
            # Validar email √∫nico
            if not self.validate_unique_email(form_vars['email'].get(), edit_mode):
                messagebox.showerror("Error", "Ya existe un usuario con este email")
                return
            
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            if edit_mode:
                # Actualizar usuario existente
                cursor.execute("""
                    UPDATE usuarios SET 
                        nombre = ?, apellido = ?, email = ?, telefono = ?, 
                        direccion = ?, fecha_nacimiento = ?, tipo_usuario = ?, activo = ?,
                        fecha_actualizacion = CURRENT_TIMESTAMP
                    WHERE id = ?
                """, (
                    form_vars['nombre'].get().strip(),
                    form_vars['apellido'].get().strip(),
                    form_vars['email'].get().strip(),
                    form_vars['telefono'].get().strip() or None,
                    form_vars['direccion'].get().strip() or None,
                    form_vars['fecha_nacimiento'].get().strip() or None,
                    form_vars['tipo_usuario'].get(),
                    form_vars['activo'].get(),
                    self.selected_user_id
                ))
                
                user_id = self.selected_user_id
                action = "actualizado"
                
            else:
                # Crear nuevo usuario
                password_hash = self.hash_password(form_vars['password'].get())
                
                cursor.execute("""
                    INSERT INTO usuarios (nombre, apellido, email, telefono, direccion, 
                                        fecha_nacimiento, tipo_usuario, password_hash, activo, 
                                        fecha_creacion)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
                """, (
                    form_vars['nombre'].get().strip(),
                    form_vars['apellido'].get().strip(),
                    form_vars['email'].get().strip(),
                    form_vars['telefono'].get().strip() or None,
                    form_vars['direccion'].get().strip() or None,
                    form_vars['fecha_nacimiento'].get().strip() or None,
                    form_vars['tipo_usuario'].get(),
                    password_hash,
                    form_vars['activo'].get()
                ))
                
                user_id = cursor.lastrowid
                action = "creado"
            
            # Guardar informaci√≥n espec√≠fica seg√∫n el tipo de usuario
            user_type = form_vars['tipo_usuario'].get()
            
            if user_type == 'doctor':
                if edit_mode:
                    cursor.execute("DELETE FROM doctores WHERE id = ?", (user_id,))
                
                cursor.execute("""
                    INSERT INTO doctores (id, especialidad)
                    VALUES (?, ?)
                """, (user_id, form_vars['especialidad'].get().strip()))
                
            elif user_type == 'paciente':
                if edit_mode:
                    cursor.execute("DELETE FROM pacientes WHERE id = ?", (user_id,))
                
                # Generar n√∫mero de expediente si no existe
                if not edit_mode:
                    numero_expediente = self.generate_expediente_number()
                else:
                    # Mantener el n√∫mero de expediente existente
                    cursor.execute("SELECT numero_expediente FROM pacientes WHERE id = ?", (user_id,))
                    result = cursor.fetchone()
                    numero_expediente = result[0] if result else self.generate_expediente_number()
                
                # Parsear seguro desde el combobox (formato: "id|nombre")
                seguro_combo_val = (form_vars.get('seguro_id', tk.StringVar()).get() or '').strip()
                seguro_id_val = None
                seguro_nombre_val = None
                if '|' in seguro_combo_val:
                    parts = seguro_combo_val.split('|', 1)
                    seguro_id_val = int(parts[0]) if parts[0].isdigit() else None
                    seguro_nombre_val = parts[1].strip()
                elif seguro_combo_val.isdigit():
                    seguro_id_val = int(seguro_combo_val)
                elif seguro_combo_val:
                    # Si vino texto directo (fallback), guardarlo como nombre
                    seguro_nombre_val = seguro_combo_val

                tiene_seguro = 1 if (seguro_id_val and seguro_id_val != 4) or (seguro_nombre_val and seguro_nombre_val.lower() != 'sin seguro') else 0

                cursor.execute(
                    """
                    INSERT INTO pacientes (id, numero_expediente, seguro_medico, seguro_medico_id,
                                           contacto_emergencia, telefono_emergencia, tiene_seguro)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                    """,
                    (
                        user_id,
                        numero_expediente,
                        seguro_nombre_val,
                        seguro_id_val,
                        form_vars.get('contacto_emergencia', tk.StringVar()).get().strip() or None,
                        form_vars.get('telefono_emergencia', tk.StringVar()).get().strip() or None,
                        tiene_seguro,
                    ),
                )
            
            conn.commit()
            cursor.close()
            conn.close()
            
            messagebox.showinfo("√âxito", f"Usuario {action} exitosamente")
            form_window.destroy()
            self.refresh_user_list()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error guardando usuario: {str(e)}")
            if 'conn' in locals():
                conn.rollback()
    
    def validate_unique_email(self, email, edit_mode):
        """Validar que el email sea √∫nico"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            if edit_mode and hasattr(self, 'selected_user_id'):
                # En modo edici√≥n, excluir el usuario actual
                cursor.execute("SELECT id FROM usuarios WHERE email = ? AND id != ?", 
                             (email, self.selected_user_id))
            else:
                cursor.execute("SELECT id FROM usuarios WHERE email = ?", (email,))
            
            result = cursor.fetchone()
            cursor.close()
            conn.close()
            
            return result is None
            
        except Exception as e:
            print(f"Error validando email: {e}")
            return False
    
    def generate_expediente_number(self):
        """Generar n√∫mero de expediente √∫nico"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Obtener el √∫ltimo n√∫mero de expediente
            cursor.execute("SELECT MAX(CAST(numero_expediente AS INTEGER)) FROM pacientes WHERE numero_expediente REGEXP '^[0-9]+$'")
            result = cursor.fetchone()
            
            if result and result[0]:
                next_number = int(result[0]) + 1
            else:
                next_number = 1001  # Empezar desde 1001
            
            cursor.close()
            conn.close()
            
            return str(next_number).zfill(6)  # Formato: 001001, 001002, etc.
            
        except Exception as e:
            print(f"Error generando expediente: {e}")
            # Fallback: usar timestamp
            return datetime.now().strftime("%Y%m%d%H%M%S")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al guardar usuario: {str(e)}")
    
    def validate_unique_email(self, email, edit_mode):
        """Validar que el email sea √∫nico"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            if edit_mode:
                cursor.execute("SELECT id FROM usuarios WHERE email = ? AND id != ?", 
                             (email, self.selected_user_id))
            else:
                cursor.execute("SELECT id FROM usuarios WHERE email = ?", (email,))
            
            result = cursor.fetchone()
            cursor.close()
            conn.close()
            
            return result is None
            
        except Exception as e:
            print(f"Error validando email: {e}")
            return False
    
    def generate_expediente_number(self):
        """Generar n√∫mero de expediente √∫nico"""
        try:
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            # Obtener el √∫ltimo n√∫mero de expediente
            cursor.execute("SELECT MAX(CAST(numero_expediente AS INTEGER)) FROM pacientes WHERE numero_expediente REGEXP '^[0-9]+$'")
            result = cursor.fetchone()
            
            if result and result[0]:
                next_number = int(result[0]) + 1
            else:
                next_number = 1000  # Empezar desde 1000
            
            cursor.close()
            conn.close()
            
            return str(next_number).zfill(6)  # Formato 000001, 000002, etc.
            
        except Exception as e:
            print(f"Error generando expediente: {e}")
            return datetime.now().strftime('%Y%m%d%H%M%S')  # Fallback
    
    def hash_password(self, password):
        """Hash de contrase√±a simple (en producci√≥n usar bcrypt o similar)"""
        import hashlib
        return hashlib.sha256(password.encode()).hexdigest()
    
    def change_user_password(self):
        """Cambiar contrase√±a del usuario seleccionado"""
        if not self.selected_user_id:
            messagebox.showwarning("Selecci√≥n requerida", "Por favor seleccione un usuario")
            return
        
        # Ventana para cambio de contrase√±a
        pwd_window = tk.Toplevel()
        pwd_window.title("Cambiar Contrase√±a - MEDISYNC")
        pwd_window.geometry("400x250")
        pwd_window.configure(bg='#F8FAFC')
        pwd_window.resizable(False, False)
        
        # Centrar ventana
        pwd_window.transient(self.root)
        pwd_window.grab_set()
        
        # Header
        header_frame = tk.Frame(pwd_window, bg='#0B5394', height=60)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        tk.Label(header_frame, text="üîë Cambiar Contrase√±a", font=('Arial', 14, 'bold'), 
                bg='#0B5394', fg='white').pack(expand=True)
        
        # Contenido
        content_frame = tk.Frame(pwd_window, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True, padx=30, pady=20)
        
        # Informaci√≥n del usuario
        user_info = f"Usuario: {self.selected_user_data.get('nombre', '')} {self.selected_user_data.get('apellido', '')}"
        tk.Label(content_frame, text=user_info, font=('Arial', 11, 'bold'), 
                bg='#F8FAFC', fg='#1E3A8A').pack(pady=(0, 20))
        
        # Variables
        new_password = tk.StringVar()
        confirm_password = tk.StringVar()
        
        # Campos
        tk.Label(content_frame, text="Nueva Contrase√±a:", font=('Arial', 10, 'bold'), 
                bg='#F8FAFC').pack(anchor='w')
        new_pwd_entry = tk.Entry(content_frame, textvariable=new_password, 
                               font=('Arial', 11), show='*', width=30)
        new_pwd_entry.pack(fill='x', pady=(5, 15))
        
        tk.Label(content_frame, text="Confirmar Contrase√±a:", font=('Arial', 10, 'bold'), 
                bg='#F8FAFC').pack(anchor='w')
        confirm_pwd_entry = tk.Entry(content_frame, textvariable=confirm_password, 
                                   font=('Arial', 11), show='*', width=30)
        confirm_pwd_entry.pack(fill='x', pady=(5, 20))
        
        # Botones
        btn_frame = tk.Frame(content_frame, bg='#F8FAFC')
        btn_frame.pack(fill='x')
        
        def save_password():
            if not new_password.get():
                messagebox.showerror("Error", "La nueva contrase√±a es obligatoria")
                return
            
            if new_password.get() != confirm_password.get():
                messagebox.showerror("Error", "Las contrase√±as no coinciden")
                return
            
            if len(new_password.get()) < 6:
                messagebox.showerror("Error", "La contrase√±a debe tener al menos 6 caracteres")
                return
            
            try:
                conn = self.db_manager.get_connection()
                cursor = conn.cursor()
                
                password_hash = self.hash_password(new_password.get())
                cursor.execute("UPDATE usuarios SET password_hash = ? WHERE id = ?", 
                             (password_hash, self.selected_user_id))
                
                conn.commit()
                cursor.close()
                conn.close()
                
                pwd_window.destroy()
                messagebox.showinfo("√âxito", "Contrase√±a actualizada correctamente")
                
            except Exception as e:
                messagebox.showerror("Error", f"Error al cambiar contrase√±a: {str(e)}")
        
        tk.Button(btn_frame, text="‚ùå Cancelar", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), width=12,
                 command=pwd_window.destroy).pack(side='right', padx=(10, 0))
        
        tk.Button(btn_frame, text="üíæ Guardar", bg='#0B5394', fg='white',
                 font=('Arial', 10, 'bold'), width=12,
                 command=save_password).pack(side='right')
        
        new_pwd_entry.focus()
    
    def activate_user(self):
        """Activar usuario seleccionado"""
        if not self.selected_user_id:
            messagebox.showwarning("Selecci√≥n requerida", "Por favor seleccione un usuario")
            return
        
        if self.selected_user_data.get('activo'):
            messagebox.showinfo("Informaci√≥n", "El usuario ya est√° activo")
            return
        
        result = messagebox.askyesno("Confirmar", 
                                   f"¬øEst√° seguro de activar al usuario {self.selected_user_data.get('nombre', '')} {self.selected_user_data.get('apellido', '')}?")
        
        if result:
            try:
                conn = self.db_manager.get_connection()
                cursor = conn.cursor()
                
                cursor.execute("UPDATE usuarios SET activo = 1 WHERE id = ?", (self.selected_user_id,))
                
                conn.commit()
                cursor.close()
                conn.close()
                
                self.load_users_list()
                self.load_selected_user_info()
                messagebox.showinfo("√âxito", "Usuario activado correctamente")
                
            except Exception as e:
                messagebox.showerror("Error", f"Error al activar usuario: {str(e)}")
    
    def deactivate_user(self):
        """Desactivar usuario seleccionado"""
        if not self.selected_user_id:
            messagebox.showwarning("Selecci√≥n requerida", "Por favor seleccione un usuario")
            return
        
        if not self.selected_user_data.get('activo'):
            messagebox.showinfo("Informaci√≥n", "El usuario ya est√° inactivo")
            return
        
        result = messagebox.askyesno("Confirmar", 
                                   f"¬øEst√° seguro de desactivar al usuario {self.selected_user_data.get('nombre', '')} {self.selected_user_data.get('apellido', '')}?\n\nEsto impedir√° que el usuario acceda al sistema.")
        
        if result:
            try:
                conn = self.db_manager.get_connection()
                cursor = conn.cursor()
                
                cursor.execute("UPDATE usuarios SET activo = 0 WHERE id = ?", (self.selected_user_id,))
                
                conn.commit()
                cursor.close()
                conn.close()
                
                self.load_users_list()
                self.load_selected_user_info()
                messagebox.showinfo("√âxito", "Usuario desactivado correctamente")
                
            except Exception as e:
                messagebox.showerror("Error", f"Error al desactivar usuario: {str(e)}")
    
    def view_user_details(self):
        """Ver detalles completos del usuario"""
        if not self.selected_user_id:
            messagebox.showwarning("Selecci√≥n requerida", "Por favor seleccione un usuario")
            return
        
        # Ventana de detalles
        details_window = tk.Toplevel()
        details_window.title("Detalles del Usuario - MEDISYNC")
        details_window.geometry("600x500")
        details_window.configure(bg='#F8FAFC')
        
        # Centrar ventana
        details_window.transient(self.root)
        details_window.grab_set()
        
        # Header
        header_frame = tk.Frame(details_window, bg='#0B5394', height=60)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        tk.Label(header_frame, text="üëÅÔ∏è Detalles del Usuario", font=('Arial', 16, 'bold'), 
                bg='#0B5394', fg='white').pack(expand=True)
        
        # Contenido
        content_frame = tk.Frame(details_window, bg='white')
        content_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Scrollable frame
        canvas = tk.Canvas(content_frame, bg='white')
        scrollbar = ttk.Scrollbar(content_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg='white')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Mostrar informaci√≥n detallada
        data = self.selected_user_data
        
        # Informaci√≥n b√°sica
        basic_frame = tk.LabelFrame(scrollable_frame, text="Informaci√≥n B√°sica", 
                                  font=('Arial', 12, 'bold'), padx=15, pady=10)
        basic_frame.pack(fill='x', pady=(0, 10))
        
        basic_info = [
            ("ID:", str(data.get('id', 'N/A'))),
            ("Nombre completo:", f"{data.get('nombre', '')} {data.get('apellido', '')}"),
            ("Email:", data.get('email', 'N/A')),
            ("Tipo de usuario:", data.get('tipo_usuario', 'N/A').title()),
            ("Estado:", "‚úÖ Activo" if data.get('activo') else "‚ùå Inactivo"),
            ("Tel√©fono:", data.get('telefono', 'No especificado')),
            ("Direcci√≥n:", data.get('direccion', 'No especificada')),
            ("Fecha de nacimiento:", data.get('fecha_nacimiento', 'No especificada')),
            ("Fecha de creaci√≥n:", data.get('fecha_creacion', 'N/A')),
            ("√öltimo acceso:", data.get('ultimo_acceso', 'Nunca'))
        ]
        
        for label, value in basic_info:
            info_frame = tk.Frame(basic_frame, bg='white')
            info_frame.pack(fill='x', pady=2)
            
            tk.Label(info_frame, text=label, font=('Arial', 10, 'bold'), 
                    bg='white', width=20, anchor='w').pack(side='left')
            tk.Label(info_frame, text=value, font=('Arial', 10), 
                    bg='white', anchor='w').pack(side='left', padx=(10, 0))
        
        # Informaci√≥n espec√≠fica seg√∫n tipo
        if data.get('tipo_usuario') == 'doctor':
            doctor_frame = tk.LabelFrame(scrollable_frame, text="Informaci√≥n de Doctor", 
                                       font=('Arial', 12, 'bold'), padx=15, pady=10)
            doctor_frame.pack(fill='x', pady=(0, 10))
            
            tk.Label(doctor_frame, text=f"Especialidad: {data.get('info_adicional', 'No especificada')}", 
                    font=('Arial', 10), bg='white').pack(anchor='w')
        
        elif data.get('tipo_usuario') == 'paciente':
            patient_frame = tk.LabelFrame(scrollable_frame, text="Informaci√≥n de Paciente", 
                                        font=('Arial', 12, 'bold'), padx=15, pady=10)
            patient_frame.pack(fill='x', pady=(0, 10))
            
            tk.Label(patient_frame, text=f"N√∫mero de expediente: {data.get('info_adicional', 'No asignado')}", 
                    font=('Arial', 10), bg='white').pack(anchor='w')
        
        # Bot√≥n cerrar
        btn_frame = tk.Frame(scrollable_frame, bg='white')
        btn_frame.pack(fill='x', pady=20)
        
        tk.Button(btn_frame, text="Cerrar", bg='#0B5394', fg='white',
                 font=('Arial', 11, 'bold'), width=15,
                 command=details_window.destroy).pack()
        
        # Pack scrollable components
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
    
    def send_user_email(self):
        """Enviar email al usuario"""
        if not self.selected_user_id:
            messagebox.showwarning("Selecci√≥n requerida", "Por favor seleccione un usuario")
            return
        
        user_email = self.selected_user_data.get('email', '')
        if not user_email:
            messagebox.showwarning("Email no disponible", "Este usuario no tiene email registrado")
            return
        
        # Crear ventana de composici√≥n de email
        email_window = tk.Toplevel(self.root)
        email_window.title(f"Enviar Email - {self.selected_user_data.get('nombre', '')} {self.selected_user_data.get('apellido', '')}")
        email_window.geometry("500x400")
        email_window.configure(bg='#F8FAFC')
        
        # Header
        header_frame = tk.Frame(email_window, bg='#0B5394', height=60)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        tk.Label(header_frame, text="üìß Enviar Email", font=('Arial', 16, 'bold'), 
                bg='#0B5394', fg='white').pack(expand=True)
        
        # Contenido
        content_frame = tk.Frame(email_window, bg='#F8FAFC')
        content_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Destinatario
        tk.Label(content_frame, text="Para:", font=('Arial', 10, 'bold'), 
                bg='#F8FAFC').pack(anchor='w')
        recipient_entry = tk.Entry(content_frame, font=('Arial', 10), width=50)
        recipient_entry.insert(0, user_email)
        recipient_entry.pack(fill='x', pady=(5, 15))
        
        # Asunto
        tk.Label(content_frame, text="Asunto:", font=('Arial', 10, 'bold'), 
                bg='#F8FAFC').pack(anchor='w')
        subject_entry = tk.Entry(content_frame, font=('Arial', 10))
        subject_entry.pack(fill='x', pady=(5, 15))
        
        # Mensaje
        tk.Label(content_frame, text="Mensaje:", font=('Arial', 10, 'bold'), 
                bg='#F8FAFC').pack(anchor='w')
        message_text = tk.Text(content_frame, height=10, font=('Arial', 10))
        message_text.pack(fill='both', expand=True, pady=(5, 15))
        
        # Botones
        buttons_frame = tk.Frame(content_frame, bg='#F8FAFC')
        buttons_frame.pack(fill='x')
        
        def send_email():
            recipient = recipient_entry.get().strip()
            subject = subject_entry.get().strip()
            message = message_text.get("1.0", tk.END).strip()
            
            if not all([recipient, subject, message]):
                messagebox.showwarning("Campos requeridos", "Por favor complete todos los campos")
                return
            
            # Aqu√≠ ir√≠a la l√≥gica real de env√≠o de email
            messagebox.showinfo("Email Enviado", f"Email enviado exitosamente a {recipient}")
            email_window.destroy()
        
        tk.Button(buttons_frame, text="üìß Enviar", command=send_email,
                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                 padx=20, pady=8).pack(side='right', padx=(10, 0))
        
        tk.Button(buttons_frame, text="‚ùå Cancelar", command=email_window.destroy,
                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                 padx=20, pady=8).pack(side='right')
    
    def view_access_history(self):
        """Ver historial de accesos del usuario"""
        if not self.selected_user_id:
            messagebox.showwarning("Selecci√≥n requerida", "Por favor seleccione un usuario")
            return
        
        try:
            # Crear ventana de historial
            history_window = tk.Toplevel(self.root)
            history_window.title(f"Historial de Accesos - {self.selected_user_data.get('nombre', '')} {self.selected_user_data.get('apellido', '')}")
            history_window.geometry("600x400")
            history_window.configure(bg='#F8FAFC')
            
            # Header
            header_frame = tk.Frame(history_window, bg='#0B5394', height=60)
            header_frame.pack(fill='x')
            header_frame.pack_propagate(False)
            
            tk.Label(header_frame, text="üìã Historial de Accesos", font=('Arial', 16, 'bold'), 
                    bg='#0B5394', fg='white').pack(expand=True)
            
            # Frame para la lista
            list_frame = tk.Frame(history_window, bg='#F8FAFC')
            list_frame.pack(fill='both', expand=True, padx=20, pady=20)
            
            # Treeview para mostrar el historial
            columns = ('Fecha', 'Hora', 'Tipo', 'Detalles')
            history_tree = ttk.Treeview(list_frame, columns=columns, show='headings', height=15)
            
            # Configurar columnas
            history_tree.heading('Fecha', text='Fecha')
            history_tree.heading('Hora', text='Hora') 
            history_tree.heading('Tipo', text='Tipo de Acceso')
            history_tree.heading('Detalles', text='Detalles')
            
            history_tree.column('Fecha', width=100)
            history_tree.column('Hora', width=80)
            history_tree.column('Tipo', width=120)
            history_tree.column('Detalles', width=250)
            
            # Scrollbars
            v_scrollbar = ttk.Scrollbar(list_frame, orient='vertical', command=history_tree.yview)
            h_scrollbar = ttk.Scrollbar(list_frame, orient='horizontal', command=history_tree.xview)
            history_tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
            
            # Empaquetar
            history_tree.pack(side='left', fill='both', expand=True)
            v_scrollbar.pack(side='right', fill='y')
            h_scrollbar.pack(side='bottom', fill='x')
            
            # Datos de ejemplo (en una implementaci√≥n real, vendr√≠an de la base de datos)
            sample_data = [
                ('2025-08-10', '09:15:23', 'Login', 'Inicio de sesi√≥n exitoso'),
                ('2025-08-10', '09:45:12', 'Consulta', 'Consult√≥ lista de pacientes'),
                ('2025-08-10', '10:30:45', 'Edici√≥n', 'Modific√≥ datos de paciente'),
                ('2025-08-09', '14:20:11', 'Login', 'Inicio de sesi√≥n exitoso'),
                ('2025-08-09', '16:55:33', 'Logout', 'Cerr√≥ sesi√≥n'),
                ('2025-08-08', '08:30:22', 'Login', 'Inicio de sesi√≥n exitoso'),
            ]
            
            for item in sample_data:
                history_tree.insert('', 'end', values=item)
            
            # Bot√≥n cerrar
            close_btn = tk.Button(history_window, text="üîô Cerrar", command=history_window.destroy,
                                 bg='#0B5394', fg='white', font=('Arial', 10, 'bold'),
                                 padx=20, pady=8)
            close_btn.pack(pady=10)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al mostrar historial: {str(e)}")
    
    def delete_user(self):
        """Eliminar usuario (con confirmaci√≥n)"""
        if not self.selected_user_id:
            messagebox.showwarning("Selecci√≥n requerida", "Por favor seleccione un usuario")
            return
        
        user_name = f"{self.selected_user_data.get('nombre', '')} {self.selected_user_data.get('apellido', '')}"
        
        result = messagebox.askyesno("Confirmar Eliminaci√≥n", 
                                   f"¬øEst√° COMPLETAMENTE SEGURO de eliminar al usuario {user_name}?\n\n‚ö†Ô∏è ADVERTENCIA: Esta acci√≥n NO se puede deshacer.\n\nSe eliminar√°n todos los datos relacionados con este usuario.")
        
        if result:
            # Segunda confirmaci√≥n
            confirmation = messagebox.askyesno("Confirmaci√≥n Final", 
                                             "¬øConfirma definitivamente la eliminaci√≥n?\n\nEsta es su √∫ltima oportunidad para cancelar.")
            
            if confirmation:
                try:
                    conn = self.db_manager.get_connection()
                    cursor = conn.cursor()
                    
                    # Eliminar de tablas relacionadas primero
                    if self.selected_user_data.get('tipo_usuario') == 'doctor':
                        cursor.execute("DELETE FROM doctores WHERE id = ?", (self.selected_user_id,))
                    elif self.selected_user_data.get('tipo_usuario') == 'paciente':
                        cursor.execute("DELETE FROM pacientes WHERE id = ?", (self.selected_user_id,))
                    
                    # Eliminar citas relacionadas (opcional, dependiendo de la pol√≠tica)
                    # cursor.execute("DELETE FROM citas WHERE doctor_id = ? OR paciente_id = ?", 
                    #              (self.selected_user_id, self.selected_user_id))
                    
                    # Eliminar usuario principal
                    cursor.execute("DELETE FROM usuarios WHERE id = ?", (self.selected_user_id,))
                    
                    conn.commit()
                    cursor.close()
                    conn.close()
                    
                    self.load_users_list()
                    self.selected_user_id = None
                    self.selected_user_data = None
                    
                    # Limpiar informaci√≥n mostrada
                    for widget in self.user_info_frame.winfo_children():
                        widget.destroy()
                    
                    self.user_info_label = tk.Label(self.user_info_frame, 
                                                   text="Usuario eliminado. Seleccione otro usuario.", 
                                                   font=('Arial', 11), bg='white', fg='#C0392B')
                    self.user_info_label.pack()
                    
                    messagebox.showinfo("√âxito", "Usuario eliminado correctamente")
                    
                except Exception as e:
                    messagebox.showerror("Error", f"Error al eliminar usuario: {str(e)}")
    
    # Funciones para pacientes
    def request_appointment(self): 
        """Redirigir a la pesta√±a de citas para solicitar nueva cita"""
        self.switch_patient_tab("appointments")
        
    def view_my_history(self): 
        """Redirigir a la pesta√±a de historial m√©dico"""
        self.switch_patient_tab("history")
        
    def view_my_bills(self): 
        """Redirigir a la pesta√±a de facturaci√≥n"""
        self.switch_patient_tab("billing")
        
    def update_my_profile(self): 
        """Redirigir a la pesta√±a de configuraci√≥n/perfil"""
        self.switch_patient_tab("settings")
    def request_new_appointment(self): messagebox.showinfo("Acci√≥n", "Solicitar nueva cita - En desarrollo")
    
    # NUEVAS FUNCIONES PARA FORMULARIO MEJORADO
    def select_date_enhanced(self, var):
        """Selector de fecha mejorado con calendario visual"""
        try:
            import calendar
            from datetime import datetime, timedelta
            
            # Crear ventana de calendario
            cal_window = tk.Toplevel(self.root)
            cal_window.title("üìÖ Seleccionar Fecha")
            cal_window.geometry("350x400")
            cal_window.configure(bg='#F8FAFC')
            cal_window.transient(self.root)
            cal_window.grab_set()
            cal_window.resizable(False, False)
            
            # Centrar ventana
            cal_window.update_idletasks()
            x = (cal_window.winfo_screenwidth() // 2) - (350 // 2)
            y = (cal_window.winfo_screenheight() // 2) - (400 // 2)
            cal_window.geometry(f"350x400+{x}+{y}")
            
            # Variables para navegaci√≥n
            today = datetime.now()
            current_date = [today.year, today.month]
            
            # Header con navegaci√≥n
            header_frame = tk.Frame(cal_window, bg='#0B5394', height=60)
            header_frame.pack(fill='x')
            header_frame.pack_propagate(False)
            
            nav_frame = tk.Frame(header_frame, bg='#0B5394')
            nav_frame.pack(expand=True, fill='both')
            
            # Bot√≥n mes anterior
            prev_btn = tk.Button(nav_frame, text="‚óÄ", bg='#0B5394', fg='white', 
                               font=('Arial', 14, 'bold'), relief='flat',
                               command=lambda: navigate_month(-1))
            prev_btn.pack(side='left', padx=(20, 0), pady=15)
            
            # Label del mes/a√±o
            month_label = tk.Label(nav_frame, text="", bg='#0B5394', fg='white',
                                 font=('Arial', 14, 'bold'))
            month_label.pack(expand=True, pady=15)
            
            # Bot√≥n mes siguiente
            next_btn = tk.Button(nav_frame, text="‚ñ∂", bg='#0B5394', fg='white',
                               font=('Arial', 14, 'bold'), relief='flat',
                               command=lambda: navigate_month(1))
            next_btn.pack(side='right', padx=(0, 20), pady=15)
            
            # Frame para calendario
            cal_frame = tk.Frame(cal_window, bg='#F8FAFC')
            cal_frame.pack(fill='both', expand=True, padx=20, pady=10)
            
            # D√≠as de la semana
            days_frame = tk.Frame(cal_frame, bg='#F8FAFC')
            days_frame.pack(fill='x', pady=(0, 10))
            
            days = ['Lun', 'Mar', 'Mi√©', 'Jue', 'Vie', 'S√°b', 'Dom']
            for day in days:
                tk.Label(days_frame, text=day, bg='#FFFFFF', fg='#1E3A8A',
                        font=('Arial', 10, 'bold'), width=5, height=2,
                        relief='solid', bd=1).pack(side='left', padx=1, pady=1)
            
            # Frame para d√≠as del mes
            dates_frame = tk.Frame(cal_frame, bg='#F8FAFC')
            dates_frame.pack(fill='both', expand=True)
            
            def navigate_month(direction):
                current_date[1] += direction
                if current_date[1] > 12:
                    current_date[1] = 1
                    current_date[0] += 1
                elif current_date[1] < 1:
                    current_date[1] = 12
                    current_date[0] -= 1
                update_calendar()
            
            def update_calendar():
                # Limpiar frame anterior
                for widget in dates_frame.winfo_children():
                    widget.destroy()
                
                # Actualizar label del mes
                month_names = ['', 'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
                              'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre']
                month_label.config(text=f"{month_names[current_date[1]]} {current_date[0]}")
                
                # Obtener calendario del mes
                cal = calendar.monthcalendar(current_date[0], current_date[1])
                
                for week_num, week in enumerate(cal):
                    week_frame = tk.Frame(dates_frame, bg='#F8FAFC')
                    week_frame.pack(fill='x', pady=1)
                    
                    for day in week:
                        if day == 0:
                            # D√≠a vac√≠o
                            tk.Label(week_frame, text="", width=5, height=2,
                                   bg='#F8FAFC').pack(side='left', padx=1)
                        else:
                            # Determinar color seg√∫n el d√≠a
                            btn_color = '#ffffff'
                            text_color = '#1E3A8A'
                            
                            # Marcar d√≠a actual
                            if (current_date[0] == today.year and 
                                current_date[1] == today.month and day == today.day):
                                btn_color = '#0B5394'
                                text_color = 'white'
                            
                            # Deshabilitar d√≠as pasados
                            date_obj = datetime(current_date[0], current_date[1], day)
                            if date_obj < today.replace(hour=0, minute=0, second=0, microsecond=0):
                                btn_color = '#FFFFFF'
                                text_color = '#CBD5E1'
                                state = 'disabled'
                            else:
                                state = 'normal'
                            
                            def select_day(d=day):
                                selected_date = f"{d:02d}/{current_date[1]:02d}/{current_date[0]}"
                                var.set(selected_date)
                                cal_window.destroy()
                            
                            day_btn = tk.Button(week_frame, text=str(day), 
                                              width=5, height=2, bg=btn_color, fg=text_color,
                                              font=('Arial', 10), relief='solid', bd=1,
                                              command=select_day, state=state, cursor='hand2')
                            day_btn.pack(side='left', padx=1)
            
            # Botones de acci√≥n r√°pida
            quick_frame = tk.Frame(cal_window, bg='#F8FAFC')
            quick_frame.pack(fill='x', padx=20, pady=(0, 20))
            
            quick_dates = [
                ("Hoy", today),
                ("Ma√±ana", today + timedelta(days=1)),
                ("En una semana", today + timedelta(days=7))
            ]
            
            for label, date_obj in quick_dates:
                def select_quick_date(d=date_obj):
                    selected_date = f"{d.day:02d}/{d.month:02d}/{d.year}"
                    var.set(selected_date)
                    cal_window.destroy()
                
                tk.Button(quick_frame, text=label, command=select_quick_date,
                         bg='#0B5394', fg='white', font=('Arial', 9),
                         relief='flat', padx=10, pady=5, cursor='hand2').pack(side='left', padx=5)
            
            # Inicializar calendario
            update_calendar()
            
        except Exception as e:
            # Fallback al selector simple
            self.select_date(var)

    def clear_appointment_form(self, appointment_vars, entries):
        """Limpiar todos los campos del formulario"""
        try:
            # Limpiar variables StringVar
            for var_name, var in appointment_vars.items():
                if var_name == 'estado':
                    var.set('pendiente')
                elif var_name == 'duracion':
                    var.set('60')
                elif var_name == 'tipo_consulta':
                    var.set('general')
                else:
                    var.set('')
            
            # Limpiar widget de texto de observaciones
            if 'observaciones' in entries:
                obs_widget = entries['observaciones']
                if isinstance(obs_widget, tk.Text):
                    obs_widget.delete(1.0, tk.END)
                    obs_widget.insert(1.0, "Ingrese observaciones adicionales, instrucciones especiales, o notas importantes para la cita...")
            
            # Resetear comboboxes
            for key, widget in entries.items():
                if isinstance(widget, ttk.Combobox):
                    if key == 'paciente_id':
                        widget.set("Seleccione un paciente...")
                    elif key == 'doctor_id':
                        widget.set("Seleccione un doctor...")
                    elif key == 'estado':
                        widget.set('pendiente')
                    elif key == 'tipo_consulta':
                        widget.set('general')
                    elif key == 'duracion':
                        widget.set('60')
            
            messagebox.showinfo("‚úÖ Formulario Limpiado", 
                              "Todos los campos han sido restablecidos a sus valores por defecto.")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al limpiar formulario: {str(e)}")

    def setup_form_validation(self, appointment_vars, entries):
        """Configurar validaci√≥n en tiempo real para el formulario"""
        def validate_date(*args):
            date_str = appointment_vars['fecha'].get()
            if date_str:
                try:
                    # Validar formato DD/MM/YYYY
                    datetime.strptime(date_str, '%d/%m/%Y')
                    entries['fecha'].config(bg='#d5f4e6')  # Verde claro
                except ValueError:
                    entries['fecha'].config(bg='#ffeaa7')  # Amarillo claro
            else:
                entries['fecha'].config(bg='white')
        
        def validate_time(*args):
            time_str = appointment_vars['hora'].get()
            if time_str:
                try:
                    # Validar formato HH:MM
                    datetime.strptime(time_str, '%H:%M')
                    entries['hora'].config(bg='#d5f4e6')  # Verde claro
                except ValueError:
                    entries['hora'].config(bg='#ffeaa7')  # Amarillo claro
            else:
                entries['hora'].config(bg='white')
        
        # Configurar validaci√≥n
        appointment_vars['fecha'].trace('w', validate_date)
        appointment_vars['hora'].trace('w', validate_time)

    def save_appointment_enhanced(self, window, appointment_vars, entries):
        """Guardar cita con validaci√≥n mejorada"""
        try:
            # Obtener valores del formulario
            fecha = appointment_vars['fecha'].get().strip()
            hora = appointment_vars['hora'].get().strip()
            paciente_selection = appointment_vars['paciente_id'].get().strip()
            doctor_selection = appointment_vars['doctor_id'].get().strip()
            motivo = appointment_vars['motivo'].get().strip()
            estado = appointment_vars['estado'].get().strip()
            duracion = appointment_vars['duracion'].get().strip()
            tipo_consulta = appointment_vars['tipo_consulta'].get().strip()
            
            # Obtener observaciones del Text widget
            observaciones = ""
            if 'observaciones' in entries:
                obs_widget = entries['observaciones']
                if isinstance(obs_widget, tk.Text):
                    observaciones = obs_widget.get(1.0, tk.END).strip()
                    # Limpiar placeholder text
                    if observaciones.startswith("Ingrese observaciones"):
                        observaciones = ""
            
            # Validaciones mejoradas
            errors = []
            
            if not fecha:
                errors.append("‚Ä¢ La fecha es obligatoria")
            else:
                try:
                    fecha_obj = datetime.strptime(fecha, '%d/%m/%Y')
                    if fecha_obj.date() < datetime.now().date():
                        errors.append("‚Ä¢ La fecha no puede ser anterior a hoy")
                except ValueError:
                    errors.append("‚Ä¢ Formato de fecha inv√°lido (debe ser DD/MM/YYYY)")
            
            if not hora:
                errors.append("‚Ä¢ La hora es obligatoria")
            else:
                try:
                    datetime.strptime(hora, '%H:%M')
                except ValueError:
                    errors.append("‚Ä¢ Formato de hora inv√°lido (debe ser HH:MM)")
            
            if not paciente_selection or paciente_selection.startswith("Seleccione"):
                errors.append("‚Ä¢ Debe seleccionar un paciente")
            
            if not doctor_selection or doctor_selection.startswith("Seleccione"):
                errors.append("‚Ä¢ Debe seleccionar un doctor")
            
            if not motivo:
                errors.append("‚Ä¢ El motivo de la consulta es obligatorio")
            
            if errors:
                error_message = "Por favor corrija los siguientes errores:\n\n" + "\n".join(errors)
                messagebox.showerror("‚ùå Errores en el Formulario", error_message)
                return
            
            # Extraer IDs de las selecciones
            try:
                paciente_id = paciente_selection.split(' - ')[0]
                doctor_id = doctor_selection.split(' - ')[0]
            except:
                messagebox.showerror("Error", "Error al procesar selecciones de paciente/doctor")
                return
            
            # Verificar disponibilidad del horario
            if self.check_appointment_conflict(fecha, hora, doctor_id):
                response = messagebox.askyesno("‚ö†Ô∏è Conflicto de Horario", 
                    "Ya existe una cita programada para este doctor en el mismo horario.\n\n"
                    "¬øDesea programar la cita de todas formas?")
                if not response:
                    return
            
            # Crear diccionario de datos de la cita
            appointment_data = {
                'fecha': fecha,
                'hora': hora,
                'paciente_id': int(paciente_id),
                'doctor_id': int(doctor_id),
                'motivo': motivo,
                'observaciones': observaciones,
                'estado': estado,
                'duracion': int(duracion) if duracion else 60,
                'tipo_consulta': tipo_consulta
            }
            
            # Guardar en la base de datos
            result = self.db_manager.create_appointment(appointment_data)
            
            if result:
                # Mostrar confirmaci√≥n con detalles
                paciente_name = paciente_selection.split(' - ')[1] if ' - ' in paciente_selection else "Paciente"
                doctor_name = doctor_selection.split(' - ')[1] if ' - ' in doctor_selection else "Doctor"
                
                confirmation_msg = f"""‚úÖ ¬°Cita programada exitosamente!

üìÖ Fecha: {fecha}
üïê Hora: {hora}
üë§ Paciente: {paciente_name}
üë®‚Äç‚öïÔ∏è Doctor: {doctor_name}
üí≠ Motivo: {motivo}
üìä Estado: {estado}
‚è±Ô∏è Duraci√≥n: {duracion} minutos

La cita ha sido guardada en el sistema."""
                
                messagebox.showinfo("üéâ Cita Creada", confirmation_msg)
                
                # Refrescar la lista de citas si existe
                if hasattr(self, 'load_appointments_data') and hasattr(self, 'appointments_tree'):
                    self.load_appointments_data(self.appointments_tree)
                
                window.destroy()
            else:
                messagebox.showerror("Error", "No se pudo guardar la cita. Verifique los datos e intente nuevamente.")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error inesperado al guardar la cita:\n{str(e)}")

    def check_appointment_conflict(self, fecha, hora, doctor_id):
        """Verificar si existe conflicto de horario para un doctor"""
        try:
            # Obtener todas las citas del doctor para la fecha
            appointments = self.db_manager.get_all_appointments()
            
            # Convertir hora a objeto time para comparaci√≥n
            new_time = datetime.strptime(hora, '%H:%M').time()
            
            for appointment in appointments:
                # Verificar si es el mismo doctor
                if str(appointment.get('doctor_id')) == str(doctor_id):
                    # Verificar fecha
                    app_fecha = appointment.get('fecha_hora', '')
                    if app_fecha:
                        try:
                            app_dt = datetime.fromisoformat(app_fecha)
                            app_fecha_str = app_dt.strftime('%d/%m/%Y')
                            app_time = app_dt.time()
                            
                            if app_fecha_str == fecha and app_time == new_time:
                                estado = appointment.get('estado', '').lower()
                                if estado not in ['cancelada', 'completada']:
                                    return True
                        except:
                            continue
            
            return False
        except Exception:
            return False
    
    def update_available_hours(self, doctor_var, fecha_var, hora_var, hours_frame):
        """Actualizar horarios disponibles seg√∫n el doctor seleccionado"""
        try:
            doctor_text = doctor_var.get()
            if not doctor_text or "Seleccione" in doctor_text:
                return
            
            # Extraer ID del doctor del texto "ID - Dr. Nombre Apellido"
            doctor_id = doctor_text.split(' - ')[0]
            
            # Limpiar botones de hora anteriores
            for widget in hours_frame.winfo_children():
                widget.destroy()
            
            # Obtener horarios del doctor desde la base de datos
            doctor_hours = self.get_doctor_schedule(doctor_id)
            
            # Si no hay horarios espec√≠ficos, usar horarios por defecto
            if not doctor_hours:
                doctor_hours = ['08:00', '09:00', '10:00', '11:00', '14:00', '15:00', '16:00', '17:00']
            
            # Crear botones para las primeras 4 horas
            for i, time in enumerate(doctor_hours[:4]):
                tk.Button(hours_frame, text=time, 
                         command=lambda t=time: hora_var.set(t),
                         bg='#FFFFFF', fg='#1E3A8A', font=('Arial', 8),
                         relief='flat', padx=5, pady=2, cursor='hand2').pack(side='left', padx=1)
            
            # Agregar bot√≥n "M√°s horarios" si hay m√°s de 4
            if len(doctor_hours) > 4:
                tk.Button(hours_frame, text="‚ãØ", 
                         command=lambda: self.show_more_hours(doctor_hours[4:], hora_var),
                         bg='#E3F2FD', fg='#1E3A8A', font=('Arial', 8, 'bold'),
                         relief='flat', padx=5, pady=2, cursor='hand2').pack(side='left', padx=1)
            
        except Exception as e:
            print(f"Error actualizando horarios: {e}")
    
    def get_doctor_schedule(self, doctor_id):
        """Obtener horarios del doctor desde la base de datos"""
        try:
            # Aqu√≠ puedes implementar la l√≥gica para obtener horarios espec√≠ficos del doctor
            # Por ahora retornamos horarios est√°ndar de consultorio m√©dico
            
            # Horarios comunes para diferentes turnos
            morning_hours = ['08:00', '08:30', '09:00', '09:30', '10:00', '10:30', '11:00', '11:30']
            afternoon_hours = ['14:00', '14:30', '15:00', '15:30', '16:00', '16:30', '17:00', '17:30']
            
            # Combinar horarios de ma√±ana y tarde
            all_hours = morning_hours + afternoon_hours
            
            return all_hours
            
        except Exception as e:
            print(f"Error obteniendo horarios del doctor: {e}")
            return ['08:00', '09:00', '10:00', '11:00', '14:00', '15:00', '16:00', '17:00']
    
    def show_more_hours(self, additional_hours, hora_var):
        """Mostrar ventana con horarios adicionales"""
        try:
            hours_window = tk.Toplevel(self.root)
            hours_window.title("‚è∞ Horarios Disponibles")
            hours_window.geometry("400x300")
            hours_window.configure(bg='#F8FAFC')
            hours_window.transient(self.root)
            hours_window.grab_set()
            hours_window.resizable(False, False)
            
            # Centrar ventana
            hours_window.update_idletasks()
            x = (hours_window.winfo_screenwidth() // 2) - (400 // 2)
            y = (hours_window.winfo_screenheight() // 2) - (300 // 2)
            hours_window.geometry(f"400x300+{x}+{y}")
            
            # Header
            header_frame = tk.Frame(hours_window, bg='#0B5394', height=60)
            header_frame.pack(fill='x')
            header_frame.pack_propagate(False)
            
            tk.Label(header_frame, text="‚è∞ Seleccionar Horario", 
                    font=('Arial', 14, 'bold'), bg='#0B5394', fg='white').pack(expand=True)
            
            # Frame para horarios
            content_frame = tk.Frame(hours_window, bg='#F8FAFC')
            content_frame.pack(fill='both', expand=True, padx=20, pady=20)
            
            # Crear grid de horarios
            hours_per_row = 4
            for i, hour in enumerate(additional_hours):
                row = i // hours_per_row
                col = i % hours_per_row
                
                def select_hour(h=hour):
                    hora_var.set(h)
                    hours_window.destroy()
                
                btn = tk.Button(content_frame, text=hour, 
                               command=select_hour,
                               bg='#FFFFFF', fg='#1E3A8A', font=('Arial', 10),
                               relief='solid', bd=1, padx=15, pady=8, cursor='hand2',
                               width=8)
                btn.grid(row=row, column=col, padx=5, pady=5, sticky='ew')
            
            # Configurar grid
            for i in range(hours_per_row):
                content_frame.columnconfigure(i, weight=1)
            
        except Exception as e:
            print(f"Error mostrando horarios adicionales: {e}")
    
    def set_appointment_hour(self, doctor_var, fecha_var, hour, hours_frame):
        """Establecer hora de la cita y verificar disponibilidad"""
        try:
            # Aqu√≠ podr√≠as agregar verificaci√≥n de disponibilidad
            # Por ahora simplemente establecemos la hora
            
            # Buscar el StringVar de hora en las variables padre
            # Como tenemos acceso limitado, vamos a buscar en el frame padre
            parent_window = hours_frame.winfo_toplevel()
            
            # Buscar el entry de hora en la ventana
            for widget in parent_window.winfo_children():
                if hasattr(widget, 'winfo_children'):
                    self.find_and_set_hour_entry(widget, hour)
            
        except Exception as e:
            print(f"Error estableciendo hora: {e}")
    
    def find_and_set_hour_entry(self, widget, hour):
        """Buscar recursivamente el campo de hora y establecer el valor"""
        try:
            if hasattr(widget, 'winfo_children'):
                for child in widget.winfo_children():
                    if hasattr(child, 'get') and hasattr(child, 'set'):
                        # Es un Entry o similar
                        try:
                            current_val = child.get()
                            if ':' in current_val or len(current_val) == 0:
                                child.delete(0, tk.END)
                                child.insert(0, hour)
                                return True
                        except:
                            pass
                    
                    # Buscar recursivamente
                    if self.find_and_set_hour_entry(child, hour):
                        return True
            return False
        except:
            return False
    
    # Funciones de datos adicionales que faltan
    def get_billing_summary(self): return {}
    def get_secretaria_quick_stats(self):
        """Obtener estad√≠sticas r√°pidas para el panel de secretar√≠a"""
        try:
            conn = self.db_manager.get_connection()
            cur = conn.cursor()
            
            stats = {}
            
            # Citas de hoy
            today = datetime.now().strftime('%Y-%m-%d')
            cur.execute("SELECT COUNT(*) FROM citas WHERE DATE(fecha) = ?", (today,))
            stats['appointments_today'] = cur.fetchone()[0]
            
            # Citas pendientes
            cur.execute("SELECT COUNT(*) FROM citas WHERE estado = 'pendiente'")
            stats['pending_appointments'] = cur.fetchone()[0]
            
            # Citas completadas hoy
            cur.execute("SELECT COUNT(*) FROM citas WHERE DATE(fecha) = ? AND estado = 'completada'", (today,))
            stats['completed_today'] = cur.fetchone()[0]
            
            # Total de pacientes
            cur.execute("SELECT COUNT(*) FROM usuarios WHERE tipo = 'paciente'")
            stats['total_patients'] = cur.fetchone()[0]
            
            # Nuevos pacientes este mes
            first_day_month = datetime.now().replace(day=1).strftime('%Y-%m-%d')
            cur.execute("SELECT COUNT(*) FROM usuarios WHERE tipo = 'paciente' AND DATE(fecha_registro) >= ?", (first_day_month,))
            stats['new_patients_month'] = cur.fetchone()[0]
            
            # Contactos pendientes (aproximaci√≥n)
            stats['pending_contacts'] = 0
            
            # Ingresos hoy
            cur.execute("""
                SELECT COALESCE(SUM(total), 0) 
                FROM facturas 
                WHERE DATE(fecha) = ? AND estado = 'pagada'
            """, (today,))
            stats['today_income'] = cur.fetchone()[0]
            
            # Facturas pendientes
            cur.execute("SELECT COUNT(*) FROM facturas WHERE estado = 'pendiente'")
            stats['pending_invoices'] = cur.fetchone()[0]
            
            # Facturas pagadas hoy
            cur.execute("SELECT COUNT(*) FROM facturas WHERE DATE(fecha) = ? AND estado = 'pagada'", (today,))
            stats['paid_today'] = cur.fetchone()[0]
            
            # Total del mes
            cur.execute("""
                SELECT COALESCE(SUM(total), 0) 
                FROM facturas 
                WHERE DATE(fecha) >= ? AND estado = 'pagada'
            """, (first_day_month,))
            stats['month_total'] = cur.fetchone()[0]
            
            # Doctores activos
            cur.execute("SELECT COUNT(*) FROM usuarios WHERE tipo = 'doctor' AND estado = 'activo'")
            stats['active_doctors'] = cur.fetchone()[0]
            
            # Consultas programadas
            cur.execute("SELECT COUNT(*) FROM citas WHERE estado IN ('pendiente', 'confirmada')")
            stats['scheduled_consultations'] = cur.fetchone()[0]
            
            cur.close()
            conn.close()
            
            return stats
            
        except Exception as e:
            print(f"Error obteniendo estad√≠sticas: {e}")
            return {
                'appointments_today': 0,
                'pending_appointments': 0,
                'completed_today': 0,
                'total_patients': 0,
                'new_patients_month': 0,
                'pending_contacts': 0,
                'today_income': 0,
                'pending_invoices': 0,
                'paid_today': 0,
                'month_total': 0,
                'active_doctors': 0,
                'scheduled_consultations': 0
            }
    def get_patient_health_summary(self): return {}
    def get_patient_billing_summary(self): return {}
    def get_patient_profile_data(self): return self.get_patient_info(self.current_user.id)
    def get_patient_personal_stats(self): return {}

    # ==================== FUNCIONES DE FACTURACI√ìN PARA PACIENTES ====================
    
    def filter_patient_billing(self):
        """Filtrar facturas del paciente seg√∫n per√≠odo y estado"""
        try:
            period = self.billing_period_filter.get()
            status = self.billing_status_filter.get()
            self.load_patient_billing_data(period_filter=period, status_filter=status)
        except Exception as e:
            print(f"Error filtrando facturas: {e}")
            self.load_patient_billing_data()
    
    def clear_billing_filters(self):
        """Limpiar filtros de facturaci√≥n"""
        try:
            self.billing_period_filter.set('Todos')
            self.billing_status_filter.set('Todos')
            self.load_patient_billing_data()
        except Exception as e:
            print(f"Error limpiando filtros: {e}")
    
    def view_billing_detail(self):
        """Ver detalle de factura seleccionada"""
        try:
            selection = self.patient_billing_tree.selection()
            if not selection:
                messagebox.showwarning("Selecci√≥n", "Por favor seleccione una factura para ver detalles")
                return
            
            item = self.patient_billing_tree.item(selection[0])
            values = item['values']
            
            detail_text = f"""üìÑ DETALLE DE FACTURA
            
üî¢ N√∫mero: {values[0]}
üìÖ Fecha: {values[1]}
üè• Servicio: {values[2]}
üí∞ Monto: {values[3]}
üìä Estado: {values[4]}
üìÖ Vencimiento: {values[5]}

Para m√°s informaci√≥n o dudas sobre esta factura,
contacte a secretar√≠a."""
            
            messagebox.showinfo("Detalle de Factura", detail_text)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error mostrando detalle: {e}")
    
    def download_billing_pdf(self):
        """Descargar PDF de factura seleccionada"""
        try:
            selection = self.patient_billing_tree.selection()
            if not selection:
                messagebox.showwarning("Selecci√≥n", "Por favor seleccione una factura para descargar")
                return
            
            item = self.patient_billing_tree.item(selection[0])
            factura_numero = item['values'][0]
            
            messagebox.showinfo("Descarga PDF", 
                              f"üì• Descargando factura {factura_numero}\n\n" +
                              "La funcionalidad de descarga PDF estar√° disponible pr√≥ximamente.")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error descargando PDF: {e}")
    
    def email_my_billing(self):
        """Enviar factura por email"""
        try:
            selection = self.patient_billing_tree.selection()
            if not selection:
                messagebox.showwarning("Selecci√≥n", "Por favor seleccione una factura para enviar")
                return
            
            item = self.patient_billing_tree.item(selection[0])
            factura_numero = item['values'][0]
            
            messagebox.showinfo("Env√≠o por Email", 
                              f"üìß Enviando factura {factura_numero} por email\n\n" +
                              "La factura ser√° enviada a su correo registrado.")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error enviando email: {e}")
    
    def show_billing_summary(self):
        """Mostrar resumen de facturaci√≥n"""
        try:
            summary = self.get_patient_billing_summary()
            
            summary_text = f"""üí∞ RESUMEN DE FACTURACI√ìN
            
üí≥ Total Pagado: RD${summary.get('total_paid', 0):,.2f}
‚è≥ Total Pendiente: RD${summary.get('total_pending', 0):,.2f}
üìã Total de Facturas: {summary.get('total_invoices', 0)}
üìÖ Total Este Mes: RD${summary.get('month_total', 0):,.2f}

Estado de cuenta actualizado al {datetime.now().strftime('%d/%m/%Y')}"""
            
            messagebox.showinfo("Resumen Financiero", summary_text)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error mostrando resumen: {e}")


    def view_history_detail_simple(self, event=None):
        """Ver detalles del registro seleccionado en la tabla"""
        try:
            selection = self.medical_history_tree.selection()
            if not selection:
                messagebox.showwarning("Advertencia", "Por favor seleccione un registro para ver los detalles")
                return
            
            # Obtener el ID del registro
            item = self.medical_history_tree.item(selection[0])
            item_id = selection[0]
            
            # Obtener el ID del registro desde el diccionario
            if hasattr(self, 'history_record_ids') and item_id in self.history_record_ids:
                record_id = self.history_record_ids[item_id]
            else:
                messagebox.showerror("Error", "No se pudo obtener la informaci√≥n del registro")
                return
            
            # Obtener datos completos del registro
            conn = self.db_manager.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT 
                    hm.id,
                    hm.fecha_consulta,
                    u.nombre || ' ' || u.apellido as doctor_nombre,
                    COALESCE(d.especialidad, 'Medicina General') as especialidad,
                    COALESCE(hm.diagnostico, 'No especificado') as diagnostico,
                    COALESCE(hm.tratamiento, 'No especificado') as tratamiento,
                    COALESCE(hm.observaciones, 'Sin observaciones') as observaciones,
                    COALESCE(hm.medicamentos, 'No prescritos') as medicamentos,
                    COALESCE(hm.sintomas, 'No registrados') as sintomas,
                    COALESCE(hm.motivo_consulta, 'No especificado') as motivo_consulta
                FROM historial_medico hm
                JOIN usuarios u ON u.id = hm.doctor_id
                LEFT JOIN doctores d ON d.id = hm.doctor_id
                WHERE hm.id = ?
            """, (record_id,))
            
            record = cursor.fetchone()
            cursor.close()
            conn.close()
            
            if not record:
                messagebox.showerror("Error", "No se encontraron los detalles del registro")
                return
            
            # Crear ventana de detalles
            detail_window = tk.Toplevel(self.root)
            detail_window.title(f"Detalle M√©dico - {record[1]}")
            detail_window.geometry("700x600")
            detail_window.configure(bg='#F8FAFC')
            detail_window.transient(self.root)
            detail_window.grab_set()
            
            # Header
            header = tk.Frame(detail_window, bg='#1E3A8A', height=60)
            header.pack(fill='x')
            header.pack_propagate(False)
            
            header_content = tk.Frame(header, bg='#1E3A8A')
            header_content.pack(expand=True, fill='both', padx=20, pady=10)
            
            tk.Label(header_content, text="üìã Detalle Completo del Registro M√©dico", 
                    font=('Arial', 14, 'bold'), bg='#1E3A8A', fg='white').pack(side='left')
            
            tk.Button(header_content, text="‚úï Cerrar", 
                     command=detail_window.destroy,
                     bg='#DC2626', fg='white', font=('Arial', 10, 'bold'),
                     relief='flat', padx=12, pady=4).pack(side='right')
            
            # Contenido con scroll
            main_frame = tk.Frame(detail_window, bg='#F8FAFC')
            main_frame.pack(fill='both', expand=True, padx=20, pady=20)
            
            canvas = tk.Canvas(main_frame, bg='#F8FAFC', highlightthickness=0)
            scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
            scrollable_frame = tk.Frame(canvas, bg='#F8FAFC')
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # Informaci√≥n b√°sica
            basic_info = tk.LabelFrame(scrollable_frame, text="üìä Informaci√≥n B√°sica", 
                                      font=('Arial', 12, 'bold'), bg='white', padx=15, pady=10)
            basic_info.pack(fill='x', pady=(0, 10))
            
            basic_data = [
                ("üìÖ Fecha de Consulta:", record[1]),
                ("üë®‚Äç‚öïÔ∏è Doctor:", record[2]),
                ("üè• Especialidad:", record[3]),
                ("üÜî ID Registro:", str(record[0]))
            ]
            
            for label, value in basic_data:
                row = tk.Frame(basic_info, bg='white')
                row.pack(fill='x', pady=3)
                tk.Label(row, text=label, font=('Arial', 10, 'bold'), 
                        bg='white', fg='#374151', width=20, anchor='w').pack(side='left')
                tk.Label(row, text=value, font=('Arial', 10), 
                        bg='white', fg='#1E3A8A', anchor='w').pack(side='left', padx=(10, 0))
            
            # Informaci√≥n m√©dica
            medical_info = tk.LabelFrame(scrollable_frame, text="ü©∫ Informaci√≥n M√©dica", 
                                        font=('Arial', 12, 'bold'), bg='white', padx=15, pady=10)
            medical_info.pack(fill='x', pady=(0, 10))
            
            # Motivo de consulta
            if record[9] and record[9] != 'No especificado':
                motivo_frame = tk.Frame(medical_info, bg='white')
                motivo_frame.pack(fill='x', pady=5)
                tk.Label(motivo_frame, text="üéØ Motivo de Consulta:", font=('Arial', 10, 'bold'), 
                        bg='white', fg='#374151').pack(anchor='w')
                tk.Text(motivo_frame, height=2, wrap='word', font=('Arial', 10), 
                       bg='#F8FAFC', relief='solid', bd=1).pack(fill='x', pady=(3, 0))
                motivo_text = motivo_frame.winfo_children()[-1]
                motivo_text.insert('1.0', record[9])
                motivo_text.configure(state='disabled')
            
            # S√≠ntomas
            if record[8] and record[8] != 'No registrados':
                sintomas_frame = tk.Frame(medical_info, bg='white')
                sintomas_frame.pack(fill='x', pady=5)
                tk.Label(sintomas_frame, text="ü§í S√≠ntomas:", font=('Arial', 10, 'bold'), 
                        bg='white', fg='#374151').pack(anchor='w')
                tk.Text(sintomas_frame, height=2, wrap='word', font=('Arial', 10), 
                       bg='#F8FAFC', relief='solid', bd=1).pack(fill='x', pady=(3, 0))
                sintomas_text = sintomas_frame.winfo_children()[-1]
                sintomas_text.insert('1.0', record[8])
                sintomas_text.configure(state='disabled')
            
            # Diagn√≥stico
            diag_frame = tk.Frame(medical_info, bg='white')
            diag_frame.pack(fill='x', pady=5)
            tk.Label(diag_frame, text="üîç Diagn√≥stico:", font=('Arial', 10, 'bold'), 
                    bg='white', fg='#374151').pack(anchor='w')
            tk.Text(diag_frame, height=3, wrap='word', font=('Arial', 10), 
                   bg='#F8FAFC', relief='solid', bd=1).pack(fill='x', pady=(3, 0))
            diag_text = diag_frame.winfo_children()[-1]
            diag_text.insert('1.0', record[4])
            diag_text.configure(state='disabled')
            
            # Tratamiento
            treat_frame = tk.Frame(medical_info, bg='white')
            treat_frame.pack(fill='x', pady=5)
            tk.Label(treat_frame, text="üíä Tratamiento:", font=('Arial', 10, 'bold'), 
                    bg='white', fg='#374151').pack(anchor='w')
            tk.Text(treat_frame, height=3, wrap='word', font=('Arial', 10), 
                   bg='#F8FAFC', relief='solid', bd=1).pack(fill='x', pady=(3, 0))
            treat_text = treat_frame.winfo_children()[-1]
            treat_text.insert('1.0', record[5])
            treat_text.configure(state='disabled')
            
            # Medicamentos
            if record[7] and record[7] != 'No prescritos':
                med_frame = tk.Frame(medical_info, bg='white')
                med_frame.pack(fill='x', pady=5)
                tk.Label(med_frame, text="üíâ Medicamentos:", font=('Arial', 10, 'bold'), 
                        bg='white', fg='#374151').pack(anchor='w')
                tk.Text(med_frame, height=2, wrap='word', font=('Arial', 10), 
                       bg='#F8FAFC', relief='solid', bd=1).pack(fill='x', pady=(3, 0))
                med_text = med_frame.winfo_children()[-1]
                med_text.insert('1.0', record[7])
                med_text.configure(state='disabled')
            
            # Observaciones del doctor
            if record[6] and record[6] != 'Sin observaciones':
                obs_info = tk.LabelFrame(scrollable_frame, text="üìù Observaciones del Doctor", 
                                        font=('Arial', 12, 'bold'), bg='white', padx=15, pady=10)
                obs_info.pack(fill='x', pady=(0, 10))
                
                obs_text = tk.Text(obs_info, height=6, wrap='word', font=('Arial', 10), 
                                  bg='#F8FAFC', relief='solid', bd=1)
                obs_text.pack(fill='both', expand=True)
                obs_text.insert('1.0', record[6])
                obs_text.configure(state='disabled')
            
            # Pack canvas y scrollbar
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # Bind scroll del mouse
            def _on_mousewheel(event):
                canvas.yview_scroll(int(-1*(event.delta/120)), "units")
            canvas.bind_all("<MouseWheel>", _on_mousewheel)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al mostrar detalles: {str(e)}")
            print(f"Error en view_history_detail_simple: {e}")

if __name__ == "__main__":
    app = MedisyncApp()
